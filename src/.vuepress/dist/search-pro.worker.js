const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":321,\"nextId\":321,\"documentIds\":{\"0\":\"0\",\"1\":\"0#🎉-欢迎使用-easydb\",\"2\":\"0#🚀-核心功能与主要特性\",\"3\":\"1\",\"4\":\"1#前言\",\"5\":\"1#整体结构\",\"6\":\"1#前端\",\"7\":\"1#后端\",\"8\":\"1#easydb-模块依赖与职责概述\",\"9\":\"1#模块职责\",\"10\":\"1#开发环境与运行示例\",\"11\":\"1#开发环境\",\"12\":\"1#运行示例\",\"13\":\"1#springboot\",\"14\":\"1#使用maven编译项目\",\"15\":\"1#通过-intellij-idea-配置和启动-easydb-项目\",\"16\":\"1#步骤一-配置-com-dyx-simpledb-backend-launcher-启动项\",\"17\":\"1#步骤二-启动-com-dyx-simpledb-client-launcher-进行交互\",\"18\":\"1@0\",\"19\":\"2\",\"20\":\"2#核心功能指南\",\"21\":\"2#表的创建与管理\",\"22\":\"2#数据操作-crud\",\"23\":\"2#事务管理\",\"24\":\"2#注意事项\",\"25\":\"3\",\"26\":\"3#前言\",\"27\":\"3@0\",\"28\":\"3@1\",\"29\":\"4\",\"30\":\"4#c-s-通信机制\",\"31\":\"4#package-类\",\"32\":\"4#encoder-类\",\"33\":\"4#transporter-类\",\"34\":\"4#packager-类\",\"35\":\"4#服务器与客户端实现\",\"36\":\"4#服务器实现\",\"37\":\"4#客户端实现\",\"38\":\"4@0\",\"39\":\"4@1\",\"40\":\"5\",\"41\":\"5#websocket-通信与数据库管理系统整合教程\",\"42\":\"5#websocket-通信基础\",\"43\":\"5#websocket-处理器-terminalwebsockethandler\",\"44\":\"5#初始化与销毁数据库\",\"45\":\"5#websocket-握手拦截器-httpsessionhandshakeinterceptor\",\"46\":\"5#用户会话管理-usermanager-与-usersession\",\"47\":\"5@0\",\"48\":\"5@1\",\"49\":\"6\",\"50\":\"6#引用计数缓存框架\",\"51\":\"6#回源\",\"52\":\"6#引用计数策略的优势\",\"53\":\"6#实际应用中的回源与缓存管理\",\"54\":\"6#引用计数缓存框架的实现\",\"55\":\"6#abstractcache-t-抽象类\",\"56\":\"6#引用计数管理\",\"57\":\"6#获取资源-get-long-key\",\"58\":\"6#释放资源-release-long-key\",\"59\":\"6#关闭缓存-close\",\"60\":\"6#总结\",\"61\":\"6@0\",\"62\":\"6@1\",\"63\":\"7\",\"64\":\"7#dataitem-的实现\",\"65\":\"7#dataitem-的数据结构\",\"66\":\"7#dataitem-的关键方法\",\"67\":\"7#datamanager-的实现\",\"68\":\"7#datamanager-的核心功能\",\"69\":\"7#datamanager-的-uid-的生成与解析\",\"70\":\"7#getforcache\",\"71\":\"7#releaseforcache\",\"72\":\"7#datamanager-的核心方法\",\"73\":\"7#datamanager-的初始化\",\"74\":\"7#总结\",\"75\":\"7@0\",\"76\":\"7@1\",\"77\":\"8\",\"78\":\"8#easydb-崩溃恢复功能概述\",\"79\":\"8#日志格式与结构\",\"80\":\"8#日志文件的校验和\",\"81\":\"8#日志文件的创建与初始化\",\"82\":\"8#checkandremovetail\",\"83\":\"8#日志迭代与写入\",\"84\":\"8#easydb-恢复策略详解\",\"85\":\"8#恢复策略的基本原理\",\"86\":\"8#单线程环境下的恢复\",\"87\":\"8#多线程环境下的恢复\",\"88\":\"8#恢复策略的具体实现代码\",\"89\":\"8#日志格式\",\"90\":\"8#重做已完成的事务\",\"91\":\"8#撤销未完成的事务\",\"92\":\"8#插入和更新日志的操作实现\",\"93\":\"8@0\",\"94\":\"8@1\",\"95\":\"9\",\"96\":\"9#页面缓存设计与实现\",\"97\":\"9#页面结构定义\",\"98\":\"9#页面缓存接口定义\",\"99\":\"9#页面缓存的实现\",\"100\":\"9#页面写回文件系统\",\"101\":\"9#新建页面\",\"102\":\"9#限制条件\",\"103\":\"9#页面缓存的操作方法\",\"104\":\"9#getforcache\",\"105\":\"9#releaseforcache\",\"106\":\"9#数据恢复操作\",\"107\":\"9#总结\",\"108\":\"9@0\",\"109\":\"9@1\",\"110\":\"10\",\"111\":\"10#页面索引设计与实现\",\"112\":\"10#页面索引的基本介绍\",\"113\":\"10#pageindex-类的实现\",\"114\":\"10#根据空间大小选择页面-select-int-spacesize\",\"115\":\"10#添加页面信息-add-int-pgno-int-freespace\",\"116\":\"10#填充页面索引-fillpageindex\",\"117\":\"10#总结\",\"118\":\"10@0\",\"119\":\"10@1\",\"120\":\"11\",\"121\":\"11#数据库页面管理\",\"122\":\"11#第一页的特殊用途\",\"123\":\"11#页面数据校验机制\",\"124\":\"11#普通页的管理\",\"125\":\"11#空闲空间偏移量-fso-的管理\",\"126\":\"11#数据插入\",\"127\":\"11@0\",\"128\":\"11@1\",\"129\":\"12\",\"130\":\"12@0\",\"131\":\"12@1\",\"132\":\"13\",\"133\":\"13#java-的数组存储\",\"134\":\"13#subarray-类的实现\",\"135\":\"13#案例演示\",\"136\":\"13#案例代码\",\"137\":\"13#演示结果\",\"138\":\"13#总结\",\"139\":\"13@0\",\"140\":\"13@1\",\"141\":\"14\",\"142\":\"14#前言\",\"143\":\"14#二叉树索引结构\",\"144\":\"14#根节点的初始化\",\"145\":\"14#搜索与插入操作\",\"146\":\"14#根节点的管理\",\"147\":\"14#错误处理与恢复\",\"148\":\"14#结语\",\"149\":\"14@0\",\"150\":\"14@1\",\"151\":\"15\",\"152\":\"15#具体实现\",\"153\":\"15#写前分析\",\"154\":\"15#代码实现\",\"155\":\"15#获取所有uid\",\"156\":\"15#查找是否存在索引id\",\"157\":\"15#执行全表查询\",\"158\":\"15#判断是否符合条件\",\"159\":\"15#检查单个条件\",\"160\":\"15#字符串转换为值\",\"161\":\"15#计算条件\",\"162\":\"15@0\",\"163\":\"15@1\",\"164\":\"16\",\"165\":\"16#前言\",\"166\":\"16#索引管理器-im\",\"167\":\"16#全表扫描\",\"168\":\"16@0\",\"169\":\"16@1\",\"170\":\"17\",\"171\":\"17#前言\",\"172\":\"17#整体结构\",\"173\":\"17#前端\",\"174\":\"17#后端\",\"175\":\"17#easydb-模块依赖与职责概述\",\"176\":\"17#模块职责\",\"177\":\"17#开发环境与运行示例\",\"178\":\"17#开发环境\",\"179\":\"17#运行示例\",\"180\":\"17#springboot\",\"181\":\"17#使用maven编译项目\",\"182\":\"17#通过-intellij-idea-配置和启动-easydb-项目\",\"183\":\"17#步骤一-配置-com-dyx-simpledb-backend-launcher-启动项\",\"184\":\"17#步骤二-启动-com-dyx-simpledb-client-launcher-进行交互\",\"185\":\"17@0\",\"186\":\"18\",\"187\":\"18#启动信息管理\",\"188\":\"18#基本定义\",\"189\":\"18#创建与打开启动信息文件\",\"190\":\"18#加载启动信息\",\"191\":\"18#更新启动信息\",\"192\":\"18@0\",\"193\":\"18@1\",\"194\":\"19\",\"195\":\"19#简介\",\"196\":\"19#parse-方法\",\"197\":\"19#解析不同类型的-sql-语句\",\"198\":\"19#解析-select-语句\",\"199\":\"19#解析-insert-语句\",\"200\":\"19#解析-update-语句\",\"201\":\"19#解析-delete-语句\",\"202\":\"19#解析-create-table-语句\",\"203\":\"19#处理事务语句\",\"204\":\"19@0\",\"205\":\"19@1\",\"206\":\"20\",\"207\":\"20#前言\",\"208\":\"20#启动信息管理\",\"209\":\"20#表结构管理与字段约束\",\"210\":\"20#sql解析与事务处理\",\"211\":\"20@0\",\"212\":\"20@1\",\"213\":\"21\",\"214\":\"21#数据库表结构与字段约束的实现\",\"215\":\"21#数据存储结构\",\"216\":\"21#表的存储结构\",\"217\":\"21#字段的存储结构\",\"218\":\"21#表的创建与持久化\",\"219\":\"21#创建表\",\"220\":\"21#字段的创建与约束实现\",\"221\":\"21#字段约束的实现\",\"222\":\"21#隐藏字段的实现\",\"223\":\"21@0\",\"224\":\"21@1\",\"225\":\"22\",\"226\":\"22#基本定义\",\"227\":\"22#loadtables\",\"228\":\"22#create\",\"229\":\"22@0\",\"230\":\"22@1\",\"231\":\"23\",\"232\":\"23@0\",\"233\":\"24\",\"234\":\"24#xid文件结构以及规则\",\"235\":\"24#xid-的定义\",\"236\":\"24#事务的状态\",\"237\":\"24#xid-文件的结构和管理\",\"238\":\"24#transactionmanager-的接口定义\",\"239\":\"24#tm模块的实现\",\"240\":\"24#常量定义\",\"241\":\"24#xid文件的校验与读取\",\"242\":\"24#校验xid文件\",\"243\":\"24#获取xid位置\",\"244\":\"24#事务的开始与状态更新\",\"245\":\"24#开始一个事务-begin\",\"246\":\"24#更新事务状态-updatexid\",\"247\":\"24#增加事务计数-incrxidcounter\",\"248\":\"24#事务状态检查与关闭\",\"249\":\"24#检查事务状态-checkxid\",\"250\":\"24#关闭事务管理器\",\"251\":\"24#_4-总结\",\"252\":\"24@0\",\"253\":\"24@1\",\"254\":\"25\",\"255\":\"25#案例背景\",\"256\":\"25#执行过程\",\"257\":\"25#locktable-详解与实现教程\",\"258\":\"25#locktable-类的概述\",\"259\":\"25#数据结构与字段介绍\",\"260\":\"25#锁请求与等待管理\",\"261\":\"25#死锁检测与路径缓存优化\",\"262\":\"25#死锁检测实现\",\"263\":\"25#路径缓存优化\",\"264\":\"25#超时检测与事务回滚\",\"265\":\"25#超时检测线程\",\"266\":\"25#检查超时并回滚\",\"267\":\"25#回滚事务\",\"268\":\"25#资源释放与重分配\",\"269\":\"25#综合运作流程\",\"270\":\"25@0\",\"271\":\"25@1\",\"272\":\"26\",\"273\":\"26#两段锁协议-2pl-与并发控制\",\"274\":\"26#多版本并发控制-mvcc\",\"275\":\"26#记录的多版本存储与管理\",\"276\":\"26#事务的隔离级别\",\"277\":\"26#版本跳跃问题与解决方案\",\"278\":\"26#死锁检测与处理\",\"279\":\"26#vm-的实现与接口设计\",\"280\":\"26#总结\",\"281\":\"26@0\",\"282\":\"27\",\"283\":\"27#事务隔离级别实现\",\"284\":\"27#读未提交\",\"285\":\"27#读提交\",\"286\":\"27#读提交的事务可见性逻辑\",\"287\":\"27#可重复读\",\"288\":\"27#可重复读的事务可见性逻辑\",\"289\":\"27#串行化\",\"290\":\"27#事务结构\",\"291\":\"27#版本跳跃问题\",\"292\":\"27#版本跳跃的检查\",\"293\":\"27@0\",\"294\":\"27@1\",\"295\":\"28\",\"296\":\"28#_2pl-与-mvcc\",\"297\":\"28#冲突与-2pl\",\"298\":\"28#mvcc\",\"299\":\"28#记录的实现\",\"300\":\"28#entry-格式数据\",\"301\":\"28#entry-结构\",\"302\":\"28#日志格式操作\",\"303\":\"28#wrapentryraw\",\"304\":\"28#data\",\"305\":\"28#setxmax\",\"306\":\"28@0\",\"307\":\"28@1\",\"308\":\"29\",\"309\":\"29#vm-version-manager-的基本定义与实现优化\",\"310\":\"29#具体实现功能的优化\",\"311\":\"29#begin-方法\",\"312\":\"29#commit-方法\",\"313\":\"29#abort-方法\",\"314\":\"29#read-方法\",\"315\":\"29#insert-方法\",\"316\":\"29#delete-方法\",\"317\":\"29#总结\",\"318\":\"29@0\",\"319\":\"29@1\",\"320\":\"30\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[3,13],\"2\":[2,40],\"3\":[1,20],\"4\":[1,23],\"5\":[1,4],\"6\":[1,14],\"7\":[1,28],\"8\":[2,18],\"9\":[1,59],\"10\":[1],\"11\":[1,7],\"12\":[1],\"13\":[1,70],\"14\":[1,39],\"15\":[6,20],\"16\":[3,55],\"17\":[3,34],\"18\":[null,null,1],\"19\":[1,6],\"20\":[1],\"21\":[1,34],\"22\":[1,34],\"23\":[1,23],\"24\":[1,15],\"25\":[2],\"26\":[1,41],\"27\":[null,null,1],\"28\":[null,null,2],\"29\":[1,28],\"30\":[3,10],\"31\":[2,28],\"32\":[2,41],\"33\":[2,54],\"34\":[2,29],\"35\":[1],\"36\":[1,45],\"37\":[1,76],\"38\":[null,null,1],\"39\":[null,null,1],\"40\":[1,6],\"41\":[2,16],\"42\":[2,9],\"43\":[3,106],\"44\":[1,69],\"45\":[3,71],\"46\":[2,170],\"47\":[null,null,1],\"48\":[null,null,1],\"49\":[1,8],\"50\":[1,10],\"51\":[1,15],\"52\":[1,34],\"53\":[1,36],\"54\":[1],\"55\":[1,19],\"56\":[1,20],\"57\":[1,65],\"58\":[1,46],\"59\":[1,34],\"60\":[1,28],\"61\":[null,null,1],\"62\":[null,null,1],\"63\":[2,8],\"64\":[2,31],\"65\":[2,36],\"66\":[2,56],\"67\":[2,19],\"68\":[2,40],\"69\":[4,79],\"70\":[1,59],\"71\":[1,16],\"72\":[2,229],\"73\":[2,40],\"74\":[1,35],\"75\":[null,null,1],\"76\":[null,null,1],\"77\":[1,9],\"78\":[2,12],\"79\":[1,23],\"80\":[1,18],\"81\":[1,48],\"82\":[1,70],\"83\":[1,127],\"84\":[2,14],\"85\":[1,29],\"86\":[1,57],\"87\":[1,59],\"88\":[1],\"89\":[1,28],\"90\":[1,53],\"91\":[1,87],\"92\":[1,70],\"93\":[null,null,1],\"94\":[null,null,1],\"95\":[1,8],\"96\":[1,22],\"97\":[1,28],\"98\":[1,29],\"99\":[1,13],\"100\":[1,58],\"101\":[1,23],\"102\":[1,4],\"103\":[1],\"104\":[1,69],\"105\":[1,19],\"106\":[1,44],\"107\":[1,34],\"108\":[null,null,1],\"109\":[null,null,1],\"110\":[1,8],\"111\":[1,8],\"112\":[1,23],\"113\":[1,27],\"114\":[2,44],\"115\":[2,26],\"116\":[2,42],\"117\":[1,30],\"118\":[null,null,1],\"119\":[null,null,1],\"120\":[1,8],\"121\":[1,10],\"122\":[1,7],\"123\":[1,49],\"124\":[1,9],\"125\":[3,42],\"126\":[1,60],\"127\":[null,null,1],\"128\":[null,null,1],\"129\":[1,86],\"130\":[null,null,1],\"131\":[null,null,5],\"132\":[1,8],\"133\":[2,39],\"134\":[2,21],\"135\":[1,5],\"136\":[1,71],\"137\":[1,27],\"138\":[1,36],\"139\":[null,null,1],\"140\":[null,null,1],\"141\":[1,7],\"142\":[1,28],\"143\":[1,44],\"144\":[1,37],\"145\":[1,64],\"146\":[1,66],\"147\":[1,33],\"148\":[1,31],\"149\":[null,null,1],\"150\":[null,null,1],\"151\":[1,8],\"152\":[1],\"153\":[1,7],\"154\":[1,64],\"155\":[1,29],\"156\":[1,19],\"157\":[1,38],\"158\":[1,39],\"159\":[1,63],\"160\":[1,39],\"161\":[1,48],\"162\":[null,null,1],\"163\":[null,null,1],\"164\":[1],\"165\":[1,19],\"166\":[3,19],\"167\":[1,19],\"168\":[null,null,1],\"169\":[null,null,2],\"170\":[1,20],\"171\":[1,23],\"172\":[1,4],\"173\":[1,14],\"174\":[1,28],\"175\":[2,19],\"176\":[1,59],\"177\":[1],\"178\":[1,7],\"179\":[1],\"180\":[1,70],\"181\":[1,40],\"182\":[6,20],\"183\":[3,55],\"184\":[3,36],\"185\":[null,null,1],\"186\":[1,21],\"187\":[1,25],\"188\":[1,21],\"189\":[1,52],\"190\":[1,22],\"191\":[1,75],\"192\":[null,null,1],\"193\":[null,null,1],\"194\":[1,15],\"195\":[1,20],\"196\":[1,83],\"197\":[3],\"198\":[2,71],\"199\":[2,68],\"200\":[2,35],\"201\":[2,26],\"202\":[2,62],\"203\":[1,60],\"204\":[null,null,1],\"205\":[null,null,1],\"206\":[1],\"207\":[1,19],\"208\":[1,12],\"209\":[1,11],\"210\":[1,16],\"211\":[null,null,1],\"212\":[null,null,5],\"213\":[1,9],\"214\":[1,10],\"215\":[1,4],\"216\":[1,50],\"217\":[1,50],\"218\":[1,8],\"219\":[1,92],\"220\":[1,45],\"221\":[1,44],\"222\":[1,42],\"223\":[null,null,1],\"224\":[null,null,2],\"225\":[2,7],\"226\":[1,87],\"227\":[1,36],\"228\":[1,74],\"229\":[null,null,1],\"230\":[null,null,1],\"231\":[1,43],\"232\":[null,null,1],\"233\":[1,23],\"234\":[1,21],\"235\":[2,12],\"236\":[1,9],\"237\":[2,23],\"238\":[2,29],\"239\":[1],\"240\":[1,37],\"241\":[1],\"242\":[1,67],\"243\":[1,15],\"244\":[1],\"245\":[3,37],\"246\":[3,66],\"247\":[3,38],\"248\":[1],\"249\":[3,53],\"250\":[1,12],\"251\":[2,97],\"252\":[null,null,1],\"253\":[null,null,1],\"254\":[1,8],\"255\":[1,23],\"256\":[1,28],\"257\":[2,8],\"258\":[2,8],\"259\":[1,32],\"260\":[1,51],\"261\":[1,9],\"262\":[1,43],\"263\":[1,14],\"264\":[1,17],\"265\":[1,29],\"266\":[1,39],\"267\":[1,46],\"268\":[1,50],\"269\":[1,41],\"270\":[null,null,1],\"271\":[null,null,3],\"272\":[1,18],\"273\":[3,25],\"274\":[3,27],\"275\":[1,23],\"276\":[1,22],\"277\":[1,13],\"278\":[1,16],\"279\":[2,21],\"280\":[1,15],\"281\":[null,null,1],\"282\":[1,10],\"283\":[1,15],\"284\":[1,37],\"285\":[1,16],\"286\":[1,64],\"287\":[1,12],\"288\":[1,81],\"289\":[1,51],\"290\":[1,58],\"291\":[1,34],\"292\":[1,76],\"293\":[null,null,1],\"294\":[null,null,2],\"295\":[1,28],\"296\":[3],\"297\":[2,73],\"298\":[1,78],\"299\":[1,11],\"300\":[2,9],\"301\":[2,56],\"302\":[1],\"303\":[1,37],\"304\":[1,39],\"305\":[1,54],\"306\":[null,null,1],\"307\":[null,null,1],\"308\":[2,7],\"309\":[4,58],\"310\":[1],\"311\":[1,37],\"312\":[1,43],\"313\":[1,36],\"314\":[1,44],\"315\":[1,30],\"316\":[1,75],\"317\":[1,26],\"318\":[null,null,1],\"319\":[null,null,1],\"320\":[1,3]},\"averageFieldLength\":[1.366411972790298,35.412265094243416,0.48773675031884683],\"storedFields\":{\"0\":{\"h\":\"主页\"},\"1\":{\"h\":\"🎉 欢迎使用 EasyDB\",\"t\":[\"EasyDB 是一个轻量级、高性能的 Java 实现数据库，灵感来源于 MySQL、PostgreSQL 和 SQLite。它旨在为开发者提供一个便捷且功能丰富的数据库解决方案，特别适用于那些需要灵活控制数据管理和优化数据库操作的应用场景。\"]},\"2\":{\"h\":\"🚀 核心功能与主要特性\",\"t\":[\"轻量化构建 EasyDB 基于 Spring Boot 框架构建，简化了启动和配置流程，使其可以轻松集成到现有项目中。通过简洁的配置，开发者可以快速启动并部署 EasyDB，极大地提升开发效率。\",\"高效的数据管理 EasyDB 支持 B+ 树索引结构，提供快速的数据检索与管理能力，即使在大数据量环境下也能保持高效的查询性能。系统内置了丰富的条件约束与主键索引功能，支持唯一性、非空性、自增性等多种约束条件。\",\"并发与事务控制 通过 MVCC（多版本并发控制）和两阶段锁协议（2PL），EasyDB 优化了并发操作，支持多种事务隔离级别，如读未提交、读提交、可重复读和串行化。这些功能确保了高并发环境下的数据一致性与系统性能。\",\"日志与恢复机制 内置的日志管理功能确保了所有数据库操作的可追溯性。通过详细的日志记录，EasyDB 实现了数据一致性保障，并支持故障恢复，增强了系统的容错能力和数据的安全性。\"]},\"3\":{\"h\":\"EasyDB\",\"t\":[\"项目地址：\",\"EasyDB：https://github.com/blockCloth/EasyDB\",\"MYDB：https://github.com/CN-GuoZiyang/MYDB\",\"React Teriminal：https://github.com/Tomotoes/react-terminal\",\"知识星球：https://www.javabetter.cn/zhishixingqiu/\"]},\"4\":{\"h\":\"前言\",\"t\":[\"在一次偶然的机会，通过二哥星球得知了 MYDB 项目。该项目凭借其独特的设计理念和简洁的实现方式，引起了我的极大兴趣。作为一名热衷于数据库技术的开发者，我不仅深刻学习了 MYDB 的核心功能，还萌生了对其进行二次开发的想法。 在深入研究 MYDB 项目的过程中，我发现了该项目的许多亮点，同时也注意到一些可以进一步优化和扩展的地方。因此，我决定在保留其原有设计优势的基础上，增加一些实用的新功能，以满足更多应用场景的需求。通过这些改进，我希望能够让 EasyDB 项目在更多场合下展现出其强大的功能性和灵活性。\"]},\"5\":{\"h\":\"整体结构\",\"t\":[\"EasyDB 的架构分为前端和后端两个部分，各自承担不同的职责：\"]},\"6\":{\"h\":\"前端\",\"t\":[\"前端的职责相对简单，主要任务是读取用户的输入，并将其发送到后端进行处理。处理完成后，前端接收并显示执行结果，等待用户的下一次输入。EasyDB 的前端采用了基于 React Terminal 项目二次开发的解决方案以及基于Socket交互，提供了一个直观的命令行界面，用户可以方便地与数据库进行交互。\"]},\"7\":{\"h\":\"后端\",\"t\":[\"后端则承担了更多的任务，负责解析并执行用户提交的 SQL 语句。如果输入的 SQL 语句合法，后端会尝试执行并返回结果；如果不合法，则会提示用户 SQL 语法错误。在 EasyDB 中，后端支持两种启动方式：\",\"基于 Socket 交互的启动：提供轻量级、低延迟的网络交互。\",\"基于 SpringBoot + React 的启动：集成了现代 Web 框架，为前后端提供更强大的支持和灵活性。\"]},\"8\":{\"h\":\"EasyDB 模块依赖与职责概述\",\"t\":[\"EasyDB 的模块设计遵循一定的依赖关系，通过拓扑排序可以清晰地看到各个模块的实现顺序。在本教程中，模块的实现顺序为：Transaction Manager (TM) -> Data Manager (DM) -> Version Manager (VM) -> Index Manager (IM) -> Table Manager (TBM)。\"]},\"9\":{\"h\":\"模块职责\",\"t\":[\"Transaction Manager (TM)：\",\"职责：TM 负责管理事务的状态，通过维护 XID 文件来跟踪每个事务的状态。它提供接口，供其他模块查询特定事务的状态，从而确保事务的一致性和数据的完整性。\",\"Data Manager (DM)：\",\"职责：DM 直接管理数据库的 DB 文件和日志文件，其主要任务包括： \",\"分页管理：管理 DB 文件并对其进行分页缓存，以提高数据访问的效率。\",\"日志管理：管理日志文件，确保在发生错误时，系统能够根据日志恢复数据，保证数据的一致性。\",\"数据抽象：将 DB 文件抽象为 DataItem，供上层模块使用，同时提供相应的缓存机制。\",\"Version Manager (VM)：\",\"职责：VM 通过实现两阶段锁协议，确保调度序列的可串行化，并通过多版本并发控制（MVCC）消除读写阻塞。VM 支持两种事务隔离级别，以满足不同的并发需求。\",\"Index Manager (IM)：\",\"职责：IM 负责实现基于 B+ 树的数据索引，提升数据检索的效率。目前，where 子句仅支持已建立索引的字段。\",\"Table Manager (TBM)：\",\"职责：TBM 负责管理数据库中的表和字段信息。它还负责解析 SQL 语句，并根据解析结果执行相应的表操作，确保数据的正确性和结构的一致性。\"]},\"10\":{\"h\":\"开发环境与运行示例\"},\"11\":{\"h\":\"开发环境\",\"t\":[\"JDK >= 1.8\",\"Maven >= 3.5\"]},\"12\":{\"h\":\"运行示例\"},\"13\":{\"h\":\"SpringBoot\",\"t\":[\"如果你希望在 Spring Boot 环境下运行 EasyDB，下面是操作步骤：\",\"克隆项目并进入项目目录：\",\"git clone https://github.com/blockCloth/EasyDB.git cd EasyDB\",\"配置数据库路径： 在 application-dev.yml 文件中配置数据库路径，并且在application.yml中切换配置文件，例如：\",\"custom: db: path: D:/JavaCount/mydb/windows/\",\"启动 Spring Boot 应用： 直接在 IDE 中运行 Spring Boot 应用：\",\"@EnableScheduling @SpringBootApplication public class SimpleSqlDatabaseApplication { public static void main(String[] args) { SpringApplication.run(SimpleSqlDatabaseApplication.class, args); } }\",\"访问数据库服务： Spring Boot 应用启动后，数据库服务将会运行在指定的端口（默认为 8081）。你可以通过发送 HTTP 请求或使用 REST 客户端来访问数据库服务。\",\"通过前端客户端进行交互： 你可以在浏览器中访问：\",\"http://localhost:8081/index.html\",\"在页面中你可以输入 SQL 语句，前端会将其发送到后端 Spring Boot 服务进行处理，并显示执行结果。\"]},\"14\":{\"h\":\"使用maven编译项目\",\"t\":[\"首先执行一下命令编译源码：\",\"mvn compile\",\"编译完成后，使用以下命令创建数据库。此命令会在指定路径下创建一个新的数据库实例：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.backend.Launcher\\\"' '-Dexec.args=\\\"-create D:\\\\JavaCount\\\\mydb\\\\windows\\\"'\",\"数据库创建后，使用以下命令启动数据库服务。该服务会在本地机器的 9999 端口运行：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.backend.Launcher\\\"' '-Dexec.args=\\\"-open D:\\\\JavaCount\\\\mydb\\\\windows\\\\test\\\\test\\\"'\",\"打开一个新的终端窗口，执行以下命令启动数据库客户端。这将启动一个交互式命令行界面，用户可以在此输入类 SQL 语法，并将语句发送到数据库服务进行处理，随后返回执行结果：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.client.Launcher\\\"'\",\"执行示例：\"]},\"15\":{\"h\":\"通过 IntelliJ IDEA 配置和启动 EasyDB 项目\",\"t\":[\"在通过 IntelliJ IDEA 启动 EasyDB 项目时，你可以利用启动配置来自动化数据库的创建和启动过程。以下步骤将指导你如何配置 IntelliJ IDEA，使其在启动 com.dyx.simpledb.backend.Launcher 类时，先创建数据库并打开它，随后只需启动 com.dyx.simpledb.client.Launcher 类即可进行交互。\"]},\"16\":{\"h\":\"步骤一：配置 启动项\",\"t\":[\"创建启动配置： \",\"在 IntelliJ IDEA 中，打开 Run --> Edit Configurations。\",\"点击左上角的 + 按钮，选择 Application 以创建一个新的启动配置。\",\"配置数据库创建： \",\"在 Name 字段中输入合适的名称，例如 LauncherStart。\",\"在 Main class 字段中，选择 com.dyx.simpledb.backend.Launcher 作为主类。\",\"在 Program arguments 字段中，输入以下内容以创建数据库：\",\"-create D:/JavaCount/mydb/windows/mydb\",\"设置 Working directory 为项目的根目录，确保所有路径都能正确解析。\",\"配置数据库打开： \",\"重复以上步骤，创建另一个启动配置。将 Program arguments 字段修改为：\",\"-open D:/JavaCount/mydb/windows/mydb\",\"运行启动配置： \",\"首先运行创建数据库的启动配置，等待数据库创建成功。\",\"然后运行打开数据库的启动配置，启动数据库服务。\"]},\"17\":{\"h\":\"步骤二：启动 进行交互\",\"t\":[\"运行客户端： \",\"运行 com.dyx.simpledb.client.Launcher 启动配置，启动客户端。\",\"客户端启动后，将进入交互式命令行，你可以在其中输入 SQL 语句，与数据库进行交互。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb0版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"18\":{\"c\":[\"使用指南\"]},\"19\":{\"h\":\"EasyDB使用文档\",\"t\":[\"本使用文档旨在帮助用户快速上手使用本数据库系统。文档内容主要围绕常见的 SQL 语句和数据库操作，适合初学者和希望快速掌握数据库基本功能的用户。\"]},\"20\":{\"h\":\"核心功能指南\"},\"21\":{\"h\":\"\",\"t\":[\"说明如何在数据库中创建、查看和删除表，介绍表的基本结构和数据类型。\",\"支持的数据类型：int、long、float、double、varchar、datetime\",\"示例：\",\"CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR NOT NULL, email VARCHAR UNIQUE ); // 创建表的语句 SHOW TABLES; // 查看数据库拥有哪些表 SHOW USER; // 查看表结构 DROP TABLE users; // 删除表\"]},\"22\":{\"h\":\"\",\"t\":[\"介绍增（INSERT）、查（SELECT）、改（UPDATE）、删（DELETE）等基本数据操作的 SQL 语句。\",\"示例：\",\"INSERT INTO users (username, email) VALUES ('Alice', 'alice@example.com'); // 指定插入 INSERT INTO users VALUES (10,'Alice', 'alice@example.com'); //全部插入 SELECT * FROM users; // 查询所有字段 SELECT name,email FROM users; //指定查找 UPDATE users SET email = 'alice@newdomain.com' WHERE username = 'Alice'; // 修改用户数据 DELETE FROM users WHERE username = 'Alice'; // 删除用户数据\"]},\"23\":{\"h\":\"\",\"t\":[\"介绍事务的基本概念及其在数据库中的应用，说明如何使用事务控制命令。\",\"示例：\",\"BEGIN; // 开启默认事务，读已提交 BEGIN ISOLATION LEVEL <ISOLATION_LEVEL>; 开启指定事务的隔离级别 ISOLATION_LEVEL： - READ UNCOMMITTED: 读未提交 - READ COMMITTED: 读已提交 - REPEATABLE READ: 可重复读 - SERIALIZABLE: 串行化 COMMIT; //提交事务 ABORT; //回滚事务\"]},\"24\":{\"h\":\"\",\"t\":[\"进行数据库操作之间必须输入init命令进行初始化\",\"通过本使用文档，用户可以快速掌握数据库的基础操作，并有效地进行数据管理和查询。\",\"体验地址：http://db.blockcloth.cn/\",\"项目地址：https://github.com/blockCloth/EasyDB\"]},\"25\":{\"h\":\"EasyDB 通信规则\"},\"26\":{\"h\":\"前言\",\"t\":[\"EasyDB 是一个轻量级的数据库系统，采用 C/S（Client/Server）架构，旨在为开发者提供一个简洁且高效的数据库管理解决方案。EasyDB 支持客户端通过 socket 通信与服务器进行交互，执行 SQL 语句并实时获取结果。它的设计和实现类似于 MySQL，并且提供了一套完整的通信机制和核心类，使得开发者可以轻松构建和管理自己的数据库系统。\",\"在本教程中，我们将详细介绍两种实现 EasyDB 的方式。第一部分将讲解如何通过 WebSocket 实现实时的数据库通信管理，这使得客户端能够通过 WebSocket 连接服务器，发送 SQL 命令并即时接收结果。第二部分则聚焦于 EasyDB 的核心通信机制和服务器、客户端的实现，通过 socket 进行数据传输与处理，涵盖了从编码解码到服务器与客户端的整个工作流程。\",\"通过本文，您将全面了解如何使用 WebSocket 和 Socket 技术来构建一个具有高实时性和可扩展性的数据库系统。\"]},\"27\":{\"c\":[\"communication\"]},\"28\":{\"c\":[\"socket\",\"websocket\"]},\"29\":{\"h\":\"服务端与客户端通信协议\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/Launcher.java；com/dyx/simpledb/client/*；\",\"EasyDB 是一个基于 C/S 结构（Client/Server）的数据库系统，类似于 MySQL。它支持启动服务器并允许多个客户端通过 socket 通信连接到服务器，执行 SQL 查询并返回结果。本文将介绍 EasyDB 的通信机制、核心类的实现以及服务器与客户端的工作原理。\"]},\"30\":{\"h\":\"C/S 通信机制\",\"t\":[\"EasyDB 使用了一种自定义的二进制格式用于客户端和服务端之间的通信。虽然这种格式增加了通信的效率，但如果需要，也可以使用明文传输。通信的基本结构是 Package 类，它封装了传输的数据和可能发生的异常。\"]},\"31\":{\"h\":\"Package 类\",\"t\":[\"public class Package { byte[] data; Exception err; }\",\"在传输数据之前，每个 Package 实例会通过 Encoder 类编码为字节数组。对方收到后，同样会通过 Encoder 进行解码。编码和解码的规则如下：\",\"[Flag][data]\",\"flag = 0：表示数据正常，data 为传输的实际数据。\",\"flag = 1：表示发生错误，data 为 Exception.getMessage() 返回的错误提示信息。\"]},\"32\":{\"h\":\"Encoder 类\",\"t\":[\"public class Encoder { public byte[] encode(Package pkg) { if(pkg.getErr() != null) { Exception err = pkg.getErr(); String msg = \\\"Internal server error!\\\"; if(err.getMessage() != null) { msg = err.getMessage(); } return Bytes.concat(new byte[]{1}, msg.getBytes()); } else { return Bytes.concat(new byte[]{0}, pkg.getData()); } } public Package decode(byte[] data) throws Exception { if(data.length < 1) { throw Error.InvalidPkgDataException; } if(data[0] == 0) { return new Package(Arrays.copyOfRange(data, 1, data.length), null); } else if(data[0] == 1) { return new Package(null, new RuntimeException(new String(Arrays.copyOfRange(data, 1, data.length)))); } else { throw Error.InvalidPkgDataException; } } }\"]},\"33\":{\"h\":\"Transporter 类\",\"t\":[\"Transporter 类负责将编码后的数据通过输出流发送出去。为了避免特殊字符的问题，数据会被转换为十六进制字符串并在末尾加上换行符，这样可以使用 BufferedReader 和 Writer 进行按行读写。\",\"public class Transporter { private Socket socket; private BufferedReader reader; private BufferedWriter writer; public Transporter(Socket socket) throws IOException { this.socket = socket; this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); } public void send(byte[] data) throws Exception { String raw = hexEncode(data); writer.write(raw); writer.flush(); } public byte[] receive() throws Exception { String line = reader.readLine(); if(line == null) { close(); } return hexDecode(line); } public void close() throws IOException { writer.close(); reader.close(); socket.close(); } private String hexEncode(byte[] buf) { return Hex.encodeHexString(buf, true) + \\\"\\\\n\\\"; } private byte[] hexDecode(String buf) throws DecoderException { return Hex.decodeHex(buf); } }\"]},\"34\":{\"h\":\"Packager 类\",\"t\":[\"Packager 类将 Encoder 和 Transporter 结合在一起，提供了更高级别的 send 和 receive 方法。\",\"public class Packager { private Transporter transporter; private Encoder encoder; public Packager(Transporter transporter, Encoder encoder) { this.transporter = transporter; this.encoder = encoder; } public void send(Package pkg) throws Exception { byte[] data = encoder.encode(pkg); transporter.send(data); } public Package receive() throws Exception { byte[] data = transporter.receive(); return encoder.decode(data); } public void close() throws Exception { transporter.close(); } }\"]},\"35\":{\"h\":\"服务器与客户端实现\"},\"36\":{\"h\":\"服务器实现\",\"t\":[\"服务器通过 ServerSocket 启动并监听端口，当有请求到来时，会启动一个新线程处理请求。HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，并循环接收来自客户端的数据进行处理。\",\"Packager packager = null; try { Transporter t = new Transporter(socket); Encoder e = new Encoder(); packager = new Packager(t, e); } catch(IOException e) { e.printStackTrace(); try { socket.close(); } catch (IOException e1) { e1.printStackTrace(); } return; } Executor exe = new Executor(tbm); while(true) { Package pkg = null; try { pkg = packager.receive(); } catch(Exception e) { break; } byte[] sql = pkg.getData(); byte[] result = null; Exception e = null; try { result = exe.execute(sql); } catch (Exception e1) { e = e1; e.printStackTrace(); } pkg = new Package(result, e); try { packager.send(pkg); } catch (Exception e1) { e1.printStackTrace(); break; } }\"]},\"37\":{\"h\":\"客户端实现\",\"t\":[\"客户端通过 Socket 连接到服务器，并实现了一个简单的 Shell，读取用户输入并调用 Client.execute() 方法发送 SQL 语句。\",\"public byte[] execute(byte[] stat) throws Exception { Package pkg = new Package(stat, null); Package resPkg = rt.roundTrip(pkg); if(resPkg.getErr() != null) { throw resPkg.getErr(); } return resPkg.getData(); }\",\"RoundTripper 类实现了单次的收发动作：\",\"public Package roundTrip(Package pkg) throws Exception { packager.send(pkg); return packager.receive(); }\",\"客户端的启动入口如下：\",\"public class Launcher { public static void main(String[] args) throws UnknownHostException, IOException { Socket socket = new Socket(\\\"127.0.0.1\\\", 9999); Encoder e = new Encoder(); Transporter t = new Transporter(socket); Packager packager = new Packager(t, e); Client client = new Client(packager); Shell shell = new Shell(client); shell.run(); } }\",\"注\",\"本文作者：blockCloth本文内容转载自：https://shinya.click/projects/mydb/mydb10版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"38\":{\"c\":[\"communication\"]},\"39\":{\"c\":[\"socket\"]},\"40\":{\"h\":\"基于WebSocket通信协议\",\"t\":[\"本章涉及代码：com/dyx/simpledb/websocket/*\"]},\"41\":{\"h\":\"WebSocket 通信与数据库管理系统整合教程\",\"t\":[\"在本教程中，我们将讲解如何使用 Spring 框架实现一个基于 WebSocket 的数据库管理系统。这套系统允许客户端通过 WebSocket 连接到服务器，执行 SQL 命令并实时获取结果。整个实现涵盖了 WebSocket 通信、用户会话管理、数据库初始化与销毁等多个重要功能模块。\"]},\"42\":{\"h\":\"WebSocket 通信基础\",\"t\":[\"WebSocket 是一种全双工通信协议，它允许服务器和客户端之间进行实时、双向的数据交换。在我们的系统中，WebSocket 用于接收客户端的 SQL 命令并返回执行结果。\"]},\"43\":{\"h\":\"WebSocket 处理器：\",\"t\":[\"TerminalWebSocketHandler 是处理 WebSocket 消息的核心类。它负责解析客户端发送的 SQL 命令，执行数据库操作，并返回执行结果。\",\"线程池管理： 每个 WebSocket 会话都有一个独立的线程池，用于处理该会话的 SQL 命令，保证并发操作的独立性。\",\"SQL 命令解析与执行： 根据客户端发送的 SQL 命令选择相应的处理方法，如数据库初始化或执行具体的 SQL 语句。\",\"@Slf4j @Component public class TerminalWebSocketHandler extends TextWebSocketHandler { @Autowired private UserManager userManager; @Value(\\\"${custom.db.path}\\\") private String dbPath; private final Map<String, ExecutorService> sessionExecutorMap = new ConcurrentHashMap<>(); @Override public void handleTextMessage(WebSocketSession session, TextMessage message) throws IOException { String payload = message.getPayload(); JSONObject jsonObject = new JSONObject(payload); String sql = jsonObject.getStr(\\\"command\\\"); String clientIp = (String) session.getAttributes().get(\\\"clientIp\\\"); String sessionId = session.getId(); // 每个 WebSocket 会话的唯一标识符 log.info(\\\"User with IP: {}, session ID: {} executed SQL: {}\\\", clientIp, sessionId, sql); ExecutorService executorService = sessionExecutorMap.computeIfAbsent(sessionId, key -> Executors.newSingleThreadExecutor()); executorService.submit(() -> { try { if (\\\"init\\\".equalsIgnoreCase(sql.trim()) || \\\"init;\\\".equalsIgnoreCase(sql.trim())) { handleInitCommand(session, clientIp, sessionId); } else { UserSession userSession = userManager.getUserSession(clientIp); if (userSession == null || userSession.getExecutor(sessionId) == null) { session.sendMessage(new TextMessage(createMessage(\\\"Please init database\\\", \\\"error\\\"))); } else { userSession.updateLastAccessedTime(); // 更新最后访问时间 handleSqlCommand(session, userSession, sessionId, sql); } } } catch (IOException e) { e.printStackTrace(); } }); }\"]},\"44\":{\"h\":\"初始化与销毁数据库\",\"t\":[\"handleInitCommand() 方法负责初始化数据库。如果数据库文件尚未存在，该方法将创建新的数据库文件，并在后续操作中加载它。\",\"数据库文件管理： 系统根据客户端 IP 地址为每个用户创建一个独立的数据库文件目录。\",\"初始化与加载： 根据数据库文件是否存在，决定是创建新的数据库还是加载现有的数据库。\",\"private void handleInitCommand(WebSocketSession session, String clientIp, String sessionId) throws IOException { UserSession userSession = userManager.getUserSession(clientIp); if (userSession != null && userSession.getExecutor(sessionId) != null) { session.sendMessage(new TextMessage(createMessage(\\\"Database is already initialized in this session.\\\", \\\"success\\\"))); return; } if (userSession == null) { userSession = new UserSession(clientIp, System.currentTimeMillis()); userManager.addUserSession(clientIp, userSession); } String directoryPath = dbPath + File.separator + clientIp; String dbFilePath = directoryPath + File.separator + clientIp; File ipDirectory = new File(directoryPath); if (!ipDirectory.exists() && !ipDirectory.mkdirs()) { session.sendMessage(new TextMessage(createMessage(\\\"Database init failed: cannot create directory.\\\", \\\"error\\\"))); return; } boolean databaseExists = checkIfDatabaseFilesExist(directoryPath, clientIp); if (databaseExists) { initializeDatabase(userSession, dbFilePath, sessionId); } else { createDatabase(dbFilePath); initializeDatabase(userSession, dbFilePath, sessionId); } session.sendMessage(new TextMessage(createMessage(\\\"Database init and load success!\\\", \\\"success\\\"))); }\"]},\"45\":{\"h\":\"WebSocket 握手拦截器：\",\"t\":[\"HttpSessionHandshakeInterceptor 用于在 WebSocket 握手阶段获取客户端的 IP 地址，并将其存储在 WebSocket 会话的属性中。这在后续操作中用于标识用户和管理会话。\",\"获取客户端 IP 地址： 通过解析 HTTP 请求头信息，获取客户端的真实 IP 地址，支持多重代理的情况下正确识别 IP。\",\"拦截握手请求： 在 WebSocket 握手阶段添加自定义逻辑，以便后续处理使用。\",\"@Component public class HttpSessionHandshakeInterceptor implements HandshakeInterceptor { @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception { if (request instanceof ServletServerHttpRequest) { HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest(); String clientIp = getClientIp(servletRequest); attributes.put(\\\"clientIp\\\", clientIp); } return true; } @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) { } private String getClientIp(HttpServletRequest request) { String clientIp = request.getHeader(\\\"X-Forwarded-For\\\"); if (clientIp != null && !clientIp.isEmpty() && !\\\"unknown\\\".equalsIgnoreCase(clientIp)) { clientIp = clientIp.split(\\\",\\\")[0]; } else { clientIp = request.getRemoteAddr(); } if (\\\"0:0:0:0:0:0:0:1\\\".equals(clientIp)) { clientIp = \\\"127.0.0.1\\\"; } return clientIp; } }\"]},\"46\":{\"h\":\"用户会话管理： 与\",\"t\":[\"UserManager 负责管理所有活跃用户的会话，包括会话的创建、维护和销毁。同时，它还负责定期检查并清理过期的会话及其相关的数据库文件。\",\"最大用户限制： 限制同时活跃的用户数量，确保系统的稳定性。\",\"定期检查与清理： 通过 @Scheduled 注解定期检查用户会话，并清理过期的会话及其数据库文件。\",\"@Component public class UserManager { private static final int MAX_USERS = 20; private static final int SESSION_EXPIRY_CHECK_INTERVAL = 10 * 60 * 1000; private static final int MAX_SESSION_DURATION = 2 * 60 * 60 * 1000; private ConcurrentHashMap<String, UserSession> activeUsers = new ConcurrentHashMap<>(); private AtomicInteger userCount = new AtomicInteger(0); @Value(\\\"${custom.db.path}\\\") private String dbPath; public boolean canInit(String userId) { if (userCount.get() >= MAX_USERS) { return false; } activeUsers.put(userId, new UserSession(userId, System.currentTimeMillis())); userCount.incrementAndGet(); return true; } public UserSession getUserSession(String userId) { return activeUsers.get(userId); } public void addUserSession(String userId, UserSession userSession) { activeUsers.put(userId, userSession); userCount.incrementAndGet(); } public void removeUserSession(String userId) { UserSession session = activeUsers.get(userId); if (session != null) { session.close(); } activeUsers.remove(userId); userCount.decrementAndGet(); } @Scheduled(fixedRate = 60000) public void checkSessions() { long currentTime = System.currentTimeMillis(); activeUsers.forEach((userId, session) -> { if (currentTime - session.getLastAccessedTime() >= SESSION_EXPIRY_CHECK_INTERVAL || currentTime - session.getStartTime() >= MAX_SESSION_DURATION) { removeUserSession(userId); destroyDatabase(userId); } }); } public void destroyDatabase(String userId) { String directoryPath = dbPath + File.separator + userId; Path directory = Paths.get(directoryPath); try { deleteDirectory(directory); } catch (IOException e) { e.printStackTrace(); } } private void deleteDirectory(Path directory) throws IOException { Files.walkFileTree(directory, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { if (exc == null) { Files.delete(dir); return FileVisitResult.CONTINUE; } else { throw exc; } } }); } }\",\"UserSession 类用于表示单个用户的会话信息，包括数据库连接、事务管理器和表管理器等。\",\"会话管理：UserSession 管理每个用户的数据库连接和事务，支持多个 WebSocket 会话。\",\"资源释放： 当用户会话结束时，确保正确关闭数据库连接和释放资源。\",\"@Setter @Getter public class UserSession { private String userId; private long startTime; private long lastAccessedTime; private TableManager tableManager; private TransactionManager transactionManager; private DataManager dataManager; private Map<String,Executor> executorMap; private final Set<String> sessionIds = ConcurrentHashMap.newKeySet(); public UserSession(String userId, long startTime) { this.userId = userId; this.startTime = startTime; this.lastAccessedTime = startTime; executorMap = new HashMap<>(); } public void updateLastAccessedTime() { this.lastAccessedTime = System.currentTimeMillis(); } public void close() { if (dataManager != null) { dataManager.close(); } if (transactionManager != null) { transactionManager.close(); } } public Executor getExecutor(String sessionId) { return executorMap.get(sessionId); } public Executor removeExecutor(String sessionId) { return executorMap.remove(sessionId); } public void setExecutor(String sessionId, Executor executor) { executorMap.put(sessionId,executor); } public void addSession(String sessionId) { sessionIds.add(sessionId); } public void removeSession(String sessionId) { sessionIds.remove(sessionId); } public boolean hasActiveSessions() { return !sessionIds.isEmpty(); } }\",\"注\",\"本文作者：blockCloth版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"47\":{\"c\":[\"communication\"]},\"48\":{\"c\":[\"websocket\"]},\"49\":{\"h\":\"引用计数缓存框架\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/common/AbstractCache.java\"]},\"50\":{\"h\":\"引用计数缓存框架\",\"t\":[\"在数据库系统中，缓存策略对于性能的影响至关重要。传统的 LRU（最近最少使用）策略通常用于管理缓存，但在某些情况下，引用计数策略可能更为有效，尤其是在涉及回源操作时。\"]},\"51\":{\"h\":\"回源\",\"t\":[\"回源操作指的是当需要的数据不在内存缓存中时，从持久化存储（如磁盘）中重新加载数据到内存的过程。由于内存的访问速度远高于磁盘，数据库系统通常尽量将数据保留在内存中以提高性能。当需要访问的数据不在缓存中时，系统必须执行回源操作，从磁盘读取数据并加载到内存。这种操作通常会带来较大的性能开销，因为磁盘 I/O 速度远低于内存访问速度。\"]},\"52\":{\"h\":\"引用计数策略的优势\",\"t\":[\"在 EasyDB 系统中，为了更好地控制资源管理和回源操作，采用了引用计数策略。相比 LRU 策略，引用计数策略通过以下方式优化了回源操作：\",\"资源管理可控：在引用计数策略中，资源的释放由上层模块主动触发，而不是由缓存系统自动决定。这意味着只有在上层模块明确表示不再需要某个资源时，缓存才会将其移除。这种机制避免了 LRU 策略中可能出现的资源被意外驱逐而导致的回源操作。\",\"避免不必要的回源：在 LRU 策略中，资源可能会因为缓存满而被驱逐，导致需要时再从磁盘加载回源。引用计数策略通过引用计数的管理，确保资源只有在引用次数为零时才会被驱逐，这减少了不必要的回源操作，降低了系统的 I/O 开销。\",\"缓存满时的处理：在引用计数策略中，如果缓存已满且没有可释放的资源，系统会直接抛出异常而不是自动驱逐资源。这避免了缓存抖动问题，确保系统在高并发情况下的稳定性。\"]},\"53\":{\"h\":\"实际应用中的回源与缓存管理\",\"t\":[\"在 EasyDB 的引用计数缓存框架中，回源操作的管理通过以下流程实现：\",\"缓存未命中：当系统需要的数据不在缓存中时，首先检查其他线程是否正在获取该资源。如果是，当前线程会稍后再试，避免重复回源。这通过 getting 这个 HashMap 来管理正在获取的资源。\",\"从数据源获取资源：如果缓存未命中且没有其他线程在获取该资源，系统会从磁盘中回源获取数据，并将其加载到缓存中。获取完成后，缓存会记录该资源的引用次数，确保在资源被主动释放前不会被驱逐。\",\"资源释放与驱逐：当上层模块不再需要某个资源时，通过调用 release 方法释放对该资源的引用。如果引用次数归零，缓存会将该资源从内存中移除，确保内存资源的有效利用。\",\"缓存关闭：在系统关闭时，引用计数缓存框架会安全地释放所有资源，并将必要的数据写回磁盘，确保数据的一致性和完整性。\"]},\"54\":{\"h\":\"引用计数缓存框架的实现\"},\"55\":{\"h\":\"抽象类\",\"t\":[\"引用计数缓存框架的核心是 AbstractCache<T> 抽象类，其中包含两个需要子类实现的抽象方法，用于在缓存未命中时获取资源和在资源被驱逐时进行必要的处理：\",\"/** * 当资源不在缓存时的获取行为 */ protected abstract T getForCache(long key) throws Exception; /** * 当资源被驱逐时的写回行为 */ protected abstract void releaseForCache(T obj);\"]},\"56\":{\"h\":\"引用计数管理\",\"t\":[\"为了管理资源的引用计数，AbstractCache 维护了三个核心的 HashMap：\",\"private HashMap<Long, T> cache; // 实际缓存的数据 private HashMap<Long, Integer> references; // 资源的引用个数 private HashMap<Long, Boolean> getting; // 正在获取资源的线程标记\",\"cache：存储实际缓存的数据。\",\"references：记录每个资源的引用计数。\",\"getting：标记哪些资源当前正在从数据源获取，以避免并发情况下重复获取相同的资源。\"]},\"57\":{\"h\":\"获取资源\",\"t\":[\"当需要获取资源时，get(long key) 方法会首先检查资源是否已经在缓存中，如果在，则增加其引用计数并返回。如果不在，则通过 getForCache 方法从数据源获取资源并缓存。\",\"//从缓存中获取资源 protected T get(long key) throws Exception { // 循环直到获取资源 while (true) { // 获取锁 lock.lock(); if (getting.containsKey(key)) { // 如果其他线程正在获取这个资源，那么当前线程将等待一毫秒然后继续循环 lock.unlock(); try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); continue; } continue; } if (cache.containsKey(key)) { // 如果资源已经在缓存中，直接返回资源，并增加引用计数 T obj = cache.get(key); references.put(key, references.get(key) + 1); lock.unlock(); return obj; } // 如果资源不在缓存中，尝试获取资源。如果缓存已满，抛出异常 if (maxResource > 0 && count == maxResource) { lock.unlock(); throw Error.CacheFullException; } count++; getting.put(key, true); lock.unlock(); break; } // 尝试获取资源 T obj = null; try { obj = getForCache(key); } catch (Exception e) { lock.lock(); count--; getting.remove(key); lock.unlock(); throw e; } // 将获取到的资源添加到缓存中，并设置引用计数为1 lock.lock(); getting.remove(key); cache.put(key, obj); references.put(key, 1); lock.unlock(); return obj; }\"]},\"58\":{\"h\":\"释放资源\",\"t\":[\"当上层模块不再需要某个资源时，通过 release(long key) 方法减少引用计数。如果引用计数归零，资源将从缓存中移除，并通过 releaseForCache 方法执行必要的回源处理。\",\"/** * 强行释放一个缓存 */ protected void release(long key) { lock.lock(); // 获取锁 try { int ref = references.get(key) - 1; // 获取资源的引用计数并减一 if (ref == 0) { // 如果引用计数为0 T obj = cache.get(key); // 从缓存中获取资源 releaseForCache(obj); // 处理资源的释放 references.remove(key); // 从引用计数的映射中移除资源 cache.remove(key); // 从缓存中移除资源 count--; // 将缓存中的资源计数减一 } else { // 如果引用计数不为0 references.put(key, ref); // 更新资源的引用计数 } } finally { lock.unlock(); // 释放锁 } }\"]},\"59\":{\"h\":\"关闭缓存\",\"t\":[\"在系统关闭时，close() 方法会确保缓存中的所有资源都被安全地释放，并将需要持久化的数据写回数据源，避免数据丢失。\",\"/** * 关闭缓存，写回所有资源 */ protected void close() { lock.lock(); try { //获取所有资源key Set<Long> keys = cache.keySet(); for (long key : keys) { //获取缓存 T obj = cache.get(key); //释放缓存 releaseForCache(obj); //引用计数移除缓存 references.remove(key); //实际缓存移除缓存 cache.remove(key); } } finally { //释放锁 lock.unlock(); } }\"]},\"60\":{\"h\":\"总结\",\"t\":[\"引用计数缓存框架结合了灵活的资源管理和有效的回源策略，在提高系统性能的同时，避免了 LRU 策略可能引发的问题。通过引用计数，系统能够确保资源的有效使用和及时释放，减少不必要的回源操作，提高了系统的整体效率和稳定性。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb2版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"61\":{\"c\":[\"DM\"]},\"62\":{\"c\":[\"引用计数缓存框架\"]},\"63\":{\"h\":\"DM 的实现\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/dm/dataItem/； com/dyx/simpledb/backend/dm/；\"]},\"64\":{\"h\":\"DataItem 的实现\",\"t\":[\"DataItem 是数据库系统中的数据抽象层，负责存储和管理具体的数据内容，并为上层模块提供访问接口。它主要提供以下功能：\",\"数据存储和访问：DataItem 存储了数据的具体内容，以及相关的元数据信息如数据大小和有效标志等。上层模块可以通过 DataItem 对象读取或修改数据内容。\",\"数据修改与事务管理：DataItem 支持数据的修改操作，并在修改操作前后执行保存原始数据、记录日志等流程，以确保数据修改的原子性和一致性。\",\"数据共享与内存管理：DataItem 的数据内容通过 SubArray 对象返回给上层模块，避免数据拷贝，提高了数据访问效率，并减少了内存开销。\",\"缓存管理：DataItem 对象由底层 DataManager 缓存管理，使用 release() 方法可以释放缓存中的 DataItem 对象，以便回收内存资源。\"]},\"65\":{\"h\":\"DataItem 的数据结构\",\"t\":[\"DataItem 中保存的数据结构如下：\",\"[ValidFlag] [DataSize] [Data]\",\"ValidFlag：1 字节，表示该 DataItem 是否有效。删除 DataItem 只需将其有效位设置为 0。\",\"DataSize：2 字节，表示 Data 部分的长度。\",\"public class DataItemImpl implements DataItem { private SubArray raw; // 原始数据 private byte[] oldRaw; // 旧的原始数据 private DataManagerImpl dm; // 数据管理器 private long uid; // 唯一标识符 private Page pg; // 页面对象 }\"]},\"66\":{\"h\":\"DataItem 的关键方法\",\"t\":[\"数据访问：data()\",\"返回 DataItem 中的数据部分，不进行数据拷贝，直接返回原始数据的引用。\",\"@Override public SubArray data() { return new SubArray(raw.raw, raw.start + OF_DATA, raw.end); }\",\"数据修改前准备：before()\",\"在修改数据项之前调用，锁定数据项并保存原始数据，以支持事务回滚。\",\"@Override public void before() { wLock.lock(); pg.setDirty(true); System.arraycopy(raw.raw, raw.start, oldRaw, 0, oldRaw.length); }\",\"回滚修改：unBefore()\",\"在需要撤销修改时调用，恢复原始数据并解锁数据项。\",\"@Override public void unBefore() { System.arraycopy(oldRaw, 0, raw.raw, raw.start, oldRaw.length); wLock.unlock(); }\",\"完成修改：after()\",\"修改完成后调用，记录日志并解锁数据项。\",\"@Override public void after(long xid) { dm.logDataItem(xid, this); wLock.unlock(); }\",\"释放缓存：release()\",\"使用完 DataItem 后，调用 release() 方法释放缓存。\",\"@Override public void release() { dm.releaseDataItem(this); }\"]},\"67\":{\"h\":\"DataManager 的实现\",\"t\":[\"DataManager 是数据库系统中的核心组件，负责管理底层数据的访问、修改和事务处理。它是 DM 层直接对外提供方法的类，同时也实现了对 DataItem 对象的缓存管理。DataItem 存储的 key 是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。\"]},\"68\":{\"h\":\"DataManager 的核心功能\",\"t\":[\"数据缓存与管理：DataManager 通过缓存 DataItem 对象，提供高效的数据访问。DataItem 的 key 是一个 8 字节无符号整数，其中页号和页内偏移各占 4 字节。这种设计允许快速定位和访问数据，减少了对底层存储的频繁访问。\",\"数据访问与操作：DataManager 提供了读取、插入和修改等数据操作方法。通过这些方法，数据库的上层模块可以方便地对数据进行操作。\",\"事务管理：DataManager 支持事务管理，确保数据操作的原子性。事务管理能够保证在事务提交或回滚时，数据的一致性和完整性。\",\"日志记录与恢复：DataManager 在数据修改操作前后执行日志记录，以确保数据的安全性和可靠性，并支持系统崩溃后的数据恢复。\",\"页面索引管理：DataManager 还实现了页面索引管理功能，通过页面索引，可以快速定位到合适的空闲空间，提高数据插入的效率和性能。\",\"文件初始化与校验：DataManager 在创建和打开数据库文件时，进行文件的初始化和校验，确保文件的正确性和完整性。\"]},\"69\":{\"h\":\"DataManager 的 Uid 的生成与解析\",\"t\":[\"DataItem 在 DataManager 中的存储和管理是通过一个唯一标识符 Uid 来实现的。这个 Uid 是由页面编号 (pgno) 和页面内偏移量 (offset) 组成的一个 8 字节无符号整数，其中页号和偏移量各占 4 字节。这里以pgno = 2 和 offset = 0来演示生成和解析 Uid 的详细过程。\",\"生成 Uid 通过将页面编号 (pgno) 和偏移量 (offset) 组合成一个 8 字节无符号整数来生成 Uid。这里使用了位移和按位或运算。\",\"public class Types { public static long addressToUid(int pgno, short offset) { long u0 = (long) pgno; long u1 = (long) offset; return u0 << 32 | u1; // 左移32位表示页号，按位或运算将页号和偏移量合并成一个Uid } }\",\"从 Uid 中提取偏移量 (**offset**) 为了从 Uid 中提取出偏移量，需要对 Uid 进行按位与运算。偏移量是 Uid 的低 16 位，通过与 16 位全1（0xFFFF）进行按位与操作可以提取出偏移量。\",\"// 提取偏移量，偏移量占 Uid 的低16位 short offset = (short) (uid & ((1L << 16) - 1)); // 按位与操作提取出低16位的偏移量\",\"从 Uid 中提取页面编号 (**pgno**) 提取页面编号则需要将 Uid 右移 32 位，以便将高 32 位对齐到低位，然后通过按位与操作提取出页面编号。\",\"// 右移32位，将高32位对齐到低位 uid >>>= 32; // 提取页面编号，页面编号占 Uid 的高32位 int pgno = (int) (uid & ((1L << 32) - 1)); // 按位与操作提取出页面编号\"]},\"70\":{\"h\":\"\",\"t\":[\"也是继承自AbstractCache，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可\",\"@Override protected DataItem getForCache(long uid) throws Exception { // 从 uid 中提取出偏移量（offset），这是通过位操作实现的，偏移量是 uid 的低16位 short offset = (short) (uid & ((1L << 16) - 1)); // 将 uid 右移32位，以便接下来提取出页面编号（pgno） uid >>>= 32; // 从 uid 中提取出页面编号（pgno），页面编号是 uid 的高32位 int pgno = (int) (uid & ((1L << 32) - 1)); // 使用页面缓存（pc）的 getPage(int pgno) 方法根据页面编号获取一个 Page 对象 Page pg = pc.getPage(pgno); // 使用 DataItem 接口的静态方法 parseDataItem(Page pg, short offset, DataManagerImpl dm) // 根据获取到的 Page 对象、偏移量和当前的 DataManagerImpl 对象（this）解析出一个 DataItem 对象，并返回这个对象 return DataItem.parseDataItem(pg, offset, this); }\"]},\"71\":{\"h\":\"\",\"t\":[\"DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可：\",\"@Override protected void releaseForCache(DataItem di) { di.page().release(); }\"]},\"72\":{\"h\":\"DataManager 的核心方法\",\"t\":[\"读取数据：read()\",\"根据 Uid 从缓存中获取 DataItem，并校验其有效性。DataItem 的 Uid 是由页号和页内偏移组成的一个 8 字节无符号整数。\",\"@Override public DataItem read(long uid) throws Exception { //从缓存页面中读取到DataItemImpl DataItemImpl di = (DataItemImpl) super.get(uid); // 若缓存中不存在则调用 getForCache() 方法 //校验di是否有效 if (!di.isValid()) { // 无效释放缓存 di.release(); return null; } return di; }\",\"插入数据：insert()\",\"在 PageIndex 中选择一个合适的页面进行插入操作，记录插入日志，并返回插入位置的偏移。插入的位置和页面信息都是通过页号和偏移量进行管理的。\",\"@Override public long insert(long xid, byte[] data) throws Exception { // 将输入的数据包装成DataItem的原始格式 byte[] raw = DataItem.wrapDataItemRaw(data); // 如果数据项的大小超过了页面的最大空闲空间，抛出异常 if (raw.length > PageX.MAX_FREE_SPACE) { throw Error.DataTooLargeException; } // 初始化一个页面信息对象 PageInfo pi = null; // 尝试5次找到一个可以容纳新数据项的页面 for (int i = 0; i < 5; i++) { // 从页面索引中选择一个可以容纳新数据项的页面 pi = pIndex.select(raw.length); // 如果找到了合适的页面，跳出循环 if (pi != null) { break; } else { // 如果没有找到合适的页面，创建一个新的页面，并将其添加到页面索引中 int newPgno = pc.newPage(PageX.initRaw()); pIndex.add(newPgno, PageX.MAX_FREE_SPACE); } } // 如果还是没有找到合适的页面，抛出异常 if (pi == null) { throw Error.DatabaseBusyException; } // 初始化一个页面对象 Page pg = null; // 初始化空闲空间大小为0 int freeSpace = 0; try { // 获取页面信息对象中的页面 pg = pc.getPage(pi.pgno); // 生成插入日志 byte[] log = Recover.insertLog(xid, pg, raw); // 将日志写入日志文件 logger.log(log); // 在页面中插入新的数据项，并获取其在页面中的偏移量 short offset = PageX.insert(pg, raw); // 释放页面 pg.release(); // 返回新插入的数据项的唯一标识符 return Types.addressToUid(pi.pgno, offset); } finally { // 将页面重新添加到页面索引中 if (pg != null) { pIndex.add(pi.pgno, PageX.getFreeSpace(pg)); } else { pIndex.add(pi.pgno, freeSpace); } } } /** * 返回一个完整的 DataItem 结构数据 * dataItem 结构如下： * [ValidFlag] [DataSize] [Data] * ValidFlag 1字节，0为合法，1为非法 * DataSize 2字节，标识Data的长度 * @param raw * @return */ public static byte[] wrapDataItemRaw(byte[] raw) { byte[] valid = new byte[1]; //证明此时为非法数据 byte[] size = Parser.short2Byte((short)raw.length); //计算数据字节大小 return Bytes.concat(valid, size, raw); //拼接DataItem 结构数据 } /** * 根据给定的空间大小选择一个 PageInfo 对象。 * * @param spaceSize 需要的空间大小 * @return 一个 PageInfo 对象，其空闲空间大于或等于给定的空间大小。如果没有找到合适的 PageInfo，返回 null。 */ public PageInfo select(int spaceSize) { lock.lock(); // 获取锁，确保线程安全 try { int number = spaceSize / THRESHOLD; // 计算需要的空间大小对应的区间编号 // 此处+1主要为了向上取整 /* 1、假需要存储的字节大小为5168，此时计算出来的区间号是25，但是25*204=5100显然是不满足条件的 2、此时向上取整找到 26，而26*204=5304，是满足插入条件的 */ if (number < INTERVALS_NO) number++; // 如果计算出的区间编号小于总的区间数，编号加一 while (number <= INTERVALS_NO) { // 从计算出的区间编号开始，向上寻找合适的 PageInfo if (lists[number].size() == 0) { // 如果当前区间没有 PageInfo，继续查找下一个区间 number++; continue; } return lists[number].remove(0); // 如果当前区间有 PageInfo，返回第一个 PageInfo，并从列表中移除 } return null; // 如果没有找到合适的 PageInfo，返回 null } finally { lock.unlock(); // 释放锁 } } // 定义一个静态方法，用于创建插入日志 public static byte[] insertLog(long xid, Page pg, byte[] raw) { // 创建一个表示日志类型的字节数组，并设置其值为LOG_TYPE_INSERT byte[] logTypeRaw = {LOG_TYPE_INSERT}; // 将事务ID转换为字节数组 byte[] xidRaw = Parser.long2Byte(xid); // 将页面编号转换为字节数组 byte[] pgnoRaw = Parser.int2Byte(pg.getPageNumber()); // 获取页面的第一个空闲空间的偏移量，并将其转换为字节数组 byte[] offsetRaw = Parser.short2Byte(PageX.getFSO(pg)); // 将所有字节数组连接在一起，形成一个完整的插入日志，并返回这个日志 return Bytes.concat(logTypeRaw, xidRaw, pgnoRaw, offsetRaw, raw); } // 将raw插入pg中，返回插入位置 public static short insert(Page pg, byte[] raw) { pg.setDirty(true); // 将pg的dirty标志设置为true，表示pg的数据已经被修改 short offset = getFSO(pg.getData()); // 获取pg的空闲空间偏移量 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将raw的数据复制到pg的数据中的offset位置 setFSO(pg.getData(), (short) (offset + raw.length)); // 更新pg的空闲空间偏移量 return offset; // 返回插入位置 }\",\"关闭 DataManager：close()\",\"正常关闭时，执行缓存和日志的关闭流程，并设置第一页的字节校验。\",\"@Override public void close() { super.close(); logger.close(); PageOne.setVcClose(pageOne); pageOne.release(); pc.close(); }\"]},\"73\":{\"h\":\"DataManager 的初始化\",\"t\":[\"从空文件创建：create()\",\"初始化 PageCache 和 Logger，并初始化第一页。\",\"public static DataManager create(String path, long mem, TransactionManager tm) { PageCache pc = PageCache.create(path, mem); Logger lg = Logger.create(path); DataManagerImpl dm = new DataManagerImpl(pc, lg, tm); dm.initPageOne(); return dm; }\",\"从已有文件打开：open()\",\"加载并检查第一页，必要时执行恢复操作，并填充 PageIndex。\",\"public static DataManager open(String path, long mem, TransactionManager tm) { PageCache pc = PageCache.open(path, mem); Logger lg = Logger.open(path); DataManagerImpl dm = new DataManagerImpl(pc, lg, tm); if (!dm.loadCheckPageOne()) { Recover.recover(tm, lg, pc); } dm.fillPageIndex(); PageOne.setVcOpen(dm.pageOne); dm.pc.flushPage(dm.pageOne); return dm; }\"]},\"74\":{\"h\":\"总结\",\"t\":[\"DataItem 和 DataManager 是数据库系统中数据管理的关键组件。DataItem 提供了数据的存储和访问接口，支持数据修改和事务管理。而 DataManager 负责管理底层数据的访问、缓存、事务处理和日志记录，通过这些功能的实现，为上层模块提供了安全、高效的数据操作接口。两者的协作使得数据库系统能够以高效、可靠的方式管理和操作底层数据，确保数据的安全性和一致性。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb5版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"75\":{\"c\":[\"DM\"]},\"76\":{\"c\":[\"DM\"]},\"77\":{\"h\":\"日志管理\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/dm/logger；com/dyx/simpledb/backend/dm/Recover.java\"]},\"78\":{\"h\":\"EasyDB 崩溃恢复功能概述\",\"t\":[\"EasyDB 提供了崩溃后的数据恢复功能。为了保证数据的一致性，每当 DM 层对底层数据进行操作时，都会将一条日志记录到磁盘上。在数据库崩溃后，再次启动时，系统可以根据这些日志内容恢复数据文件，从而确保数据的一致性和完整性。\"]},\"79\":{\"h\":\"日志格式与结构\",\"t\":[\"日志以二进制文件的形式存储，格式如下：\",\"[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]\",\"XChecksum：四字节的整数，是对后续所有日志计算的校验和。\",\"Log1 ~ LogN：常规的日志数据。\",\"BadTail：数据库崩溃时尚未写完的日志数据（可能不存在）。\",\"每条日志的结构如下：\",\"[Size][Checksum][Data]\",\"Size：四字节整数，表示 Data 段的字节数。\",\"Checksum：四字节整数，记录该条日志的校验和。\"]},\"80\":{\"h\":\"日志文件的校验和\",\"t\":[\"EasyDB 通过计算日志文件的校验和来确保日志数据的完整性，就是通过一个指定的种子实现的。以下是计算校验和的核心逻辑：\",\"private int calChecksum(int xCheck, byte[] log) { for (byte b : log) { xCheck = xCheck * SEED + b; // SEED = 13331 } return xCheck; }\"]},\"81\":{\"h\":\"日志文件的创建与初始化\",\"t\":[\"在创建日志文件时，系统会初始化 XChecksum 为 0，并写入文件。打开文件时，系统将读取 XChecksum 并检查 BadTail 的存在性。\",\"// 日志文件创建时 ByteBuffer buf = ByteBuffer.wrap(Parser.int2Byte(0)); // 初始化 XChecksum 为 0并转换成四字节的数字 try { fc.position(0); fc.write(buf); //将其写入到文件 fc.force(false); } catch (IOException e) { Panic.panic(e); } // 日志文件打开时 void init() { // 读取文件大小和 XChecksum size = file.length(); ByteBuffer raw = ByteBuffer.allocate(4); fc.position(0); fc.read(raw); xChecksum = Parser.parseInt(raw.array()); checkAndRemoveTail(); }\"]},\"82\":{\"h\":\"\",\"t\":[\"当打开一个日志文件时，系统首先校验 XChecksum，并移除可能存在的 BadTail。BadTail 是因崩溃而未能完整写入的日志数据，它不会包含在日志文件的校验和中，因此需要移除以确保文件一致性。\",\"// 检查并移除bad tail private void checkAndRemoveTail() { // 将当前位置重置为文件的开始位置 // [XChecksum][Log1][Log2]...[LogN][BadTail] --> [Log1][Log2]...[LogN][BadTail] rewind(); // 初始化校验和为 0 int xCheck = 0; // 循环读取日志，直到没有更多的日志可以读取 while (true) { // 读取下一条日志 byte[] log = internNext(); // 如果读取到的日志为 null，说明没有更多的日志可以读取，跳出循环 if (log == null) break; // 计算校验和 xCheck = calChecksum(xCheck, log); } // 比较计算得到的校验和和文件中的校验和，如果不相等，说明日志已经被破坏，抛出异常 if (xCheck != xChecksum) { Panic.panic(Error.BadLogFileException); } // 尝试将文件截断到当前位置，移除 \\\"bad tail\\\" try { truncate(position); } catch (Exception e) { // 如果发生异常，调用 Panic.panic 方法处理异常 Panic.panic(e); } // 尝试将文件的读取位置设置为当前位置 try { file.seek(position); } catch (IOException e) { // 如果发生 IO 异常，调用 Panic.panic 方法处理异常 Panic.panic(e); } // 将当前位置重置为文件的开始位置 rewind(); }\"]},\"83\":{\"h\":\"日志迭代与写入\",\"t\":[\"EasyDB 使用迭代器模式读取日志，通过 next() 方法不断获取下一条日志，并解析其中的 Data 部分。internNext() 函数实现了日志的读取和校验逻辑。\",\"@Override public byte[] next() { lock.lock(); try { byte[] log = internNext(); if (log == null) return null; return Arrays.copyOfRange(log, OF_DATA, log.length); } finally { lock.unlock(); } }\",\"流程图看个大概意思即可：\",\"/** * 获取下一条日志 */ private byte[] internNext() { // 检查当前位置是否已经超过了文件的大小，如果超过了，说明没有更多的日志可以读取，返回 null if (position + OF_DATA >= fileSize) { return null; } // 创建一个大小为 4 的 ByteBuffer，用于读取日志的大小 ByteBuffer tmp = ByteBuffer.allocate(4); try { // 将文件通道的位置设置为当前位置 fc.position(position); // 从文件通道中读取 4 个字节的数据到 ByteBuffer 中，即Size日志文件的大小 fc.read(tmp); } catch (IOException e) { // 如果发生 IO 异常，调用 Panic.panic 方法处理异常 Panic.panic(e); } // 使用 Parser.parseInt 方法将读取到的 4 个字节的数据转换为 int 类型，得到日志的大小 int size = Parser.parseInt(tmp.array()); // 检查当前位置加上日志的大小是否超过了文件的大小，如果超过了，说明日志不完整，返回 null if (position + size + OF_DATA > fileSize) { return null; } // 创建一个大小为 OF_DATA + size 的 ByteBuffer，用于读取完整的日志 ByteBuffer buf = ByteBuffer.allocate(OF_DATA + size); try { // 将文件通道的位置设置为当前位置 fc.position(position); // 从文件通道中读取 OF_DATA + size 个字节的数据到 ByteBuffer 中 // 读取整条日志 [Size][Checksum][Data] fc.read(buf); } catch (IOException e) { // 如果发生 IO 异常，调用 Panic.panic 方法处理异常 Panic.panic(e); } // 将 ByteBuffer 中的数据转换为字节数组 byte[] log = buf.array(); // 计算日志数据的校验和 int checkSum1 = calChecksum(0, Arrays.copyOfRange(log, OF_DATA, log.length)); // 从日志中读取校验和 int checkSum2 = Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA)); // 比较计算得到的校验和和日志中的校验和，如果不相等，说明日志已经被破坏，返回 null if (checkSum1 != checkSum2) { return null; } // 更新当前位置 position += log.length; // 返回读取到的日志 return log; }\",\"日志写入时，系统首先将数据封装成日志格式，然后写入文件，并更新总校验和。\",\"@Override public void log(byte[] data) { // 解析成一条完整的log日志 byte[] log = wrapLog(data); ByteBuffer buf = ByteBuffer.wrap(log); lock.lock(); try { //写入到指定位置 fc.position(fc.size()); fc.write(buf); } catch (IOException e) { Panic.panic(e); } finally { lock.unlock(); } // 更新总校验值 updateXChecksum(log); } /** * 更新总校验值 */ private void updateXChecksum(byte[] log) { //计算总校验值 this.xChecksum = calChecksum(this.xChecksum, log); try { fc.position(0); fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum))); fc.force(false); } catch (IOException e) { Panic.panic(e); } } /** * 将数据解析成完整log */ private byte[] wrapLog(byte[] data) { // 使用 calChecksum 方法计算数据的校验和，然后将校验和转换为字节数组 byte[] checksum = Parser.int2Byte(calChecksum(0, data)); // 将数据的长度转换为字节数组 byte[] size = Parser.int2Byte(data.length); // 使用 Bytes.concat 方法将 size、checksum 和 data 连接成一个新的字节数组，然后返回这个字节数组 return Bytes.concat(size, checksum, data); }\"]},\"84\":{\"h\":\"EasyDB 恢复策略详解\",\"t\":[\"在 EasyDB 中，恢复策略是从 NYADB2 借鉴而来的，其核心是通过严格的日志管理和操作规则来确保数据库在崩溃后的数据一致性。这个策略涉及对数据库操作的日志记录，并依赖于日志的重做（redo）和撤销（undo）机制来恢复数据。\"]},\"85\":{\"h\":\"恢复策略的基本原理\",\"t\":[\"EasyDB 为上层模块（DM 层）提供了两种基本的操作：插入新数据（Insert, I）和更新现有数据（Update, U）。在进行任何数据操作之前，必须先进行对应的日志操作，确保日志已经写入磁盘后才开始实际的数据操作。这样的设计保证了即使在数据操作还未完成的情况下发生崩溃，系统仍可以通过日志恢复数据。 日志记录格式：\",\"(Ti, I, A, x)：表示事务 Ti 在位置 A 插入了数据 x。\",\"(Ti, U, A, oldx, newx)：表示事务 Ti 将位置 A 的数据从 oldx 更新为 newx。\"]},\"86\":{\"h\":\"单线程环境下的恢复\",\"t\":[\"在单线程环境中，只可能有一个事务在操作数据库。日志不会相互交错，因此恢复过程较为简单。\",\"重做（redo）： \",\"正序扫描事务 T 的所有日志。\",\"如果日志是插入操作 (Ti, I, A, x)，将 x 重新插入位置 A。\",\"如果日志是更新操作 (Ti, U, A, oldx, newx)，将位置 A 的值更新为 newx。\",\"撤销（undo）： \",\"倒序扫描事务 T 的所有日志。\",\"如果日志是插入操作 (Ti, I, A, x)，将位置 A 的数据标记为无效（逻辑删除）。\",\"如果日志是更新操作 (Ti, U, A, oldx, newx)，将位置 A 的值恢复为 oldx。\",\"案例讲解： 假设在一个单线程环境中，有如下事务操作：\",\"事务 T1 插入了数据 x 到位置 A，日志记录为 (T1, I, A, x)。\",\"事务 T1 还更新了位置 B 的数据，将其从 oldB 更新为 newB，日志记录为 (T1, U, B, oldB, newB)。\",\"在系统崩溃后，恢复过程将：\",\"正序重做 T1 的插入操作，将 x 重新插入位置 A。\",\"重做 T1 的更新操作，将位置 B 的数据更新为 newB。\",\"如果 T1 在崩溃前未完成，恢复过程将撤销这些操作，将 A 中的 x 标记为无效，并将 B 的数据恢复为 oldB。\"]},\"87\":{\"h\":\"多线程环境下的恢复\",\"t\":[\"在多线程环境中，多个事务可能并发执行，恢复过程的复杂性增加。为了确保数据的一致性，EasyDB 引入了以下两条规则：\",\"规则 1：正在进行的事务不得读取任何未提交的事务产生的数据。 \",\"该规则避免了级联回滚的问题，即一个已提交的事务读取了未提交事务的数据，而该未提交事务在崩溃后被撤销时，已提交事务的更改也必须被撤销。\",\"规则 2：正在进行的事务不得修改其他任何未提交的事务修改或产生的数据。 \",\"该规则避免了在多线程环境中多个事务相互干扰，导致数据不一致的问题。\",\"案例讲解：\",\"案例 1：避免级联回滚\",\"假设有两个并发事务 T1 和 T2：\",\"T1 读取了 T2 更新后的数据 x。\",\"T2 尚未提交，系统崩溃。\",\"在恢复过程中，T2 的操作被撤销，而由于 T1 读取了 T2 的未提交数据，T1 也需要被撤销。然而，由于 T1 已提交，撤销它会导致数据不一致。因此，通过规则 1，EasyDB 保证 T1 不会读取 T2 的未提交数据，从而避免这种问题。\",\"案例 2：避免数据不一致\",\"假设事务 T1 和 T2 并发更新同一数据 x：\",\"T1 将 x 从 0 更新为 1。\",\"T2 将 x 从 1 更新为 2，并提交。\",\"系统崩溃。\",\"在恢复过程中，如果先撤销 T1，再重做 T2，x 的最终值为 2。但如果顺序相反，x 的最终值可能为 0。通过规则 2，EasyDB 保证 T2 的更新不会基于 T1 的未提交数据，从而避免数据不一致的问题。\"]},\"88\":{\"h\":\"恢复策略的具体实现代码\"},\"89\":{\"h\":\"日志格式\",\"t\":[\"EasyDB 中的日志分为两种类型，分别对应插入操作和更新操作：\",\"public class Recover { private static final byte LOG_TYPE_INSERT = 0; private static final byte LOG_TYPE_UPDATE = 1; // updateLog: // [LogType] [XID] [UID] [OldRaw] [NewRaw] // insertLog: // [LogType] [XID] [Pgno] [Offset] [Raw] }\"]},\"90\":{\"h\":\"重做已完成的事务\",\"t\":[\"重做操作通过扫描所有日志记录，重做所有已完成的事务操作。\",\"private static void redoTranscations(TransactionManager tm, Logger lg, PageCache pc) { // 重置日志文件的读取位置到开始 lg.rewind(); // 循环读取日志文件中的所有日志记录 while (true) { // 读取下一条日志记录 byte[] log = lg.next(); // 如果读取到的日志记录为空，表示已经读取到日志文件的末尾，跳出循环 if (log == null) break; // 判断日志记录的类型 if (isInsertLog(log)) { // 如果是插入日志，解析日志记录，获取插入日志信息 InsertLogInfo li = parseInsertLog(log); // 获取事务ID long xid = li.xid; // 如果当前事务已经提交，进行重做操作 if (!tm.isActive(xid)) { doInsertLog(pc, log, REDO); } } else { // 如果是更新日志，解析日志记录，获取更新日志信息 UpdateLogInfo xi = parseUpdateLog(log); // 获取事务ID long xid = xi.xid; // 如果当前事务已经提交，进行重做操作 if (!tm.isActive(xid)) { doUpdateLog(pc, log, REDO); } } } }\"]},\"91\":{\"h\":\"撤销未完成的事务\",\"t\":[\"撤销操作通过倒序扫描日志记录，撤销所有未完成的事务操作。\",\"private static void undoTranscations(TransactionManager tm, Logger lg, PageCache pc) { // 创建一个用于存储日志的映射，键为事务ID，值为日志列表 Map<Long, List<byte[]>> logCache = new HashMap<>(); // 将日志文件的读取位置重置到开始 lg.rewind(); // 循环读取日志文件中的所有日志记录 while (true) { // 读取下一条日志记录 byte[] log = lg.next(); // 如果读取到的日志记录为空，表示已经读取到日志文件的末尾，跳出循环 if (log == null) break; // 判断日志记录的类型 if (isInsertLog(log)) { // 如果是插入日志，解析日志记录，获取插入日志信息 InsertLogInfo li = parseInsertLog(log); // 获取事务ID long xid = li.xid; // 如果当前事务仍然活跃，将日志记录添加到对应的日志列表中 if (tm.isActive(xid)) { if (!logCache.containsKey(xid)) { logCache.put(xid, new ArrayList<>()); } logCache.get(xid).add(log); } } else { // 如果是更新日志，解析日志记录，获取更新日志信息 UpdateLogInfo xi = parseUpdateLog(log); // 获取事务ID long xid = xi.xid; // 如果当前事务仍然活跃，将日志记录添加到对应的日志列表中 if (tm.isActive(xid)) { if (!logCache.containsKey(xid)) { logCache.put(xid, new ArrayList<>()); } // 将事务id对应的log添加到集合中 logCache.get(xid).add(log); } } } // 对所有活跃的事务的日志进行倒序撤销 for (Entry<Long, List<byte[]>> entry : logCache.entrySet()) { List<byte[]> logs = entry.getValue(); for (int i = logs.size() - 1; i >= 0; i--) { byte[] log = logs.get(i); // 判断日志记录的类型 if (isInsertLog(log)) { // 如果是插入日志，进行撤销插入操作 doInsertLog(pc, log, UNDO); } else { // 如果是更新日志，进行撤销更新操作 doUpdateLog(pc, log, UNDO); } } // 中止当前事务 tm.abort(entry.getKey()); } }\"]},\"92\":{\"h\":\"插入和更新日志的操作实现\",\"t\":[\"private static void doInsertLog(PageCache pc, byte[] log, int flag) { InsertLogInfo li = parseInsertLog(log); Page pg = null; try { pg = pc.getPage(li.pgno); } catch(Exception e) { Panic.panic(e); } try { if(flag == UNDO) { DataItem.setDataItemRawInvalid(li.raw); } PageX.recoverInsert(pg, li.raw, li.offset); } finally { pg.release(); } } private static void doUpdateLog(PageCache pc, byte[] log, int flag) { int pgno; short offset; byte[] raw; if(flag == REDO) { UpdateLogInfo xi = parseUpdateLog(log); pgno = xi.pgno; offset = xi.offset; raw = xi.newRaw; } else { UpdateLogInfo xi = parseUpdateLog(log); pgno = xi.pgno; offset = xi.offset; raw = xi.oldRaw; } Page pg = null; try { pg = pc.getPage(pgno); } catch (Exception e) { Panic.panic(e); } try { PageX.recoverUpdate(pg, raw, offset); } finally { pg.release(); } }\",\"以上的代码实现了 EasyDB 中的恢复策略，通过对日志的管理和恢复规则的严格遵守，确保数据库在单线程和多线程环境下的可靠性和一致性。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb4版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"93\":{\"c\":[\"DM\"]},\"94\":{\"c\":[\"日志\"]},\"95\":{\"h\":\"数据页缓存\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/dm/pageCache/*\"]},\"96\":{\"h\":\"页面缓存设计与实现\",\"t\":[\"在数据库系统中，页面缓存是为了提升读写效率而设计的一种缓存机制。通过将页面数据保存在内存中，可以减少频繁的磁盘 I/O 操作，从而提高系统的整体性能。这里参考大部分数据库的设计，将默认数据页大小定为 8K。如果想要提升向数据库写入大量数据情况下的性能，也可以适当增大这个值。 通过前面的内容我们已经实现了一个通用的缓存框架，而在本节中，我们将借助这个缓存框架来实现页面缓存。不过首先，需要定义出页面的结构。需要注意的是，页面结构是存储在内存中的，与已经持久化到磁盘的抽象页面有一定的区别。\"]},\"97\":{\"h\":\"页面结构定义\",\"t\":[\"页面（Page）是数据库中存储数据的基本单元，其结构如下：\",\"pageNumber：页面的页号，从1开始计数。\",\"data：页面实际包含的字节数据。\",\"dirty：标志页面是否是脏页面。脏页面在缓存驱逐时需要被写回到磁盘。\",\"lock：用于保证页面操作的线程安全。\",\"PageCache：引用页面缓存，便于在获取页面时快速释放页面的缓存操作。\",\"public class PageImpl implements Page { private int pageNumber; private byte[] data; private boolean dirty; private Lock lock; private PageCache pc; }\"]},\"98\":{\"h\":\"页面缓存接口定义\",\"t\":[\"定义了页面缓存的接口，包括新建页面、获取页面、释放页面、关闭缓存、根据最大页号截断缓存、获取当前页面数量以及刷新页面等方法。\",\"public interface PageCache { int newPage(byte[] initData); Page getPage(int pgno) throws Exception; void close(); void release(Page page); void truncateByBgno(int maxPgno); int getPageNumber(); void flushPage(Page pg); }\"]},\"99\":{\"h\":\"页面缓存的实现\",\"t\":[\"页面缓存的具体实现类继承了抽象缓存框架，并实现了 getForCache() 和 releaseForCache() 两个方法：\",\"getForCache()：用于从文件中读取页面数据，并将其包装成 Page 对象。\",\"releaseForCache()：用于在驱逐页面时根据页面是否为脏页面，决定是否将其写回文件系统。\"]},\"100\":{\"h\":\"页面写回文件系统\",\"t\":[\"当页面缓存决定驱逐某个页面时，如果该页面是脏页面，则需要将其数据写回到磁盘。这个操作通过 flush() 方法实现，确保数据的原子性和线程安全性。\",\"@Override protected void releaseForCache(Page pg) { if (pg.isDirty()) { flush(pg); pg.setDirty(false); } } private void flush(Page pg) { int pgno = pg.getPageNumber(); // 获取Page的页码 long offset = pageOffset(pgno); // 计算Page在文件中的偏移量 fileLock.lock(); // 加锁，确保线程安全 try { ByteBuffer buf = ByteBuffer.wrap(pg.getData()); // 将Page的数据包装成ByteBuffer fc.position(offset); // 设置文件通道的位置 fc.write(buf); // 将数据写入到文件中 fc.force(false); // 强制将数据从操作系统的缓存刷新到磁盘 } catch (IOException e) { Panic.panic(e); // 如果发生异常，调用Panic.panic方法处理 } finally { fileLock.unlock(); // 最后，无论是否发生异常，都要解锁 } }\"]},\"101\":{\"h\":\"新建页面\",\"t\":[\"新建页面时，页面缓存会自增页面数量，并在写入文件系统后返回新建页面的页号。页面数据一旦创建就会立刻写入磁盘，以确保数据的持久性。\",\"public int newPage(byte[] initData) { int pgno = pageNumbers.incrementAndGet(); Page pg = new PageImpl(pgno, initData, null); flush(pg); // 新建的页面需要立刻写回 return pgno; }\"]},\"102\":{\"h\":\"限制条件\",\"t\":[\"数据库系统中，不允许单条数据跨页存储，即每条数据的大小不能超过单个页面的大小。\"]},\"103\":{\"h\":\"页面缓存的操作方法\"},\"104\":{\"h\":\"\",\"t\":[\"getForCache() 方法通过读取数据库文件中的页面数据，并将其包装成 Page 对象返回。这一过程确保了从磁盘读取数据的正确性和线程安全性。\",\"/** * 根据pageNumber从数据库文件中读取页数据，并包裹成Page */ @Override protected Page getForCache(long key) throws Exception { // 将key转换为页码 int pgno = (int) key; // 计算页码对应的偏移量 long offset = PageCacheImpl.pageOffset(pgno); // 分配一个大小为PAGE_SIZE的ByteBuffer ByteBuffer buf = ByteBuffer.allocate(PAGE_SIZE); // 锁定文件，确保线程安全 fileLock.lock(); try { // 设置文件通道的位置为计算出的偏移量 fc.position(offset); // 从文件通道读取数据到ByteBuffer fc.read(buf); } catch (IOException e) { // 如果发生异常，调用Panic.panic方法处理 Panic.panic(e); } // 无论是否发生异常，都要解锁 fileLock.unlock(); // 使用读取到的数据、页码和当前对象创建一个新的PageImpl对象并返回 return new PageImpl(pgno, buf.array(), this); } public PageImpl(int pageNumber, byte[] data, PageCache pc) { this.pageNumber = pageNumber; // 设置页面的页号 this.data = data; // 设置页面实际包含的字节数据 this.pc = pc; // 设置页面缓存 lock = new ReentrantLock(); // 初始化一个新的可重入锁 }\"]},\"105\":{\"h\":\"\",\"t\":[\"当页面不再需要时，releaseForCache() 方法会检查页面是否是脏页面，并根据需要将页面的数据写回到磁盘。如果页面被标记为脏页面（即其数据已被修改但尚未写回磁盘），则需要通过 flush() 方法将其内容写入磁盘。\",\"@Override protected void releaseForCache(Page pg) { if (pg.isDirty()) { flush(pg); pg.setDirty(false); } }\"]},\"106\":{\"h\":\"数据恢复操作\",\"t\":[\"在数据库系统中，数据恢复操作是为了确保在系统崩溃后，能够从日志或其他持久化存储中恢复数据。recoverInsert() 和 recoverUpdate() 方法用于在数据库崩溃后重新插入数据和恢复修改。\",\"recoverInsert()：将数据插入到指定的偏移位置，并更新空闲空间的偏移量。\",\"recoverUpdate()：在指定的偏移位置直接更新数据，而不更新空闲空间的偏移量。\",\"// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset public static void recoverInsert(Page pg, byte[] raw, short offset) { pg.setDirty(true); // 将pg的dirty标志设置为true，表示pg的数据已经被修改 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将raw的数据复制到pg的数据中的offset位置 short rawFSO = getFSO(pg.getData()); // 获取pg的当前空闲空间偏移量 if (rawFSO < offset + raw.length) { // 如果当前的空闲空间偏移量小于offset + raw.length setFSO(pg.getData(), (short) (offset + raw.length)); // 将pg的空闲空间偏移量设置为offset + raw.length } } // 将raw插入pg中的offset位置，不更新update public static void recoverUpdate(Page pg, byte[] raw, short offset) { pg.setDirty(true); // 将pg的dirty标志设置为true，表示pg的数据已经被修改 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将raw的数据复制到pg的数据中的offset位置 }\"]},\"107\":{\"h\":\"总结\",\"t\":[\"页面缓存的设计和实现对于提升数据库系统的读写性能至关重要。通过页面缓存机制，系统可以减少不必要的磁盘 I/O 操作，同时保证数据的一致性和可靠性。在数据恢复方面，通过 recoverInsert() 和 recoverUpdate() 方法，系统可以在发生崩溃后有效地恢复数据，确保数据的完整性。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb3版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"108\":{\"c\":[\"DM\"]},\"109\":{\"c\":[\"页面缓存\"]},\"110\":{\"h\":\"页面索引\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/dm/pageIndex/*\"]},\"111\":{\"h\":\"页面索引设计与实现\",\"t\":[\"在数据库系统中，为了提高插入操作的效率，页面索引的设计应运而生。它的主要作用是缓存每个页面的空闲空间信息，从而在插入数据时，能够快速找到一个合适的页面，而无需遍历所有的页面。\"]},\"112\":{\"h\":\"页面索引的基本介绍\",\"t\":[\"页面索引通过将每个页面划分为一定数量的区间（在这个设计中，划分为40个区间），并在数据库启动时遍历所有页面，将每个页面的空闲空间信息分配到相应的区间中。 当进行插入操作时，首先根据所需的空间大小向上取整，映射到某一个区间，然后直接从该区间中选择一个页面，以满足插入需求。页面索引的实现通过一个数组来存储这些信息，数组中的每个元素都是一个列表，包含具有相同空闲空间大小的页面信息。 被选择的页面从页面索引中移除，这样可以避免同一个页面的并发写入。在上层模块使用完页面后，必须将其重新插入页面索引，以便其他插入操作可以继续使用。 总的来说，页面索引通过缓存页面的空闲空间信息，有效避免了频繁的磁盘访问，从而加速了插入操作的执行。\"]},\"113\":{\"h\":\"类的实现\",\"t\":[\"public class PageIndex { // 将每一页划分为40个区间 private static final int INTERVALS_NO = 40; private static final int THRESHOLD = PageCache.PAGE_SIZE / INTERVALS_NO; // 每个区间大小为204字节 private Lock lock; // 每个区间存储的页面信息 private List<PageInfo>[] lists = new List[INTERVALS_NO + 1]; }\"]},\"114\":{\"h\":\"根据空间大小选择页面：\",\"t\":[\"select() 方法根据需要的空间大小，计算对应的区间编号，并从 PageIndex 中获取一个合适的页面。\",\"public PageInfo select(int spaceSize) { lock.lock(); // 获取锁，确保线程安全 try { int number = spaceSize / THRESHOLD; // 计算对应的区间编号 if (number < INTERVALS_NO) number++; // 向上取整，以确保找到足够大的空间 while (number <= INTERVALS_NO) { // 从当前区间向上查找 if (lists[number].size() == 0) { // 当前区间没有可用页面，继续查找下一个区间 number++; continue; } return lists[number].remove(0); // 返回并移除找到的页面信息 } return null; // 没有找到合适的页面，返回 null } finally { lock.unlock(); // 释放锁 } }\"]},\"115\":{\"h\":\"添加页面信息：\",\"t\":[\"add() 方法用于在上层模块使用完页面后，将页面重新插入 PageIndex，以便后续插入操作可以继续使用该页面。\",\"public void add(int pgno, int freeSpace) { lock.lock(); // 获取锁，确保线程安全 try { int number = freeSpace / THRESHOLD; // 计算空闲空间对应的区间编号 lists[number].add(new PageInfo(pgno, freeSpace)); // 将页面信息添加到对应的区间列表中 } finally { lock.unlock(); // 释放锁 } }\"]},\"116\":{\"h\":\"填充页面索引：\",\"t\":[\"fillPageIndex() 方法在 DataManager 被创建时调用，它遍历所有页面，从第二页开始，将每个页面的空闲空间信息填充到 PageIndex 中。\",\"void fillPageIndex() { int pageNumber = pc.getPageNumber(); // 获取当前页面数量 for (int i = 2; i <= pageNumber; i++) { // 从第二页开始处理每个页面 Page pg = null; try { pg = pc.getPage(i); // 获取页面 } catch (Exception e) { Panic.panic(e); // 处理异常 } pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg)); // 将页面编号和空闲空间大小添加到 PageIndex pg.release(); // 释放页面 } }\"]},\"117\":{\"h\":\"总结\",\"t\":[\"页面索引通过缓存页面的空闲空间信息，显著提高了数据库插入操作的效率。在进行插入操作时，可以快速找到一个合适的页面，而无需遍历磁盘或缓存中的所有页面。通过实现 PageIndex 类以及相关方法，数据库系统在处理大量插入操作时表现得更加高效，减少了磁盘访问次数，优化了系统性能。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb5版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"118\":{\"c\":[\"DM\"]},\"119\":{\"c\":[\"pageIndex\"]},\"120\":{\"h\":\"数据页管理\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/dm/page/*\"]},\"121\":{\"h\":\"数据库页面管理\",\"t\":[\"在数据库系统中，页面（Page）是数据存储和管理的基本单位。在EasyDB中，页面管理的设计目标之一是确保系统在启动时能够正确恢复，并且在运行过程中有效管理页面的空闲空间。本文将深入探讨EasyDB中页面管理的具体实现，包括第一页的特殊用途和普通页的空闲空间管理。\"]},\"122\":{\"h\":\"第一页的特殊用途\",\"t\":[\"数据库文件的第一页通常被用于存储元数据和执行启动检查。在EasyDB中，第一页的作用非常简单，但至关重要，它仅用于执行启动检查，以确保数据库在上次关闭时是正常的。\"]},\"123\":{\"h\":\"页面数据校验机制\",\"t\":[\"每次数据库启动时，系统会生成一串随机字节并存储在第一页的 100~107 字节。正常关闭时，这串字节会被复制到第一页的 108~115 字节。每次数据库启动时，系统会比较这两处的字节，如果相同，则表明上次关闭是正常的；如果不同，则意味着需要执行数据恢复流程。 以下是实现代码：\",\"// 设置启动时的校验字节 public static void setVcOpen(Page pg) { pg.setDirty(true); setVcOpen(pg.getData()); } private static void setVcOpen(byte[] raw) { // 生成并设置随机校验字节 System.arraycopy(RandomUtil.randomBytes(LEN_VC), 0, raw, OF_VC, LEN_VC); } // 设置关闭时的校验字节 public static void setVcClose(Page pg) { pg.setDirty(true); setVcClose(pg.getData()); } private static void setVcClose(byte[] raw) { // 将启动时的校验字节复制到关闭时的存储位置 System.arraycopy(raw, OF_VC, raw, OF_VC + LEN_VC, LEN_VC); } // 校验字节是否一致 public static boolean checkVc(Page pg) { return checkVc(pg.getData()); } private static boolean checkVc(byte[] raw) { // 比较启动和关闭时的校验字节 return Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC + LEN_VC), Arrays.copyOfRange(raw, OF_VC + LEN_VC, OF_VC + 2 * LEN_VC)); }\"]},\"124\":{\"h\":\"普通页的管理\",\"t\":[\"普通页面（普通页）是用于实际存储数据的页面。在EasyDB中，每个普通页以一个2字节的无符号数开头，表示该页的空闲位置的偏移量。由于页面的最大容量为8K，因此2字节的偏移量足以表达这一页的所有可能偏移。\"]},\"125\":{\"h\":\"空闲空间偏移量（FSO）的管理\",\"t\":[\"普通页的管理核心在于管理空闲空间偏移量（FSO）。FSO指示了页面中第一个可用的空闲字节的位置。每次插入数据时，FSO会更新为新插入数据的末尾位置，以便后续插入操作可以准确地找到空闲位置。 以下是FSO管理的代码示例：\",\"// 设置空闲空间偏移量 private static void setFSO(byte[] raw, short ofData) { System.arraycopy(Parser.short2Byte(ofData), 0, raw, OF_FREE, OF_DATA); } // 获取页面的空闲空间偏移量 public static short getFSO(Page pg) { return getFSO(pg.getData()); } private static short getFSO(byte[] raw) { return Parser.parseShort(Arrays.copyOfRange(raw, 0, 2)); } // 获取页面的空闲空间大小 public static int getFreeSpace(Page pg) { return PageCache.PAGE_SIZE - (int) getFSO(pg.getData()); }\"]},\"126\":{\"h\":\"数据插入\",\"t\":[\"在普通页中插入数据时，系统首先根据当前的FSO确定插入位置，然后将数据写入该位置，最后更新FSO。插入完成后，页面被标记为脏页面，以便在需要时将其写回磁盘。 以下是插入操作的代码示例：\",\"// 将数据插入页面，返回插入位置 public static short insert(Page pg, byte[] raw) { pg.setDirty(true); // 标记页面为脏页面 short offset = getFSO(pg.getData()); // 获取当前空闲空间偏移量 System.arraycopy(raw, 0, pg.getData(), offset, raw.length); // 将数据写入页面 setFSO(pg.getData(), (short) (offset + raw.length)); // 更新空闲空间偏移量 return offset; // 返回数据插入位置 }\",\"通过以上机制，EasyDB能够有效地管理页面的空闲空间，并确保数据的一致性与完整性。第一页的校验机制确保了数据库在启动时能够检测并处理未正常关闭的情况，而普通页的FSO管理则确保了数据插入和存储的高效与准确。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb3版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"127\":{\"c\":[\"DM\"]},\"128\":{\"c\":[\"页面管理\"]},\"129\":{\"h\":\"数据管理\",\"t\":[\"在本节中，我们将深入探讨 EasyDB 中的 Data Manager (DM) 模块，这是数据库系统的核心组件之一，负责管理数据库的 DB 文件和日志文件。DM 模块的设计不仅确保了数据库的高效运行，还提供了强大的数据恢复功能。以下是 DM 模块的几个关键功能：\",\"分页管理和缓存：DM 通过分页管理来有效组织和访问数据库文件，每次对文件系统的读写操作都以页面为单位进行。同时，DM 模块提供了缓存机制，确保了数据操作的高效性。这一设计大大提升了系统在处理大量数据时的性能。\",\"引用计数缓存框架：在 DM 模块中，缓存设计采用了引用计数策略，而不是常见的 LRU 策略。这一选择是因为引用计数策略能够更好地控制资源的释放，避免上层模块无法感知资源被驱逐的尴尬情况。这种策略确保了在系统资源被频繁访问时，缓存能够稳定、可靠地工作。\",\"共享内存数组：由于 Java 对数组的处理方式与其他语言（如 C、C++、Go）不同，EasyDB 需要解决如何在内存中共享数组的问题。为此，设计了一个 SubArray 类，用来松散地规定数组的可使用范围。这一实现虽然不如指针方式灵活，但在 Java 环境下，它为我们提供了一种在内存中高效操作数组的解决方案。\",\"日志管理和数据恢复：DM 模块通过详细记录每次数据操作的日志，确保了系统在发生故障时能够根据日志进行数据恢复。日志文件按特定的格式存储，包括校验和、数据大小等信息，保证了数据的一致性。在系统恢复时，DM 模块能够有效地识别并移除未完成的日志，确保数据的完整性和可靠性。\",\"页面索引：为了在插入数据时快速找到合适的存储空间，DM 模块设计了页面索引系统。页面索引将页面划分为若干区间，帮助系统快速定位有足够空间的页面，从而提高插入操作的效率。\",\"DataItem 的抽象：DM 模块将文件系统中的数据抽象为 DataItem，供上层模块使用。DataItem 的设计确保了数据操作的原子性，并提供了日志支持，使得数据的修改能够在出现问题时被回滚。\",\"在这一节中，我们将详细介绍 DM 模块的各项功能，探讨它如何在保障数据库性能的同时，实现数据的高效管理和安全恢复。通过具体的代码示例，你将看到这些设计理念是如何在 EasyDB 中落地实施的。\"]},\"130\":{\"c\":[\"数据\"]},\"131\":{\"c\":[\"页面索引\",\"页面缓存\",\"引用计数缓存框架\",\"DataItem\",\"SubArray\"]},\"132\":{\"h\":\"共享内存数组\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/common/SubArray.java\"]},\"133\":{\"h\":\"Java 的数组存储\",\"t\":[\"在 Java 中，数组被视为对象，并且在内存中以对象的形式存储。这与 C、C++ 和 Go 语言有所不同，这些语言中的数组是通过指针实现的。在这些语言中，数组的某一部分可以直接指向原数组的内存区域，实现内存共享。例如，Go 语言中的代码：\",\"var array1 [10]int64 array2 := array1[5:]\",\"在这种情况下，array2 和 array1 的第五个元素到最后一个元素共享同一片内存，即使这两个数组的长度不同。而在 Java 中，当你执行类似的 subArray 操作时，Java 底层会进行一次数组复制，这就无法实现同一片内存的共享。 为了克服这个限制，可以通过自定义的 SubArray 类来松散地规定数组的可使用范围，从而模拟共享数组的效果。\"]},\"134\":{\"h\":\"SubArray 类的实现\",\"t\":[\"以下是 SubArray 类的简单实现：\",\"public class SubArray { public byte[] raw; public int start; public int end; public SubArray(byte[] raw, int start, int end) { this.raw = raw; this.start = start; this.end = end; } }\",\"在这个类中，raw 表示原始的字节数组，start 和 end 则规定了 SubArray 所代表的数组的有效范围。通过这个类，我们可以在不复制数组的情况下，共享同一片内存区域的不同部分。\"]},\"135\":{\"h\":\"案例演示\",\"t\":[\"为了更好地理解 SubArray 类的用途，下面我们通过一个实际的案例来展示其效果。\"]},\"136\":{\"h\":\"案例代码\",\"t\":[\"@Test public void testSubArray() { // 创建一个1到10的数组 byte[] subArray = new byte[10]; for (int i = 0; i < subArray.length; i++) { subArray[i] = (byte) (i + 1); } // 创建两个 SubArray 实例，分别引用原数组的不同部分 SubArray sub1 = new SubArray(subArray, 3, 7); SubArray sub2 = new SubArray(subArray, 6, 9); // 修改共享数组中的某个数据 sub1.raw[4] = (byte) 44; // 打印原始数组的内容 System.out.println(\\\"Original Array: \\\"); printArray(subArray); // 打印两个 SubArray 的内容 System.out.println(\\\"SubArray1: \\\"); printSubArray(sub1); System.out.println(\\\"SubArray2: \\\"); printSubArray(sub2); } private void printArray(byte[] array) { System.out.println(Arrays.toString(array)); } private void printSubArray(SubArray subArray) { for (int i = subArray.start; i <= subArray.end; i++) { System.out.print(subArray.raw[i] + \\\"\\\\t\\\"); } System.out.println(); }\",\"在这个示例中，我们首先创建了一个包含 1 到 10 的数组 subArray，然后使用 SubArray 类创建了两个子数组 sub1 和 sub2。这两个子数组分别引用了原始数组的不同部分。 接下来，我们修改了原始数组中的某个元素，然后打印出原始数组和两个 SubArray 的内容。通过这种方式，我们可以看到，SubArray 实际上是共享了同一片内存，因此对原始数组的修改会直接反映在 SubArray 中。\"]},\"137\":{\"h\":\"演示结果\",\"t\":[\"Original Array: [1, 2, 3, 4, 44, 6, 7, 8, 9, 10] SubArray1: 4 44 6 7 8 SubArray2: 7 8 9 10\",\"从输出结果可以看出，当我们修改了原数组中的某个元素后，这一修改在 SubArray1 中得到了反映，因为它们共享同一片内存区域。而 SubArray2 中的内容也反映了相应的部分，这说明我们可以通过 SubArray 类来实现类似 Go 语言中共享数组的效果。\"]},\"138\":{\"h\":\"总结\",\"t\":[\"通过这个简单的 SubArray 类，我们能够在 Java 中模拟 C、C++ 或 Go 语言中的数组内存共享功能。虽然 Java 不允许直接共享数组的内存部分，但通过定义子数组的方式，我们可以高效地管理和操作数组的不同部分，而不必担心多余的内存开销或数据复制。这种方法在需要频繁处理大型数组或在多线程环境下操作共享数据时特别有用。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb2版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"139\":{\"c\":[\"DM\"]},\"140\":{\"c\":[\"SubArray\"]},\"141\":{\"h\":\"索引管理\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/im/*\"]},\"142\":{\"h\":\"前言\",\"t\":[\"IM（Index Manager，索引管理器）是 EasyDB 中用于管理 B+ 树索引的模块。它为 EasyDB 提供了基于 B+ 树的聚簇索引功能。 在 EasyDB 的依赖关系图中可以看到，IM 直接基于 DM（Data Manager）实现，而没有依赖 VM（Version Manager）。这意味着索引数据直接存储在数据库文件中，而无需经过版本管理。本节不深入探讨 B+ 树的算法实现，而是重点描述其在 EasyDB 中的具体实现。\"]},\"143\":{\"h\":\"二叉树索引结构\",\"t\":[\"B+ 树由多个节点（Node）组成，每个节点都存储在一条 DataItem 中。其数据结构如下：\",\"[LeafFlag][KeyNumber][SiblingUid] [Son0][Key0][Son1][Key1]...[SonN][KeyN]\",\"LeafFlag：标记该节点是否为叶子节点。\",\"KeyNumber：该节点中键的数量。\",\"SiblingUid：指向兄弟节点在 DM 中的 UID。\",\"SonN 和 KeyN：交替存储子节点和键值对。最后一个键值始终为 MAX_VALUE，以便于查找。\",\"Node 类持有其所属的 B+ 树的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改和释放数据。\",\"public class Node { BPlusTree tree; DataItem dataItem; SubArray raw; long uid; ... }\"]},\"144\":{\"h\":\"根节点的初始化\",\"t\":[\"在 B+ 树中，生成根节点数据的方法如下：\",\"static byte[] newRootRaw(long left, long right, long key) { SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE); setRawIsLeaf(raw, false); setRawNoKeys(raw, 2); setRawSibling(raw, 0); setRawKthSon(raw, left, 0); setRawKthKey(raw, key, 0); setRawKthSon(raw, right, 1); setRawKthKey(raw, Long.MAX_VALUE, 1); return raw.raw; }\",\"这个方法生成的根节点包含两个初始子节点 left 和 right，以及一个初始键值 key。 生成一个空的根节点数据的方法如下：\",\"static byte[] newNilRootRaw() { SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE); setRawIsLeaf(raw, true); setRawNoKeys(raw, 0); setRawSibling(raw, 0); return raw.raw; }\"]},\"145\":{\"h\":\"搜索与插入操作\",\"t\":[\"Node 类提供了两个主要方法，用于辅助 B+ 树执行插入和搜索操作：searchNext 和 leafSearchRange。\",\"searchNext方法：根据给定的键值，查找对应的 UID。如果未找到，则返回兄弟节点的 UID。\",\"public SearchNextRes searchNext(long key) { dataItem.rLock(); try { SearchNextRes res = new SearchNextRes(); int noKeys = getRawNoKeys(raw); for(int i = 0; i < noKeys; i ++) { long ik = getRawKthKey(raw, i); if(key < ik) { res.uid = getRawKthSon(raw, i); res.siblingUid = 0; return res; } } res.uid = 0; res.siblingUid = getRawSibling(raw); return res; } finally { dataItem.rUnLock(); } }\",\"leafSearchRange方法：在当前节点内进行范围查找，范围为 [leftKey, rightKey]。如果 rightKey 大于等于该节点的最大键值，则返回兄弟节点的 UID，方便继续搜索下一个节点。\",\"public LeafSearchRangeRes leafSearchRange(long leftKey, long rightKey) { dataItem.rLock(); try { int noKeys = getRawNoKeys(raw); int kth = 0; while(kth < noKeys) { long ik = getRawKthKey(raw, kth); if(ik >= leftKey) { break; } kth ++; } List<Long> uids = new ArrayList<>(); while(kth < noKeys) { long ik = getRawKthKey(raw, kth); if(ik <= rightKey) { uids.add(getRawKthSon(raw, kth)); kth ++; } else { break; } } long siblingUid = 0; if(kth == noKeys) { siblingUid = getRawSibling(raw); } LeafSearchRangeRes res = new LeafSearchRangeRes(); res.uids = uids; res.siblingUid = siblingUid; return res; } finally { dataItem.rUnLock(); } }\"]},\"146\":{\"h\":\"根节点的管理\",\"t\":[\"由于 B+ 树在插入和删除操作时会动态调整，根节点并不是固定的。为此，系统设置了一个 bootDataItem，其中存储了根节点的 UID。操作 DM 时，IM 使用的事务 ID 为 SUPER_XID。\",\"public class BPlusTree { DataItem bootDataItem; private long rootUid() { bootLock.lock(); try { SubArray sa = bootDataItem.data(); return Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+8)); } finally { bootLock.unlock(); } } private void updateRootUid(long left, long right, long rightKey) throws Exception { bootLock.lock(); try { byte[] rootRaw = Node.newRootRaw(left, right, rightKey); long newRootUid = dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw); bootDataItem.before(); SubArray diRaw = bootDataItem.data(); System.arraycopy(Parser.long2Byte(newRootUid), 0, diRaw.raw, diRaw.start, 8); bootDataItem.after(TransactionManagerImpl.SUPER_XID); } finally { bootLock.unlock(); } } }\"]},\"147\":{\"h\":\"错误处理与恢复\",\"t\":[\"在 B+ 树的操作过程中，可能会出现两种主要错误：节点内部错误和节点间关系错误。\",\"节点内部错误：发生在事务 Ti 对节点的数据进行更改时，EasyDB 突然崩溃。由于 IM 依赖 DM，数据库重启后，Ti 会被撤销（undo），节点内部的错误影响将被消除。\",\"节点间关系错误：可能发生在某次对 u 节点的插入操作中，创建了新节点 v，此时 u 的兄弟节点指向 v，但 v 未被插入到父节点中。这会导致无法直接通过父节点找到 v，虽然可以通过兄弟节点间接找到，但这并不是理想状态。\"]},\"148\":{\"h\":\"结语\",\"t\":[\"通过上述设计与实现，IM 提供了 EasyDB 的索引管理功能，尽管目前不支持删除索引操作，但可以通过 XMAX 标记来避免数据的不一致性。在后续操作中，如果某个节点发生故障，系统仍然可以通过兄弟节点恢复大部分操作。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb8版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"149\":{\"c\":[\"IM\"]},\"150\":{\"c\":[\"index\"]},\"151\":{\"h\":\"全表扫描\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/tbm/Table.java\"]},\"152\":{\"h\":\"具体实现\"},\"153\":{\"h\":\"写前分析\",\"t\":[\"全表扫描的实现思路因人而异。对我而言，我选择在以下两种情况下触发全表扫描：\",\"where条件为空。\",\"需要查询的字段都没有建立索引，或者两个需要查询的字段中其中一个没有建立索引。\"]},\"154\":{\"h\":\"代码实现\",\"t\":[\"全表扫描的判断逻辑发生在Table.parseWhere()方法中。这个方法负责返回所有数据的UID，并对数据进行运算过滤。\",\"private List<Long> parseWhere(Where where, long xid) throws Exception { if (where == null) return getAllUid(); Field indexedField1 = findIndexedField(where.singleExp1.field); // 字段1是否存在索引 Field indexedField2 = where.singleExp2 != null ? findIndexedField(where.singleExp2.field) : null; // 字段2是否存在索引 List<Long> uids; // 如果两个条件字段都没有索引，执行全表扫描 if (indexedField1 == null && indexedField2 == null) { return performFullTableScanWithCondition(where, xid); } // 如果第一个条件字段有索引，使用第一个条件字段进行初步查询 if (indexedField1 != null) { CalWhereRes res = calWhere(indexedField1, where.singleExp1); uids = indexedField1.search(res.l0, res.r0); // 如果存在第二个条件字段 if (where.singleExp2 != null) { // 如果第二个条件字段也有索引，进行第二次索引查询 if (indexedField2 != null) { CalWhereRes res2 = calWhere(indexedField2, where.singleExp2); List<Long> additionalUids = indexedField2.search(res2.l0, res2.r0); if (\\\"and\\\".equals(where.logicOp)) { uids.retainAll(additionalUids); // 取交集 } else { Set<Long> mergedSet = new HashSet<>(uids); mergedSet.addAll(additionalUids); uids = new ArrayList<>(mergedSet); // 取并集 } } else { // 如果第二个条件字段没有索引，执行全表扫描，并取并集 List<Long> additionalUids = performFullTableScanWithCondition(new Where(where.singleExp2), xid); if (\\\"and\\\".equals(where.logicOp)) { uids.retainAll(additionalUids); // 取交集 } else { Set<Long> mergedSet = new HashSet<>(uids); mergedSet.addAll(additionalUids); uids = new ArrayList<>(mergedSet); // 取并集 } } } } else { // 如果第一个条件字段没有索引但第二个条件字段有索引 CalWhereRes res = calWhere(indexedField2, where.singleExp2); uids = indexedField2.search(res.l0, res.r0); // 因为第一个条件字段没有索引，需要全表扫描 List<Long> additionalUids = performFullTableScanWithCondition(new Where(where.singleExp1), xid); if (\\\"and\\\".equals(where.logicOp)) { uids.retainAll(additionalUids); // 取交集 } else { Set<Long> mergedSet = new HashSet<>(uids); mergedSet.addAll(additionalUids); uids = new ArrayList<>(mergedSet); // 取并集 } } return uids; }\"]},\"155\":{\"h\":\"获取所有UID\",\"t\":[\"当where条件为空时，直接返回所有UID。在这里实现存在简化，但我设计了隐藏字段以及主键，确保拥有一个索引字段。正常情况下，需要扫描磁盘来获取UID。\",\"private List<Long> getAllUid() throws Exception { Field fd = null; for (Field field : fields) { if (field.isIndexed()) { fd = field; break; } } return fd.search(0, Integer.MAX_VALUE); }\"]},\"156\":{\"h\":\"查找是否存在索引ID\",\"t\":[\"查找字段是否存在索引，用于后续的查询优化。\",\"private Field findIndexedField(String fieldName) { return fields.stream() .filter(field -> field.fieldName.equals(fieldName) && field.isIndexed()) .findFirst() .orElse(null); }\"]},\"157\":{\"h\":\"执行全表查询\",\"t\":[\"执行全表扫描，并根据条件进行过滤。\",\"private List<Long> performFullTableScanWithCondition(Where where, long xid) throws Exception { List<Long> uids = new ArrayList<>(); for (Long uid : getAllUid()) { // 通过所有UID进行过滤 byte[] data = ((TableManagerImpl) tbm).vm.read(xid, uid); if (data == null) continue; Map<String, Object> record = parseEntry(data); if (satisfiesCondition(record, where)) { uids.add(uid); } } return uids; }\"]},\"158\":{\"h\":\"判断是否符合条件\",\"t\":[\"判断记录是否符合条件，包括处理where条件中的逻辑运算。\",\"private boolean satisfiesCondition(Map<String, Object> record, Where where) throws Exception { // 先初始化处理singleExp1 boolean result1 = checkSingleCondition(record, where.singleExp1); if (where.singleExp2 == null) { return result1; } // 再次处理singleExp2的结果 boolean result2 = checkSingleCondition(record, where.singleExp2); switch (where.logicOp) { case \\\"and\\\": return result1 && result2; case \\\"or\\\": return result1 || result2; default: throw new IllegalArgumentException(\\\"Unsupported logical operation: \\\" + where.logicOp); } }\"]},\"159\":{\"h\":\"检查单个条件\",\"t\":[\"检查记录是否满足单个条件。\",\"private boolean checkSingleCondition(Map<String, Object> record, SingleExpression singleExp) throws Exception { // 从记录中获取字段值 Object valueInRecord = record.get(singleExp.field); if (valueInRecord == null) return false; // 记录中没有对应的字段 // 使用 string2Value 将条件的字符串值转换为适当的对象类型 Object conditionValue = string2Value(singleExp.value, singleExp.field); // 如果转换后的值为空，说明类型不匹配或字段不存在，返回 false if (conditionValue == null) return false; // 执行比较操作,将 valueInRecord 强制转换为 Comparable<Object>，以便后续可以调用 compareTo 方法进行比较 @SuppressWarnings(\\\"unchecked\\\") Comparable<Object> comparableValueInRecord = (Comparable<Object>) valueInRecord; switch (singleExp.compareOp.toLowerCase()) { case \\\"=\\\": return comparableValueInRecord.compareTo(conditionValue) == 0; case \\\">\\\": return comparableValueInRecord.compareTo(conditionValue) > 0; case \\\"<\\\": return comparableValueInRecord.compareTo(conditionValue) < 0; case \\\">=\\\": return comparableValueInRecord.compareTo(conditionValue) >= 0; case \\\"<=\\\": return comparableValueInRecord.compareTo(conditionValue) <= 0; case \\\"!=\\\": return comparableValueInRecord.compareTo(conditionValue) != 0; case \\\"like\\\": return ((String) valueInRecord).contains((String) conditionValue); // 其他比较操作 default: throw new IllegalArgumentException(\\\"Unsupported comparison operation: \\\" + singleExp.compareOp); } }\"]},\"160\":{\"h\":\"字符串转换为值\",\"t\":[\"将字符串值转换为字段的实际类型，起初使用的是Field进行处理的，但是会存在多个字段使用同一个索引的问题，会造成类型转换异常，所以这个方法也在Table中实现了一份。\",\"private Object string2Value(String value, String fieldName) { // 引入 fieldCache用于缓存字段名和 Field 对象之间的映射关系，减少多次查找同一字段的开销。 Field field = fieldCache.computeIfAbsent(fieldName, k -> fields.stream() .filter(f -> f.fieldName.equals(k)) .findFirst() .orElse(null)); if (field != null) { Types.SupportedType type = Types.SupportedType.fromTypeName(field.fieldType); return type.parseValue(value); } return null; }\"]},\"161\":{\"h\":\"计算条件\",\"t\":[\"根据字段和表达式计算条件范围。\",\"class CalWhereRes { long l0, r0, l1, r1; boolean single; } private CalWhereRes calWhere(Field field, SingleExpression exp) throws Exception { CalWhereRes res = new CalWhereRes(); FieldCalRes r = field.calExp(exp); res.l0 = r.left; res.r0 = r.right; res.single = true; return res; }\",\"通过上述实现，我们可以有效地处理全表扫描，并在条件合适的情况下进行索引查询和优化。这样不仅提高了查询效率，也确保了系统的灵活性和扩展性。希望通过本文的分享，能够对读者在全表扫描及其优化的实现上有所帮助。\",\"注\",\"本文作者：blockCloth版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"162\":{\"c\":[\"IM\"]},\"163\":{\"c\":[\"fullText\"]},\"164\":{\"h\":\"索引管理\"},\"165\":{\"h\":\"前言\",\"t\":[\"本篇文章主要介绍了 EasyDB 中两个关键模块的实现：索引管理器（Index Manager, IM）和全表扫描。索引管理器作为 EasyDB 的核心模块之一，负责管理 B+ 树索引，从而提高数据库的查询效率。而全表扫描则是当查询条件无法通过索引优化时，直接扫描整个表的实现方式。本文将通过具体代码示例，深入探讨这两个模块的实现细节与应用场景。\"]},\"166\":{\"h\":\"索引管理器（IM）\",\"t\":[\"IM 是 EasyDB 中用于管理 B+ 树索引的模块，旨在通过高效的数据结构来加速数据库的查询操作。IM 直接基于数据管理器（DM）实现，意味着索引数据直接存储在数据库文件中，而无需经过版本管理。本文详细介绍了 B+ 树的节点结构、根节点的初始化、索引的插入与搜索操作，以及在节点操作中的错误处理与恢复机制。这些内容将帮助读者理解如何在数据库系统中实现高效的索引管理。\"]},\"167\":{\"h\":\"全表扫描\",\"t\":[\"全表扫描是在查询条件无法通过索引优化时的一种查询策略。本文讨论了在以下两种情况下触发全表扫描：当 where 条件为空或查询的字段未建立索引时。通过对 Table 模块中的 parseWhere 方法进行解析，本文展示了如何判断是否需要进行全表扫描，以及如何在全表扫描过程中结合条件进行数据过滤。通过这些实现，EasyDB 能够在索引失效的情况下依然保证查询的完整性与正确性。\",\"通过对索引管理与全表扫描的深入解析，本文为读者提供了有关数据库系统中索引优化与查询策略的重要知识，希望能为开发者在实际项目中实现高效的数据管理与查询提供帮助。\"]},\"168\":{\"c\":[\"索引\"]},\"169\":{\"c\":[\"index\",\"fullIndex\"]},\"170\":{\"h\":\"前言\",\"t\":[\"项目地址：\",\"EasyDB：https://github.com/blockCloth/EasyDB\",\"MYDB：https://github.com/CN-GuoZiyang/MYDB\",\"React Teriminal：https://github.com/Tomotoes/react-terminal\",\"知识星球：https://www.javabetter.cn/zhishixingqiu/\"]},\"171\":{\"h\":\"前言\",\"t\":[\"在一次偶然的机会，通过二哥星球得知了 MYDB 项目。该项目凭借其独特的设计理念和简洁的实现方式，引起了我的极大兴趣。作为一名热衷于数据库技术的开发者，我不仅深刻学习了 MYDB 的核心功能，还萌生了对其进行二次开发的想法。 在深入研究 MYDB 项目的过程中，我发现了该项目的许多亮点，同时也注意到一些可以进一步优化和扩展的地方。因此，我决定在保留其原有设计优势的基础上，增加一些实用的新功能，以满足更多应用场景的需求。通过这些改进，我希望能够让 EasyDB 项目在更多场合下展现出其强大的功能性和灵活性。\"]},\"172\":{\"h\":\"整体结构\",\"t\":[\"EasyDB 的架构分为前端和后端两个部分，各自承担不同的职责：\"]},\"173\":{\"h\":\"前端\",\"t\":[\"前端的职责相对简单，主要任务是读取用户的输入，并将其发送到后端进行处理。处理完成后，前端接收并显示执行结果，等待用户的下一次输入。EasyDB 的前端采用了基于 React Terminal 项目二次开发的解决方案以及基于Socket交互，提供了一个直观的命令行界面，用户可以方便地与数据库进行交互。\"]},\"174\":{\"h\":\"后端\",\"t\":[\"后端则承担了更多的任务，负责解析并执行用户提交的 SQL 语句。如果输入的 SQL 语句合法，后端会尝试执行并返回结果；如果不合法，则会提示用户 SQL 语法错误。在 EasyDB 中，后端支持两种启动方式：\",\"基于 Socket 交互的启动：提供轻量级、低延迟的网络交互。\",\"基于 SpringBoot + React 的启动：集成了现代 Web 框架，为前后端提供更强大的支持和灵活性。\"]},\"175\":{\"h\":\"EasyDB 模块依赖与职责概述\",\"t\":[\"EasyDB 的模块设计遵循一定的依赖关系，通过拓扑排序可以清晰地看到各个模块的实现顺序。在本教程中，模块的实现顺序为：Transaction Manager (TM) -> Data Manager (DM) -> Version Manager (VM) -> Index Manager (IM) -> Table Manager (TBM)。\",\"image.png\"]},\"176\":{\"h\":\"模块职责\",\"t\":[\"Transaction Manager (TM)：\",\"职责：TM 负责管理事务的状态，通过维护 XID 文件来跟踪每个事务的状态。它提供接口，供其他模块查询特定事务的状态，从而确保事务的一致性和数据的完整性。\",\"Data Manager (DM)：\",\"职责：DM 直接管理数据库的 DB 文件和日志文件，其主要任务包括： \",\"分页管理：管理 DB 文件并对其进行分页缓存，以提高数据访问的效率。\",\"日志管理：管理日志文件，确保在发生错误时，系统能够根据日志恢复数据，保证数据的一致性。\",\"数据抽象：将 DB 文件抽象为 DataItem，供上层模块使用，同时提供相应的缓存机制。\",\"Version Manager (VM)：\",\"职责：VM 通过实现两阶段锁协议，确保调度序列的可串行化，并通过多版本并发控制（MVCC）消除读写阻塞。VM 支持两种事务隔离级别，以满足不同的并发需求。\",\"Index Manager (IM)：\",\"职责：IM 负责实现基于 B+ 树的数据索引，提升数据检索的效率。目前，where 子句仅支持已建立索引的字段。\",\"Table Manager (TBM)：\",\"职责：TBM 负责管理数据库中的表和字段信息。它还负责解析 SQL 语句，并根据解析结果执行相应的表操作，确保数据的正确性和结构的一致性。\"]},\"177\":{\"h\":\"开发环境与运行示例\"},\"178\":{\"h\":\"开发环境\",\"t\":[\"JDK >= 1.8\",\"Maven >= 3.5\"]},\"179\":{\"h\":\"运行示例\"},\"180\":{\"h\":\"SpringBoot\",\"t\":[\"如果你希望在 Spring Boot 环境下运行 EasyDB，下面是操作步骤：\",\"克隆项目并进入项目目录：\",\"git clone https://github.com/blockCloth/EasyDB.git cd EasyDB\",\"配置数据库路径： 在 application-dev.yml 文件中配置数据库路径，并且在application.yml中切换配置文件，例如：\",\"custom: db: path: D:/JavaCount/mydb/windows/\",\"启动 Spring Boot 应用： 直接在 IDE 中运行 Spring Boot 应用：\",\"@EnableScheduling @SpringBootApplication public class SimpleSqlDatabaseApplication { public static void main(String[] args) { SpringApplication.run(SimpleSqlDatabaseApplication.class, args); } }\",\"访问数据库服务： Spring Boot 应用启动后，数据库服务将会运行在指定的端口（默认为 8081）。你可以通过发送 HTTP 请求或使用 REST 客户端来访问数据库服务。\",\"通过前端客户端进行交互： 你可以在浏览器中访问：\",\"http://localhost:8081/index.html\",\"在页面中你可以输入 SQL 语句，前端会将其发送到后端 Spring Boot 服务进行处理，并显示执行结果。\"]},\"181\":{\"h\":\"使用maven编译项目\",\"t\":[\"首先执行一下命令编译源码：\",\"mvn compile\",\"编译完成后，使用以下命令创建数据库。此命令会在指定路径下创建一个新的数据库实例：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.backend.Launcher\\\"' '-Dexec.args=\\\"-create D:\\\\JavaCount\\\\mydb\\\\windows\\\"'\",\"数据库创建后，使用以下命令启动数据库服务。该服务会在本地机器的 9999 端口运行：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.backend.Launcher\\\"' '-Dexec.args=\\\"-open D:\\\\JavaCount\\\\mydb\\\\windows\\\\test\\\\test\\\"'\",\"打开一个新的终端窗口，执行以下命令启动数据库客户端。这将启动一个交互式命令行界面，用户可以在此输入类 SQL 语法，并将语句发送到数据库服务进行处理，随后返回执行结果：\",\"mvn exec:java '-Dexec.mainClass=\\\"com.dyx.simpledb.client.Launcher\\\"'\",\"执行示例：\",\"socket.png\"]},\"182\":{\"h\":\"通过 IntelliJ IDEA 配置和启动 EasyDB 项目\",\"t\":[\"在通过 IntelliJ IDEA 启动 EasyDB 项目时，你可以利用启动配置来自动化数据库的创建和启动过程。以下步骤将指导你如何配置 IntelliJ IDEA，使其在启动 com.dyx.simpledb.backend.Launcher 类时，先创建数据库并打开它，随后只需启动 com.dyx.simpledb.client.Launcher 类即可进行交互。\"]},\"183\":{\"h\":\"步骤一：配置 启动项\",\"t\":[\"创建启动配置： \",\"在 IntelliJ IDEA 中，打开 Run --> Edit Configurations。\",\"点击左上角的 + 按钮，选择 Application 以创建一个新的启动配置。\",\"配置数据库创建： \",\"在 Name 字段中输入合适的名称，例如 LauncherStart。\",\"在 Main class 字段中，选择 com.dyx.simpledb.backend.Launcher 作为主类。\",\"在 Program arguments 字段中，输入以下内容以创建数据库：\",\"-create D:/JavaCount/mydb/windows/mydb\",\"设置 Working directory 为项目的根目录，确保所有路径都能正确解析。\",\"配置数据库打开： \",\"重复以上步骤，创建另一个启动配置。将 Program arguments 字段修改为：\",\"-open D:/JavaCount/mydb/windows/mydb\",\"运行启动配置： \",\"首先运行创建数据库的启动配置，等待数据库创建成功。\",\"然后运行打开数据库的启动配置，启动数据库服务。\"]},\"184\":{\"h\":\"步骤二：启动 进行交互\",\"t\":[\"运行客户端： \",\"运行 com.dyx.simpledb.client.Launcher 启动配置，启动客户端。\",\"客户端启动后，将进入交互式命令行，你可以在其中输入 SQL 语句，与数据库进行交互。\",\"image.png\",\"提示\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb0版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"185\":{\"c\":[\"前言\"]},\"186\":{\"h\":\"Booter\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/tbm/Booter.java\",\"在 EasyDB 中，启动信息管理是数据库初始化和运行时的重要组成部分。启动信息存储在 bt 文件中，该文件主要记录了数据库的头表 UID。这些信息对于数据库的正常启动至关重要。为确保启动信息的一致性和正确性，EasyDB 使用了一种保证原子性的更新策略。\"]},\"187\":{\"h\":\"启动信息管理\",\"t\":[\"启动信息存储：EasyDB 的启动信息存储在 .bt 文件中，主要记录数据库的头表 UID。\",\"Booter 类：Booter 类提供了加载（load）和更新（update）启动信息的方法。\",\"原子性更新：为了确保启动信息的修改是原子的，update 方法首先将数据写入一个临时文件 .bt_tmp，然后通过操作系统的文件重命名操作将临时文件重命名为 .bt 文件。这种方式利用了操作系统重命名文件的原子性，确保了对 .bt 文件的更新操作的原子性，从而保证了启动信息的一致性。\"]},\"188\":{\"h\":\"基本定义\",\"t\":[\"Booter 类的主要字段和定义如下：\",\"public class Booter { // 数据库启动信息文件的后缀 public static final String BOOTER_SUFFIX = \\\".bt\\\"; // 数据库启动信息文件的临时后缀 public static final String BOOTER_TMP_SUFFIX = \\\".bt_tmp\\\"; // 数据库启动信息文件的路径 String path; // 数据库启动信息文件 File file; }\"]},\"189\":{\"h\":\"创建与打开启动信息文件\",\"t\":[\"create 和 open 方法用于创建或打开启动信息文件，并进行必要的校验。\",\"// 创建一个新的Booter对象 public static Booter create(String path) { removeBadTmp(path); // 删除可能存在的临时文件 File f = new File(path + BOOTER_SUFFIX); try { if (!f.createNewFile()) { Panic.panic(Error.FileExistsException); // 文件已存在，抛出异常 } } catch (Exception e) { Panic.panic(e); // 创建文件过程中出现异常，处理异常 } if (!f.canRead() || !f.canWrite()) { Panic.panic(Error.FileCannotRWException); // 文件不可读写，抛出异常 } return new Booter(path, f); // 返回新创建的Booter对象 } // 打开一个已存在的Booter对象 public static Booter open(String path) { removeBadTmp(path); // 删除可能存在的临时文件 File f = new File(path + BOOTER_SUFFIX); if (!f.exists()) { Panic.panic(Error.FileNotExistsException); // 文件不存在，抛出异常 } if (!f.canRead() || !f.canWrite()) { Panic.panic(Error.FileCannotRWException); // 文件不可读写，抛出异常 } return new Booter(path, f); // 返回打开的Booter对象 } // 删除可能存在的临时文件 private static void removeBadTmp(String path) { new File(path + BOOTER_TMP_SUFFIX).delete(); // 删除临时文件 }\"]},\"190\":{\"h\":\"加载启动信息\",\"t\":[\"load 方法用于加载 .bt 文件中的启动信息。\",\"public byte[] load() { try { return Files.readAllBytes(file.toPath()); // 读取文件的所有字节 } catch (IOException e) { Panic.panic(e); // 读取文件过程中出现异常，处理异常 } return null; }\"]},\"191\":{\"h\":\"更新启动信息\",\"t\":[\"update 方法用于更新 .bt 文件中的启动信息，并确保操作的原子性。\",\"public void update(byte[] data) { File tmp = new File(path + BOOTER_TMP_SUFFIX); try { tmp.createNewFile(); // 创建新的临时文件 } catch (Exception e) { Panic.panic(e); // 创建临时文件过程中出现异常，处理异常 } if (!tmp.canRead() || !tmp.canWrite()) { Panic.panic(Error.FileCannotRWException); // 临时文件不可读写，抛出异常 } try (FileOutputStream out = new FileOutputStream(tmp)) { out.write(data); // 将数据写入临时文件 out.flush(); // 刷新输出流，确保数据写入文件 } catch (IOException e) { Panic.panic(e); // 写入文件过程中出现异常，处理异常 } try { Files.move(tmp.toPath(), new File(path + BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING); // 将临时文件移动并替换原文件 } catch (IOException e) { Panic.panic(e); // 移动文件过程中出现异常，处理异常 } file = new File(path + BOOTER_SUFFIX); // 更新file字段为新的启动信息文件 if (!file.canRead() || !file.canWrite()) { Panic.panic(Error.FileCannotRWException); // 新的启动信息文件不可读写，抛出异常 } }\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb9版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"192\":{\"c\":[\"TBM\"]},\"193\":{\"c\":[\"booter\"]},\"194\":{\"h\":\"使用JSQLParser进行SQL解析\",\"t\":[\"JSQLParser 是一个强大的 Java 库，用于解析 SQL 语句并将其转换为易于处理的 Java 对象。本文将通过解析 Parser 类，讲解如何使用 JSQLParser 解析和处理不同类型的 SQL 语句。\"]},\"195\":{\"h\":\"简介\",\"t\":[\"Parser 类是一个用于解析 SQL 语句的核心组件。它基于 JSQLParser 库，能够解析各种 SQL 语句并将其转换为 Java 对象，便于在应用程序中进行后续处理。类中的主要方法 Parse 是解析 SQL 语句的入口点，根据不同的 SQL 语句类型，调用相应的解析方法。\"]},\"196\":{\"h\":\"方法\",\"t\":[\"Parse 方法是解析 SQL 语句的入口。它首先将 SQL 语句转换为字符串，然后基于语句的类型调用不同的解析方法。\",\"public static Object Parse(byte[] statement) throws Exception { String sql = new String(statement).trim(); // 处理事务控制语句 if (sql.toUpperCase().startsWith(\\\"BEGIN\\\")) { return parseBegin(sql); } else if (sql.equalsIgnoreCase(\\\"ABORT\\\") || sql.equalsIgnoreCase(\\\"ABORT;\\\")) { return parseAbort(); } else if (sql.equalsIgnoreCase(\\\"COMMIT\\\") || sql.equalsIgnoreCase(\\\"COMMIT;\\\")) { return parseCommit(); } Statement parsedStatement; try { parsedStatement = CCJSqlParserUtil.parse(sql); } catch (JSQLParserException e) { // 处理 SQL 语句解析异常 String message = e.getMessage(); String result = null; int startIndex = message.indexOf(\\\"Encountered unexpected token:\\\"); int endIndex = message.indexOf(\\\"\\\\nWas expecting one of:\\\"); if (startIndex != -1 && endIndex != -1) { result = message.substring(startIndex, endIndex); } throw new RuntimeException(\\\"Invalid statement: \\\" + (result == null ? sql : result), e); } // 调用相应的解析方法 if (parsedStatement instanceof CreateTable) { return parseCreate((CreateTable) parsedStatement); } else if (parsedStatement instanceof Select) { return parseSelect((Select) parsedStatement); } else if (parsedStatement instanceof Insert) { return parseInsert((Insert) parsedStatement); } else if (parsedStatement instanceof Update) { return parseUpdate((Update) parsedStatement); } else if (parsedStatement instanceof Delete) { return parseDelete((Delete) parsedStatement); } else if (parsedStatement instanceof Drop) { return parseDrop((Drop) parsedStatement); } else if (parsedStatement instanceof ShowStatement) { return parseShow((ShowStatement) parsedStatement); } else { throw new RuntimeException(\\\"Unsupported statement: \\\" + sql); } }\"]},\"197\":{\"h\":\"解析不同类型的 SQL 语句\"},\"198\":{\"h\":\"解析 语句\",\"t\":[\"parseSelect 方法解析 SELECT 语句，提取查询的字段、表名、ORDER BY 子句和 WHERE 条件。\",\"private static SelectObj parseSelect(Select select) { SelectObj read = new SelectObj(); List<String> fields = new ArrayList<>(); List<String> orderFields = new ArrayList<>(); List<Boolean> orderAscFields = new ArrayList<>(); select.getSelectBody().accept(new SelectVisitorAdapter() { @Override public void visit(PlainSelect plainSelect) { // 处理 SELECT 字段 plainSelect.getSelectItems().forEach(selectItem -> { String fieldName = selectItem instanceof SelectExpressionItem ? ((SelectExpressionItem) selectItem).getExpression().toString() : selectItem.toString(); fields.add(fieldName); }); // 处理 ORDER BY 字段 if (plainSelect.getOrderByElements() != null) { plainSelect.getOrderByElements().forEach(orderByElement -> { String orderField = orderByElement.getExpression().toString(); orderFields.add(orderField); orderAscFields.add(orderByElement.isAsc()); }); } // 设置查询字段和表名 read.fields = fields.toArray(new String[0]); read.tableName = plainSelect.getFromItem().toString(); // 初始化 ORDER BY 表达式 read.orderByExpression = new OrderByExpression(); // 设置 ORDER BY 表达式 read.orderByExpression.fields = orderFields.toArray(new String[0]); read.orderByExpression.order = orderAscFields.toArray(new Boolean[0]); // 设置 WHERE 子句 if (plainSelect.getWhere() != null) { read.where = parseWhere(plainSelect.getWhere().toString()); } } }); return read; }\"]},\"199\":{\"h\":\"解析 语句\",\"t\":[\"parseInsert 方法解析 INSERT 语句，提取插入的数据表名、列名和值。\",\"private static InsertObj parseInsert(Insert insertStmt) throws Exception { InsertObj insertObj = new InsertObj(); insertObj.tableName = insertStmt.getTable().getName(); List<String> values = new ArrayList<>(); List<String> columnNames = new ArrayList<>(); // 获取列名 if (insertStmt.getColumns() != null && !insertStmt.getColumns().isEmpty()) { insertStmt.getColumns().forEach(column -> columnNames.add(column.getColumnName())); } // 获取值 insertStmt.getItemsList().accept(new ItemsListVisitorAdapter() { @Override public void visit(ExpressionList expressionList) { expressionList.getExpressions().forEach(expression -> { // 将表达式转换为字符串并去掉单引号 String value = expression.toString().replace(\\\"'\\\", \\\"\\\"); // 去掉前后的括号 value = value.replaceAll(\\\"^\\\\\\\\(|\\\\\\\\)$\\\", \\\"\\\"); values.add(value); }); } }); // 检查列名与值的数量是否匹配 if (!columnNames.isEmpty() && columnNames.size() != values.size()) { throw new Exception(\\\"Column count does not match value count.\\\"); } insertObj.fields = columnNames.toArray(new String[0]); insertObj.values = values.toArray(new String[0]); return insertObj; }\"]},\"200\":{\"h\":\"解析 语句\",\"t\":[\"parseUpdate 方法解析 UPDATE 语句，提取更新的表名、列名、更新值和 WHERE 条件。\",\"private static UpdateObj parseUpdate(Update updateStmt) { UpdateObj updateObj = new UpdateObj(); updateObj.tableName = updateStmt.getTable().getName(); updateObj.fieldName = updateStmt.getColumns().get(0).getColumnName(); updateObj.value = updateStmt.getExpressions().get(0).toString(); if (updateStmt.getWhere() != null) { updateObj.where = parseWhere(updateStmt.getWhere().toString()); } return updateObj; }\"]},\"201\":{\"h\":\"解析 语句\",\"t\":[\"parseDelete 方法解析 DELETE 语句，提取删除操作的表名和 WHERE 条件。\",\"private static DeleteObj parseDelete(Delete deleteStmt) { DeleteObj deleteObj = new DeleteObj(); deleteObj.tableName = deleteStmt.getTable().getName(); if (deleteStmt.getWhere() != null) { deleteObj.where = parseWhere(deleteStmt.getWhere().toString()); } return deleteObj; }\"]},\"202\":{\"h\":\"解析 语句\",\"t\":[\"parseCreate 方法解析 CREATE TABLE 语句，提取表名、列定义和索引等信息。\",\"private static Create parseCreate(CreateTable createTable) { Create create = new Create(); create.tableName = createTable.getTable().getName(); List<String> fieldNames = new ArrayList<>(); List<String> fieldTypes = new ArrayList<>(); List<String> indexes = new ArrayList<>(); List<String> autoIncrement = new ArrayList<>(); List<String> notNull = new ArrayList<>(); List<String> unique = new ArrayList<>(); for (ColumnDefinition columnDefinition : createTable.getColumnDefinitions()) { fieldNames.add(columnDefinition.getColumnName()); fieldTypes.add(columnDefinition.getColDataType().toString()); if (columnDefinition.getColumnSpecs() != null) { for (String columnSpec : columnDefinition.getColumnSpecs()) { if (columnSpec.equalsIgnoreCase(\\\"PRIMARY\\\")) { create.primaryKey = columnDefinition.getColumnName(); } else if (columnSpec.equalsIgnoreCase(\\\"AUTO_INCREMENT\\\")) { autoIncrement.add(columnDefinition.getColumnName()); } else if (columnSpec.equalsIgnoreCase(\\\"NOT\\\")) { notNull.add(columnDefinition.getColumnName()); } else if (columnSpec.equalsIgnoreCase(\\\"UNIQUE\\\")) { unique.add(columnDefinition.getColumnName()); } } } } if (createTable.getIndexes() != null) { for (Index index : createTable.getIndexes()) { // 只处理单列索引 if (index.getColumnsNames().size() == 1) { indexes.add(index.getColumnsNames ().get(0)); } } } create.fieldName = fieldNames.toArray(new String[0]); create.fieldType = fieldTypes.toArray(new String[0]); create.index = indexes.toArray(new String[0]); create.autoIncrement = autoIncrement.toArray(new String[0]); create.notNull = notNull.toArray(new String[0]); create.unique = unique.toArray(new String[0]); return create; }\"]},\"203\":{\"h\":\"处理事务语句\",\"t\":[\"除了常见的 SQL 操作，Parser 类还处理事务控制语句，如 BEGIN、COMMIT 和 ABORT。这些方法会解析 SQL 字符串并返回相应的事务操作对象。\",\"private static Abort parseAbort() { return new Abort(); } private static Commit parseCommit() { return new Commit(); } private static Begin parseBegin(String sql) throws Exception { sql = sql.trim(); if (sql.endsWith(\\\";\\\")){ sql = sql.substring(0,sql.length() - 1).trim(); } Tokenizer tokenizer = new Tokenizer(sql.getBytes()); tokenizer.peek(); tokenizer.pop(); String isolation = tokenizer.peek(); Begin begin = new Begin(); if (\\\"\\\".equals(isolation)) { begin.isolationLevel = IsolationLevel.READ_COMMITTED; return begin; } // 处理事务隔离级别的解析 // ... return begin; }\",\"注\",\"本文作者：blockCloth版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"204\":{\"c\":[\"TBM\"]},\"205\":{\"c\":[\"jsqlparse\"]},\"206\":{\"h\":\"字段与表管理\"},\"207\":{\"h\":\"前言\",\"t\":[\"在数据库管理系统中，Table Manager（TBM）模块是核心组成部分，负责管理数据库中的所有表及其结构。该模块的主要任务包括表的创建、查询、更新和删除操作，以及对字段约束、数据一致性和事务管理的支持。为了确保数据库操作的正确性和高效性，TBM模块通过多种策略和技术来处理复杂的数据库管理任务。 本文将介绍TBM模块中涉及的关键内容和核心功能，包括启动信息管理、表结构管理以及SQL解析等方面。通过这些内容的讲解，读者将能深入理解TBM模块如何在数据库系统中发挥作用。\"]},\"208\":{\"h\":\"启动信息管理\",\"t\":[\"启动信息管理是数据库启动和运行的重要环节，TBM模块中的启动信息存储在.bt文件中。该文件主要记录了数据库的头表UID（唯一标识符），这些信息对数据库的正常启动至关重要。为了确保启动信息的一致性，TBM模块使用了原子性更新策略，通过将更新数据写入临时文件，再将其重命名为正式文件，从而保证了启动信息的安全性和正确性。\"]},\"209\":{\"h\":\"表结构管理与字段约束\",\"t\":[\"数据库中的表和字段信息以二进制形式存储，并且在创建表时会考虑到字段的各种约束条件，例如自增、唯一性和非空约束。TBM模块通过对表和字段的细致管理，确保了数据的一致性和操作的高效性。此外，为了处理一些特殊情况，系统还会自动生成隐藏字段，以支持数据查询和唯一性保证。\"]},\"210\":{\"h\":\"SQL解析与事务处理\",\"t\":[\"TBM模块中的SQL解析功能使用了JSQLParser库，能够解析各种SQL语句（如CREATE、SELECT、INSERT、UPDATE、DELETE等），并将其转换为可操作的Java对象。这一功能使得系统能够灵活处理不同类型的SQL语句，并对其进行进一步的处理。此外，TBM模块还支持事务管理，通过对BEGIN、COMMIT和ABORT等事务控制语句的解析和处理，确保数据库操作的完整性和一致性。\"]},\"211\":{\"c\":[\"字段与表\"]},\"212\":{\"c\":[\"booter\",\"jsqlparser\",\"TBM\",\"table\",\"field\"]},\"213\":{\"h\":\"字段与表管理\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/tbm/Table、Field.java\"]},\"214\":{\"h\":\"数据库表结构与字段约束的实现\",\"t\":[\"在数据库管理系统中，表结构和字段是数据存储的核心组成部分。本文将介绍如何在我们的数据库系统中定义、创建和管理表结构和字段，同时讲解如何处理字段的各种约束条件，例如自增、唯一性和非空约束。为了确保数据库操作的正确性和数据的一致性，我们还将讨论隐藏字段和查询操作中涉及的约束验证。\"]},\"215\":{\"h\":\"数据存储结构\",\"t\":[\"数据库中的表和字段信息以二进制形式存储在称为 Entry 的数据结构中。\"]},\"216\":{\"h\":\"表的存储结构\",\"t\":[\"在我们的系统中，每个表的信息都按照一定的结构存储。这个结构包含了表名、指向下一个表的链接以及表中各个字段的唯一标识符（UID）。这类似于一本书的目录，其中记录了每章的名称以及它们的位置。 具体结构如下：\",\"[TableName] [NextTable] [Field1Uid][Field2Uid]...[FieldNUid]\",\"TableName: 表的名称，例如“用户表”或“订单表”。\",\"NextTable: 如果数据库中有多个表，那么每个表会链接到下一个表。这个字段保存下一个表的唯一标识符。\",\"FieldUIDs: 这是表中所有字段的唯一标识符的列表。这些标识符用于快速定位字段信息。\",\"Java 实现示例：\",\"public class Table { TableManager tbm; // 表管理器，用于管理数据库表 long uid; // 表的唯一标识符 String name; // 表的名称 byte status; // 表的状态 long nextUid; // 下一个表的唯一标识符 List<Field> fields = new ArrayList<>(); // 表的字段列表 }\"]},\"217\":{\"h\":\"字段的存储结构\",\"t\":[\"字段是数据库表中的基本单元，每个字段都具有一个名称、一个类型（例如整数或字符串）以及一个可能的索引（用于加快查询速度）。 字段的存储结构如下：\",\"[FieldName] [TypeName] [IndexUid]\",\"FieldName: 这个字段的名字，例如“用户名”或“订单ID”。\",\"TypeName: 字段的数据类型，目前支持int,long,float,double,varchar,datetime\",\"IndexUid: 如果这个字段被建立了索引，那么这个标识符指向该索引的根节点。否则，它的值为 0。\",\"Java 实现示例：\",\"public class Field { long uid; // 字段的唯一标识符 private Table tb; // 字段所属的表 String fieldName; // 字段名称 String fieldType; // 字段类型 private long index; // 索引的唯一标识符 private BPlusTree bt; // B+树，用于索引字段值 }\"]},\"218\":{\"h\":\"表的创建与持久化\",\"t\":[\"在数据库中，创建一张表并不仅仅是指定表名和字段那么简单。我们还需要考虑字段的约束条件，例如字段是否必须唯一、是否允许为空，以及是否需要自动增长（通常用于主键字段）。\"]},\"219\":{\"h\":\"创建表\",\"t\":[\"当我们调用 createTable 方法时，我们指定了表名和字段的详细信息。系统会根据用户的输入自动处理每个字段的约束条件，并将这些信息存储在数据库中。 举个例子，如果我们希望创建一个包含用户信息的表，我们可能会希望“用户ID”字段是唯一的且自动增长，而“用户名”字段则必须是唯一的且不能为空。创建表的 Java 代码示例：\",\"public static Table createTable(TableManager tbm, long nextUid, long xid, Create create) throws Exception { // 创建表对象 Table tb = new Table(tbm, create.tableName, nextUid); // 处理主键、自增、非空、唯一约束 String primaryKey = create.primaryKey; Set<String> notNullFields = new HashSet<>(Arrays.asList(create.notNull)); Set<String> autoIncrementFields = new HashSet<>(Arrays.asList(create.autoIncrement)); Set<String> uniqueFields = new HashSet<>(Arrays.asList(create.unique)); boolean isIndexed = false; for (int i = 0; i < create.fieldName.length; i++) { String fieldName = create.fieldName[i]; String fieldType = create.fieldType[i]; // 判断字段的各类约束 boolean isPrimaryKey = primaryKey != null && primaryKey.equalsIgnoreCase(fieldName); boolean isNotNull = notNullFields.contains(fieldName) || isPrimaryKey; boolean isUnique = uniqueFields.contains(fieldName) || isPrimaryKey; boolean isAutoIncrement = autoIncrementFields.contains(fieldName); // 检查自增字段的类型 if (isAutoIncrement && !\\\"int\\\".equalsIgnoreCase(fieldType)) { throw new IllegalArgumentException(\\\"自增字段类型必须为int\\\"); } boolean indexed = isPrimaryKey || (!isIndexed && isNotNull); if (indexed) { isIndexed = true; } // 创建字段 tb.fields.add(Field.createField(tb, xid, fieldName, fieldType, indexed, isAutoIncrement, isNotNull, isUnique)); } // 如果没有显式索引字段，创建隐藏字段 if (!isIndexed) { tb.fields.add(Field.createField(tb, xid, \\\"GEN_CLUST_INDEX\\\", \\\"int\\\", true, true, true, true)); autoIncrementFields.add(\\\"GEN_CLUST_INDEX\\\"); } // 持久化表对象 return tb.persistSelf(xid); }\"]},\"220\":{\"h\":\"字段的创建与约束实现\",\"t\":[\"在创建字段时，我们需要为每个字段配置它的特定约束条件，比如是否允许为空、是否必须唯一、以及是否自动增长。我们通过以下代码来实现这些约束：创建字段的 Java 代码示例：\",\"public static Field createField(Table tb, long xid, String fieldName, String fieldType, boolean indexed, boolean isAutoIncrement, boolean isNotNull, boolean isUnique) throws Exception { // 检查字段类型有效性 typeCheck(fieldType); Field f = new Field(tb, fieldName, fieldType, 0, isAutoIncrement, isNotNull, isUnique); if (indexed) { long index = BPlusTree.create(((TableManagerImpl) tb.tbm).dm); BPlusTree bt = BPlusTree.load(index, ((TableManagerImpl) tb.tbm).dm); f.index = index; f.bt = bt; } f.persistSelf(xid); return f; }\"]},\"221\":{\"h\":\"字段约束的实现\",\"t\":[\"在插入数据时，我们需要确保字段的值满足所有设置的约束条件，这里就以唯一约束为例。例如，若某个字段设置了唯一性约束，我们必须在插入新数据之前检查这个值是否已经存在于数据库中。插入数据时的约束检查：\",\"public void insert(long xid, InsertObj insertObj) throws Exception { Map<String, Object> entry = string2Entry(insertObj); byte[] raw = entry2Raw(entry); long uid = ((TableManagerImpl) tbm).vm.insert(xid, raw); for (Field field : fields) { if (field.isIndexed()) { field.insert(entry.get(field.fieldName), uid); } } // 更新唯一约束值集合 updateUniqueValues(entry); } private void updateUniqueValues(Map<String, Object> entry) { for (Field field : fields) { if (field.isUnique && entry.containsKey(field.fieldName)) { field.uniqueValues.add(entry.get(field.fieldName)); } } }\"]},\"222\":{\"h\":\"隐藏字段的实现\",\"t\":[\"有时用户在创建表时可能没有显式指定主键或索引字段。这种情况下，系统会自动生成一个隐藏字段来作为表的主键或索引字段。这个隐藏字段不会展示给用户，但它在确保数据的唯一性和加快查询速度方面起到了关键作用。隐藏字段的 Java 实现：\",\"// 检查并创建隐藏字段 if (!isIndexed) { tb.fields.add(Field.createField(tb, xid, \\\"GEN_CLUST_INDEX\\\", \\\"int\\\", true, true, true, true)); autoIncrementFields.add(\\\"GEN_CLUST_INDEX\\\"); }\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb9版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"223\":{\"c\":[\"TBM\"]},\"224\":{\"c\":[\"table\",\"field\"]},\"225\":{\"h\":\"TBM 的实现\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/tbm/*\"]},\"226\":{\"h\":\"基本定义\",\"t\":[\"TableManager 的核心作用是处理数据库表的管理，包括创建、查询、更新、删除等操作。所有操作的结果直接以字节数组的形式返回，例如错误信息或执行结果。\",\"TableManager 的方法实现主要依赖于底层的版本管理器（VM）和数据管理器（DM），从而实现对数据库的各种操作。\",\"在创建新表时，系统采用了头插法，即每次新表创建都会插入到链表的头部。这意味着新创建的表会成为表链表的第一个元素。由于头插法的特性，每次表的创建都会导致链表头部的变化，因此需要更新 Booter 文件，以记录最新的表链表头部的 UID。\",\"在 TableManager 对象初始化时，系统会自动加载并初始化表的信息。\",\"public interface TableManager { BeginRes begin(Begin begin); byte[] commit(long xid) throws Exception; byte[] abort(long xid); byte[] show(long xid); byte[] create(long xid, Create create) throws Exception; byte[] insert(long xid, Insert insert) throws Exception; byte[] read(long xid, Select select) throws Exception; byte[] update(long xid, Update update) throws Exception; byte[] delete(long xid, Delete delete) throws Exception; }\",\"public class TableManagerImpl implements TableManager { VersionManager vm; // 版本管理器，用于处理事务和数据的版本控制 DataManager dm; // 数据管理器，负责数据的存储和读取操作 private Booter booter; // 启动信息管理器，用于管理数据库的启动信息 private Map<String, Table> tableCache; // 表缓存，存储已加载的表对象 private Map<Long, List<Table>> xidTableCache; // 事务表缓存，记录每个事务修改过的表 private Lock lock; // 锁，用于确保多线程环境下的操作安全 TableManagerImpl(VersionManager vm, DataManager dm, Booter booter) { this.vm = vm; this.dm = dm; this.booter = booter; this.tableCache = new HashMap<>(); this.xidTableCache = new HashMap<>(); this.lock = new ReentrantLock(); loadTables(); } }\"]},\"227\":{\"h\":\"\",\"t\":[\"/** * 加载数据库中的所有表到缓存中。 */ private void loadTables() { // 获取第一个表的UID long uid = firstTableUid(); // 循环加载所有表，直到没有下一个表 while (uid != 0) { // 通过UID加载表对象 Table tb = Table.loadTable(this, uid); // 获取下一个表的UID uid = tb.nextUid; // 将表对象加入缓存 tableCache.put(tb.name, tb); } } /** * 获取第一个表的UID，来自Booter文件。 * @return 第一个表的UID */ private long firstTableUid() { byte[] raw = booter.load(); // 加载Booter文件内容 return Parser.parseLong(raw); // 解析出第一个表的UID }\"]},\"228\":{\"h\":\"\",\"t\":[\"在 create() 方法中，TableManager 负责创建新表，并在表链表中维护最新的表结构。此方法的实现强调了线程安全性，同时确保新表的正确创建和缓存更新。\",\"@Override public byte[] create(long xid, Create create) throws Exception { lock.lock(); // 加锁以防止并发问题 try { // 检查是否已有同名表存在，避免重复创建 if (tableCache.containsKey(create.tableName)) { throw Error.DuplicatedTableException; } // 创建新的表对象 Table table = Table.createTable(this, firstTableUid(), xid, create); // 更新表链表的头部UID updateFirstTableUid(table.uid); // 将新创建的表放入缓存 tableCache.put(create.tableName, table); // 如果事务缓存中没有此事务ID的条目，则创建一个新的条目 if (!xidTableCache.containsKey(xid)) { xidTableCache.put(xid, new ArrayList<>()); } // 将新创建的表添加到当前事务的表列表中 xidTableCache.get(xid).add(table); // 返回创建表的成功消息 return (\\\"create \\\" + create.tableName).getBytes(); } finally { lock.unlock(); // 解锁以允许其他操作 } }\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb9版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"229\":{\"c\":[\"TBM\"]},\"230\":{\"c\":[\"TBM\"]},\"231\":{\"h\":\"事务管理\",\"t\":[\"前言\",\"在现代数据库管理系统中，事务管理（Transaction Management，简称 TM）是一个至关重要的模块。它负责确保数据库操作的原子性、一致性、隔离性和持久性（ACID 特性），以保障数据在高并发环境下的正确性与可靠性。每当你进行一次数据库操作，TM 模块就像是一个无形的保护者，在背后默默地记录和监控着每一个事务的状态，确保数据操作能够顺利完成或在异常情况下能够安全回滚。\",\"在 EasyDB 中，事务管理模块通过维护一个称为 XID 的文件，记录了每个事务的状态。这个文件就像是一张任务清单，每个事务在清单中都有一个唯一的编号，表示它当前的状态是正在进行、已提交，还是已回滚。本文将深入探讨 TM 模块的实现细节，包括事务的开始、提交、回滚以及事务状态的检查和管理。\",\"事务管理模块不仅仅是数据库的核心功能之一，它还提供了接口供其他模块查询事务状态，确保整个数据库系统能够在高并发操作下正常运行。在接下来的章节中，我们将从实际代码出发，详细讲解事务管理模块是如何在 EasyDB 中实现和运作的。\"]},\"232\":{\"c\":[\"事务\"]},\"233\":{\"h\":\"事务管理实现与解析\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/tm/*\",\"假如你是一名负责管理重要文档的管理员。每份文档都代表着一项关键任务（事务），你的职责是确保这些任务被准确记录、顺利执行，并最终完成。如果任务顺利完成，你需要提交文档以确认其状态；而如果在执行过程中出现问题，你则需要将文档恢复到最初状态，也就是进行回滚。你的工具就是这篇教程中的 TransactionManager，它就像是你的任务调度器，帮助你实时跟踪和管理每个任务的状态，确保任务按计划进行或及时处理任何异常情况。\"]},\"234\":{\"h\":\"XID文件结构以及规则\",\"t\":[\"TM 是通过维护 XID 文件来维护事务的状态的，并提供接口供其他模块来查询某个事务的状态，下面就来介绍一下 XID 文件\",\"我们可以把 XID 文件比喻成一个任务清单，每个事务都有一个独特的编号（XID），就像每个任务在清单上都有它的专属编号。TransactionManager 就像是一位任务管理员，通过这个清单，它可以随时知道哪些任务正在进行（active），哪些已经完成（committed），哪些被取消（aborted）。\"]},\"235\":{\"h\":\"XID 的定义\",\"t\":[\"事务标识符（XID）：\",\"每个事务都有一个唯一的事务标识符 XID，从 1 开始递增。\",\"XID 0 被特殊定义为超级事务（Super Transaction），用于表示在没有申请事务的情况下进行的操作，其状态永远是committed\"]},\"236\":{\"h\":\"事务的状态\",\"t\":[\"三种状态： \",\"active：正在进行，尚未结束。\",\"committed：已提交。\",\"aborted：已撤销或回滚。\"]},\"237\":{\"h\":\"XID 文件的结构和管理\",\"t\":[\"TransactionManager 的职责： \",\"维护一个 XID 格式的文件，用于记录各个事务的状态。\",\"每个事务在 XID 文件中分配一个字节的空间，用于保存其状态。\",\"XID 文件的头部保存一个 8 字节的数字，用于记录这个 XID 文件管理的事务的个数。\",\"事务 XID 在文件中的状态存储在 (XID-1) + 8 字节的位置处（因为 XID 0 不需要记录状态）。\"]},\"238\":{\"h\":\"TransactionManager 的接口定义\",\"t\":[\"begin()：开启事务。\",\"commit(long xid)：提交事务。\",\"abort(long xid)：撤销或回滚事务。\",\"isActive(long xid)：查询一个事务的状态是否正在运行。\",\"isCommitted(long xid)：查询一个事务的状态是否已经提交。\",\"isAborted(long xid)：查询一个事务的状态是否撤销或回滚。\",\"close()：关闭事务。\",\"public interface TransactionManager { long begin(); // 开启一个新事务 void commit(long xid); // 提交一个事务 void abort(long xid); // 取消一个事务 boolean isActive(long xid); // 查询一个事务的状态是否是正在进行的状态 boolean isCommitted(long xid); // 查询一个事务的状态是否是已提交 boolean isAborted(long xid); // 查询一个事务的状态是否是已取消 void close(); // 关闭TM }\"]},\"239\":{\"h\":\"TM模块的实现\"},\"240\":{\"h\":\"常量定义\",\"t\":[\"public class TransactionManagerImpl implements TransactionManager { // XID文件头长度 static final int LEN_XID_HEADER_LENGTH = 8; // 每个事务的占用长度 private static final int XID_FIELD_SIZE = 1; // 事务的三种状态 private static final byte FIELD_TRAN_ACTIVE = 0; private static final byte FIELD_TRAN_COMMITTED = 1; private static final byte FIELD_TRAN_ABORTED = 2; // 超级事务，永远为commited状态 public static final long SUPER_XID = 0; // XID文件后缀 static final String XID_SUFFIX = \\\".xid\\\"; }\"]},\"241\":{\"h\":\"XID文件的校验与读取\"},\"242\":{\"h\":\"校验XID文件\",\"t\":[\"在创建 TransactionManager的构造函数后，首先需要对 XID 文件进行校验，以确保其合法性。校验过程相对简单，通过读取文件头的 8 字节数字推算出文件的理论长度，并将其与实际长度进行对比。如果两者不一致，则认为该 XID 文件存在问题，不符合规范。对于校验未通过的情况，系统会立即触发 panic 方法，强制终止运行。在一些关键基础模块中，一旦发生无法恢复的错误，系统会直接停机，以确保整体系统的安全性和稳定性。\",\"checkXIDCount.png\",\"private void checkXIDCounter() { // 初始化文件长度为0 long fileLen = 0; try { fileLen = file.length(); } catch (IOException e1) { Panic.panic(Error.BadXIDFileException); } // 如果文件长度小于XID头部长度，抛出异常 if (fileLen < LEN_XID_HEADER_LENGTH) { Panic.panic(Error.BadXIDFileException); } ByteBuffer buf = ByteBuffer.allocate(LEN_XID_HEADER_LENGTH); try { fc.position(0); fc.read(buf); } catch (IOException e) { Panic.panic(e); } this.xidCounter = Parser.parseLong(buf.array()); long end = getXidPosition(this.xidCounter + 1); if (end != fileLen) { Panic.panic(Error.BadXIDFileException); } }\"]},\"243\":{\"h\":\"获取XID位置\",\"t\":[\"根据事务xid取得其在xid文件中对应的位置\",\"private long getXidPosition(long xid) { return LEN_XID_HEADER_LENGTH + (xid - 1) * XID_FIELD_SIZE; }\"]},\"244\":{\"h\":\"事务的开始与状态更新\"},\"245\":{\"h\":\"开始一个事务（begin）\",\"t\":[\"想象一下，当你在任务清单上新增一个任务时，你需要先给它分配一个编号，并标记为“进行中”。begin() 方法就做了这样的工作：它先为事务分配一个新的 XID，然后标记它为“进行中”，最后把这个信息写入你的任务清单中，并保存起来。这个过程确保每个新任务都有一个独一无二的标识符，并且其状态被准确记录下来，使得你可以随时跟踪和管理任务的进展。这就像是在项目管理中为每个新任务建立一个详细的记录，确保任务按计划进行，防止遗漏或混淆。\",\"public long begin() { counterLock.lock(); try { long xid = xidCounter + 1; updateXID(xid, FIELD_TRAN_ACTIVE); incrXIDCounter(); return xid; } finally { counterLock.unlock(); } }\"]},\"246\":{\"h\":\"更新事务状态（updateXID）\",\"t\":[\"更新事务 ID 的状态，可以通过 updateXID() 方法来实现，而 commit() 和 abort() 方法则可以直接调用 updateXID()方法来完成任务的提交或回滚操作。这就像是你在任务清单中更新任务的状态：当一个任务完成时（类似于 commit()），你会将其标记为“已完成”；而当任务被取消时（类似于 abort()），你会将其标记为“已取消”。无论是完成还是取消，都可以通过同一个操作（即 updateXID()）来更新任务的状态，确保任务的最终状态被准确记录。\",\"// 更新xid事务的状态为status private void updateXID(long xid, byte status) { // 获取事务xid在xid文件中对应的位置 long offset = getXidPosition(xid); // 创建一个长度为XID_FIELD_SIZE的字节数组 byte[] tmp = new byte[XID_FIELD_SIZE]; // 将事务状态设置为status tmp[0] = status; // 使用字节数组创建一个ByteBuffer ByteBuffer buf = ByteBuffer.wrap(tmp); try { // 将文件通道的位置设置为offset fc.position(offset); // 将ByteBuffer中的数据写入到文件通道 fc.write(buf); } catch (IOException e) { // 如果出现异常，调用Panic.panic方法处理 Panic.panic(e); } try { // 强制将文件通道中的所有未写入的数据写入到磁盘 fc.force(false); } catch (IOException e) { // 如果出现异常，调用Panic.panic方法处理 Panic.panic(e); } }\"]},\"247\":{\"h\":\"增加事务计数（incrXIDCounter）\",\"t\":[\"// 将XID加一，并更新XID Header private void incrXIDCounter() { // 事务总数加一 xidCounter++; // 将新的事务总数转换为字节数组，并用ByteBuffer包装 ByteBuffer buf = ByteBuffer.wrap(Parser.long2Byte(xidCounter)); try { // 将文件通道的位置设置为0，即文件的开始位置 fc.position(0); // 将ByteBuffer中的数据写入到文件通道，即更新了XID文件的头部信息 fc.write(buf); } catch (IOException e) { // 如果出现异常，调用Panic.panic方法处理 Panic.panic(e); } try { // 强制将文件通道中的所有未写入的数据写入到磁盘 fc.force(false); } catch (IOException e) { // 如果出现异常，调用Panic.panic方法处理 Panic.panic(e); } }\"]},\"248\":{\"h\":\"事务状态检查与关闭\"},\"249\":{\"h\":\"检查事务状态（checkXID）\",\"t\":[\"isActive()、isCommitted()和 isAborted() 都是检查一个 xid 的状态\",\"// 定义一个方法，接收一个事务ID（xid）和一个状态（status）作为参数 private boolean checkXID(long xid, byte status) { // 计算事务ID在XID文件中的位置 long offset = getXidPosition(xid); // 创建一个新的字节缓冲区（ByteBuffer），长度为XID_FIELD_SIZE ByteBuffer buf = ByteBuffer.wrap(new byte[XID_FIELD_SIZE]); try { // 将文件通道的位置设置为offset fc.position(offset); // 从文件通道读取数据到字节缓冲区 fc.read(buf); } catch (IOException e) { // 如果出现异常，调用Panic.panic方法处理 Panic.panic(e); } // 检查字节缓冲区的第一个字节是否等于给定的状态 // 如果等于，返回true，否则返回false return buf.array()[0] == status; }\"]},\"250\":{\"h\":\"关闭事务管理器\",\"t\":[\"public void close() { try { fc.close(); file.close(); } catch (IOException e) { Panic.panic(e); } }\"]},\"251\":{\"h\":\"4. 总结\",\"t\":[\"TM 模块的主要功能是 管理事务，包括事务的开始、提交、回滚以及状态检查。为实现这些功能，模块中定义了一系列关键常量，如 LEN_XID_HEADER_LENGTH、XID_FIELD_SIZE、FIELD_TRAN_ACTIVE、FIELD_TRAN_COMMITTED、FIELD_TRAN_ABORTED、SUPER_XID 和 XID_SUFFIX，分别表示 XID 文件头长度、每个事务的占用长度、事务的三种状态、超级事务标识以及 XID 文件的后缀。 在实现上，TM 模块通过 RandomAccessFile 类型的 file 和 FileChannel 类型的 fc 操作 XID 文件，并使用 xidCounter 来记录事务的数量，同时通过 Lock 类确保线程安全。构造函数中，首先对 file 和 fc 进行初始化，并调用 checkXIDCounter 方法校验 XID 文件的合法性，确保文件的正确性。 在事务管理方面，begin() 方法用于开始一个新事务，通过调用 updateXID() 方法将事务 ID 和状态写入 XID 文件，并通过 incrXIDCounter() 方法更新 XID 计数器。commit() 和 abort() 方法分别用于提交和回滚事务，依赖 updateXID() 方法来更新事务状态。isActive()、isCommitted() 和 isAborted() 方法用于检查事务状态，通过 checkXID() 方法确认事务的当前状态。close() 方法则负责关闭文件通道和文件，确保资源的正确释放。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb1版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"252\":{\"c\":[\"事务\"]},\"253\":{\"c\":[\"事务\"]},\"254\":{\"h\":\"死锁及超时检测\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/vm/LockTable.java\"]},\"255\":{\"h\":\"案例背景\",\"t\":[\"在学习如何使用 LockTable 进行锁管理、死锁检测与解决之前，先了解一下死锁是如何发生的。假设我们有三个事务 T1、T2 和 T3，它们分别要访问两个资源 R1 和 R2。事务的执行顺序如下：\",\"T1 锁定 R1：然后尝试锁定 R2。\",\"T2 锁定 R2：然后尝试锁定 R1。\",\"T3 尝试锁定 R1。\",\"这种情况下，T1 和 T2 之间会产生死锁，而 T3 将会被阻塞在等待 R1 上。\"]},\"256\":{\"h\":\"执行过程\",\"t\":[\"T1 锁定 R1： \",\"T1 请求锁定资源 R1。\",\"因为 R1 未被占用，所以 LockTable 将 R1 锁定给 T1。\",\"T1 继续执行，准备请求锁定 R2。\",\"T2 锁定 R2： \",\"T2 请求锁定资源 R2。\",\"因为 R2 未被占用，所以 LockTable 将 R2 锁定给 T2。\",\"T2 继续执行，准备请求锁定 R1。\",\"T1 请求锁定 R2： \",\"T1 请求锁定 R2。\",\"由于 R2 已被 T2 锁定，T1 被加入到 R2 的等待队列中。\",\"T2 请求锁定 R1： \",\"T2 请求锁定 R1。\",\"由于 R1 已被 T1 锁定，T2 被加入到 R1 的等待队列中。\",\"现在形成了 T1 → R2 → T2 → R1 → T1 的循环等待，导致死锁。\",\"T3 尝试锁定 R1： \",\"T3 请求锁定 R1。\",\"由于 R1 已被 T1 锁定且 T2 在等待 R1，T3 被加入到 R1 的等待队列中。\"]},\"257\":{\"h\":\"LockTable 详解与实现教程\",\"t\":[\"在多事务并发的数据库系统中，锁管理是至关重要的一部分。本文将详细介绍如何通过 LockTable 类实现锁管理、死锁检测与解决，以及如何通过路径缓存优化死锁检测。\"]},\"258\":{\"h\":\"LockTable 类的概述\",\"t\":[\"LockTable 是一个用于管理事务锁的类，旨在解决多事务并发操作时的资源竞争问题。它通过维护一系列数据结构来管理事务对资源的请求、检测死锁、处理超时等待，并在必要时回滚事务。\"]},\"259\":{\"h\":\"数据结构与字段介绍\",\"t\":[\"LockTable 主要使用了以下数据结构：\",\"x2u：Map<Long, List<Long>>，存储每个事务已获得的资源列表（即每个事务当前持有的资源）。\",\"u2x：Map<Long, Long>，存储每个资源被哪个事务持有。\",\"wait：Map<Long, List<Long>>，存储等待某个资源的事务队列。\",\"waitLock：Map<Long, Lock>，存储正在等待资源的事务的锁。\",\"waitU：Map<Long, Long>，存储每个事务正在等待的资源ID。\",\"lock：Lock，全局锁，用于保证 LockTable 的线程安全。\",\"waitStartTime：Map<Long, Long>，记录每个事务进入等待状态的时间。\",\"xidStamp：Map<Long, Integer>，用于死锁检测中的标记\",\"pathCache：Map<Long, Boolean>，路径缓存，用于优化死锁检测时的DFS。\"]},\"260\":{\"h\":\"锁请求与等待管理\",\"t\":[\"当一个事务请求获取某个资源时，LockTable 首先会检查该资源是否已被其他事务持有。如果没有被持有，资源将直接分配给请求的事务。如果资源已被占用，事务将进入等待状态，并存储在相应的等待队列中。\",\"public Lock add(long xid, long uid) throws Exception { lock.lock(); try { if (isInList(x2u, xid, uid)) { return null; // 已拥有资源 } if (!u2x.containsKey(uid)) { // 资源未被占用 u2x.put(uid, xid); putIntoList(x2u, xid, uid); return null; } waitU.put(xid, uid); // 资源被占用，进入等待 putIntoList(wait, uid, xid); waitStartTime.put(xid, System.currentTimeMillis()); // 死锁检测 if (hasDeadLock()) { waitU.remove(xid); removeFromList(wait, uid, xid); throw Error.DeadlockException; } Lock l = new ReentrantLock(); l.lock(); waitLock.put(xid, l); return l; } finally { lock.unlock(); } }\"]},\"261\":{\"h\":\"死锁检测与路径缓存优化\",\"t\":[\"为了避免死锁，LockTable 实现了基于深度优先搜索（DFS）的死锁检测机制。通过遍历事务依赖图，系统可以检测到是否存在循环依赖，从而识别死锁。\"]},\"262\":{\"h\":\"死锁检测实现\",\"t\":[\"private boolean hasDeadLock() { xidStamp = new HashMap<>(); pathCache = new HashMap<>(); stamp = 1; for (long xid : x2u.keySet()) { if (xidStamp.getOrDefault(xid, 0) > 0) continue; stamp++; if (dfs(xid)) return true; } return false; } private boolean dfs(long xid) { // 如果路径缓存中已经有结果，直接返回缓存的值 if (pathCache.containsKey(xid)) { return pathCache.get(xid); } Integer stp = xidStamp.get(xid); if (stp != null && stp == stamp) { pathCache.put(xid, true); // 更新路径缓存 return true; } if (stp != null && stp < stamp) { pathCache.put(xid, false); // 更新路径缓存 return false; } xidStamp.put(xid, stamp); Long uid = waitU.get(xid); if (uid == null) { pathCache.put(xid, false); // 更新路径缓存 return false; } Long x = u2x.get(uid); boolean hasCycle = x != null && dfs(x); pathCache.put(xid, hasCycle); // 更新路径缓存 return hasCycle; }\"]},\"263\":{\"h\":\"路径缓存优化\",\"t\":[\"在死锁检测过程中，DFS 可能会反复检查相同的事务路径。通过引入 pathCache 路径缓存，可以显著减少重复计算的开销，从而提高死锁检测的效率。\",\"路径缓存：记录每个事务的检测结果。如果在 DFS 中已经检测到某个事务的路径不形成死锁，则下次再遇到该路径时直接返回缓存结果，而无需重新计算。\"]},\"264\":{\"h\":\"超时检测与事务回滚\",\"t\":[\"在某些情况下，事务可能会由于等待时间过长而被回滚。LockTable 通过后台线程定期检查每个事务的等待时间，并在超时时执行回滚操作。 超时检测与回滚机制的基本思想是：\",\"每个事务在获取资源时，如果资源被其他事务占用，则需要等待。\",\"为了避免长时间等待导致系统资源被锁住，我们为每个等待的事务设置一个超时时间（30S）。\",\"当检测到事务等待超时后，系统将回滚这个事务，并释放它占用的所有资源，从而避免死锁或资源饥饿。\"]},\"265\":{\"h\":\"超时检测线程\",\"t\":[\"启动一个后台线程，定期检查每个事务的等待时间。如果超时，则执行回滚操作。\",\"private void startTimeoutDeadlockChecker() { new Thread(() -> { while (true) { try { Thread.sleep(CHECK_INTERVAL_MS); // 每秒检测一次 checkForTimeouts(TIMEOUT_THRESHOLD_MS); // TIMEOUT_THRESHOLD_MS设置时间为30s } catch (InterruptedException e) { throw new RuntimeException(e); } } }).start(); }\"]},\"266\":{\"h\":\"检查超时并回滚\",\"t\":[\"checkForTimeouts 方法负责检查是否有事务等待超时，并触发回滚。\",\"public void checkForTimeouts(long timeout) { lock.lock(); try { long currentTime = System.currentTimeMillis(); Iterator<Map.Entry<Long, Long>> iterator = waitStartTime.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<Long, Long> entry = iterator.next(); long xid = entry.getKey(); long startTime = entry.getValue(); if (currentTime - startTime >= timeout) { // 超时，执行回滚操作 rollbackTimeoutTransaction(xid); iterator.remove(); // 从等待时间记录中移除 } } } finally { lock.unlock(); } }\"]},\"267\":{\"h\":\"回滚事务\",\"t\":[\"回滚事务意味着：\",\"释放该事务占用的资源。\",\"将该事务从等待队列和锁表中移除。\",\"通知其他等待的事务资源已经可用。\",\"private void rollbackTimeoutTransaction(long xid) { System.out.println(\\\"Transaction \\\" + xid + \\\" has timed out and will be rolled back.\\\"); // 解除事务等待的资源 Long uid = waitU.remove(xid); if (uid != null) { removeFromList(wait, uid, xid); } // 释放所有已占用资源 List<Long> resources = x2u.remove(xid); if (resources != null) { for (Long resource : resources) { selectNewXID(resource); } } // 通知等待该事务的其他线程 Lock l = waitLock.remove(xid); if (l != null && ((ReentrantLock) l).isHeldByCurrentThread()) { l.unlock(); } }\"]},\"268\":{\"h\":\"资源释放与重分配\",\"t\":[\"当一个事务 commit 或者 abort 时，LockTable 会释放该事务持有的所有资源锁，并重新分配给等待队列中的其他事务。\",\"public void remove(long xid) { lock.lock(); try { List<Long> l = x2u.get(xid); if (l != null) { while (l.size() > 0) { Long uid = l.remove(0); selectNewXID(uid); // 重新分配资源 } } waitU.remove(xid); x2u.remove(xid); waitLock.remove(xid); } finally { lock.unlock(); } } // 从等待队列中选择一个xid来占用uid private void selectNewXID(long uid) { u2x.remove(uid); List<Long> l = wait.get(uid); if (l == null) return; assert l.size() > 0; while (l.size() > 0) { long xid = l.remove(0); if (!waitLock.containsKey(xid)) { continue; } else { u2x.put(uid, xid); Lock lo = waitLock.remove(xid); waitU.remove(xid); lo.unlock(); // 解锁等待事务 break; } } if (l.size() == 0) wait.remove(uid); }\"]},\"269\":{\"h\":\"综合运作流程\",\"t\":[\"事务请求资源：当事务请求资源时，LockTable 会检查资源是否被其他事务占用，并决定是否将资源分配给请求事务或将其放入等待队列。\",\"死锁检测：每当一个事务进入等待状态，LockTable 会执行死锁检测，通过 DFS 判断是否存在循环依赖。\",\"超时回滚：后台线程定期检查事务的等待时间，并在超时后自动回滚事务。\",\"资源释放：在事务完成时，LockTable 会释放该事务持有的资源，并将资源分配给其他等待的事务。\",\"通过这一系列操作，LockTable 有效地管理了资源的并发访问，防止了死锁的发生，并确保系统的高效运行。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb7版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"270\":{\"c\":[\"VM\"]},\"271\":{\"c\":[\"deadlock\",\"time out\"]},\"272\":{\"h\":\"版本管理\",\"t\":[\"在本节中，我们将深入探讨 EasyDB 中的 Version Manager (VM) 模块，这一模块是数据库系统的关键组成部分之一，负责管理数据库的事务和数据版本。VM 模块的设计确保了数据库的并发控制和数据一致性，同时通过 MVCC（多版本并发控制）实现了不同事务之间的隔离。以下是 VM 模块的几个关键功能：\"]},\"273\":{\"h\":\"两段锁协议（2PL）与并发控制\",\"t\":[\"在 EasyDB 中，VM 模块通过两段锁协议（2PL）实现了事务的并发控制。2PL 保证了调度序列的可串行化，即事务的执行顺序可以调整为一个等效的串行执行顺序，从而确保数据的一致性。 2PL 的工作原理是，在事务执行期间，所有对数据的读写操作都必须先获取相应的锁，而这些锁只有在事务提交或回滚后才会释放。通过这种方式，VM 模块能够避免不同事务之间的冲突操作，从而保证数据库的正确性。 然而，2PL 也可能导致事务之间的相互阻塞，甚至引发死锁。为了减少这种阻塞，VM 模块进一步实现了 MVCC 机制。\"]},\"274\":{\"h\":\"多版本并发控制（MVCC）\",\"t\":[\"MVCC 是 VM 模块中的一项关键技术，它通过维护每个数据项的多个版本，来降低事务之间的阻塞概率。具体来说，VM 为每个数据记录维护了多个版本，当某个事务对数据进行修改时，系统会为该数据生成一个新的版本，而不是直接覆盖原有的数据。 在 MVCC 的帮助下，当一个事务 T1 在对某个数据项 X 进行更新时，另一个事务 T2 可以读取 X 的旧版本，而不必等待 T1 完成操作。这种机制极大地提高了数据库的并发性能，同时确保了事务的隔离性和数据的一致性。\"]},\"275\":{\"h\":\"记录的多版本存储与管理\",\"t\":[\"在 VM 模块中，每条数据记录（Entry）被设计为可以拥有多个版本。VM 通过管理这些版本，提供了数据的多版本存储与管理功能。每当一个事务对记录进行修改时，系统会生成该记录的一个新版本，并将其与旧版本一起存储。 每个版本记录了两个重要的元数据：创建该版本的事务编号（XMIN）和删除该版本的事务编号（XMAX）。XMIN 标识了该版本的创建事务，而 XMAX 则用于标识删除该版本的事务。通过这些元数据，VM 能够有效地管理和查询不同事务创建的数据版本，并实现事务的隔离级别。\"]},\"276\":{\"h\":\"事务的隔离级别\",\"t\":[\"VM 模块支持四种事务隔离级别：读未提交、读提交、可重复读和串行化。读未提交允许读取未提交的数据，可能导致“脏读”；读提交仅允许读取已提交的数据，避免了“脏读”但可能出现“不可重复读”；可重复读确保事务期间多次读取数据结果一致，解决了“不可重复读”问题，但可能出现“幻读”；串行化提供最高的隔离性，完全避免了并发问题，但性能开销较大。通过这些隔离级别，VM 模块在数据一致性和系统性能之间取得了平衡。\"]},\"277\":{\"h\":\"版本跳跃问题与解决方案\",\"t\":[\"版本跳跃问题是指当一个事务在修改数据时跳过了其他事务的中间版本，导致数据版本不连续。这种情况通常在可重复读隔离级别下是不被允许的，因为它可能会破坏事务的逻辑一致性。 为了解决这一问题，VM 模块在修改数据之前，会检查最新版本的创建者对当前事务是否可见。如果不可见，意味着存在版本跳跃问题，系统将回滚当前事务，以确保数据的一致性。\"]},\"278\":{\"h\":\"死锁检测与处理\",\"t\":[\"在实现两段锁协议的同时，VM 模块还需要解决可能发生的死锁问题。死锁是指两个或多个事务互相等待对方持有的资源，导致事务永远无法完成。 为了防止死锁，VM 模块在每次出现资源等待时，会动态构建一个等待图，并通过深度优先搜索（DFS）算法检测图中是否存在环。如果检测到环，系统会立即中断其中一个事务，从而打破死锁，恢复系统的正常运行。\"]},\"279\":{\"h\":\"VM 的实现与接口设计\",\"t\":[\"VM 模块通过 VersionManager 接口向上层提供功能支持，主要包括读、写、删除和事务管理等操作。VM 模块内部通过一个事务管理器来管理事务的生命周期，并通过一个锁表（LockTable）来管理并发控制和死锁检测。 VM 模块还继承了 AbstractCache 类，负责管理数据记录（Entry）的缓存。通过缓存机制，VM 能够有效减少频繁的数据加载操作，提高系统的整体性能。\"]},\"280\":{\"h\":\"总结\",\"t\":[\"VM 模块作为 EasyDB 中的重要组件之一，通过两段锁协议、MVCC、多版本管理和死锁检测等机制，确保了数据库系统的并发控制和数据一致性。在这一节中，我们将深入探讨 VM 模块的各项功能，并通过具体的代码示例展示其实现细节，帮助读者理解 EasyDB 中事务和版本管理的复杂性及其解决方案。\"]},\"281\":{\"c\":[\"VM\"]},\"282\":{\"h\":\"事务的隔离级别\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/vm/Visibility、IsolationLevel、Transaction.java\"]},\"283\":{\"h\":\"事务隔离级别实现\",\"t\":[\"在数据库系统中，不同的事务隔离级别提供了不同的并发控制和数据一致性保障。EasyDB 实现了四种常见的事务隔离级别：读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。每种隔离级别都有其特定的可见性规则和应用场景。\"]},\"284\":{\"h\":\"读未提交\",\"t\":[\"读未提交（Read Uncommitted）是最低级别的事务隔离级别。在这种隔离级别下，事务可以读取其他事务未提交的数据。这意味着可能会读取到未提交的数据变化，这种情况被称为“脏读”。在 EasyDB 中，读未提交级别实现最为简单，所有数据版本对事务都是可见的，包括那些尚未提交的数据版本，也对数据进行了一个简单的过滤，已删除的数据时不可见的\",\"private static boolean readUnCommitted(TransactionManager tm, Transaction t, Entry e) { long xmax = e.getXmax(); // 检查数据是否被删除，如果未删除则可见 return xmax == 0; }\"]},\"285\":{\"h\":\"读提交\",\"t\":[\"读提交（Read Committed）是一种较为常用的事务隔离级别，保证事务只能读取已经提交的数据版本。它可以避免读取未提交的数据，从而防止脏读。在 EasyDB 中，读提交通过维护两个关键字段来实现：XMIN和XMAX。其中，XMIN记录了创建版本的事务编号，XMAX记录了删除版本的事务编号。\"]},\"286\":{\"h\":\"读提交的事务可见性逻辑\",\"t\":[\"XMIN == Ti and XMAX == NULL： \",\"这个条件表示，当前版本的数据是由当前事务 Ti 创建的，并且尚未被删除。因此，这个版本对当前事务 Ti 是可见的。\",\"XMIN is committed and (XMAX == NULL or (XMAX != Ti and XMAX is not committed))： \",\"XMIN is committed 表示，版本是由一个已提交的事务创建的，因此对其他事务是可见的。\",\"XMAX == NULL 表示该版本尚未被删除，因此仍然是可见的。\",\"(XMAX != Ti and XMAX is not committed) 这一部分是说，如果这个版本被其他事务删除了，但该删除操作尚未提交，这意味着删除操作对当前事务不可见，所以当前版本仍然是可见的\",\"(XMIN == Ti and // 由Ti创建且 XMAX == NULL // 还未被删除 ) or // 或 (XMIN is commited and // 由一个已提交的事务创建且 (XMAX == NULL or // 尚未删除或 (XMAX != Ti and XMAX is not commited) // 由一个未提交的事务删除 ))\",\"private static boolean readCommitted(TransactionManager tm, Transaction t, Entry e) { long xid = t.xid; long xmin = e.getXmin(); long xmax = e.getXmax(); // 当前事务创建且未删除的数据版本是可见的 if (xmin == xid && xmax == 0) return true; // 由已提交事务创建的版本是可见的 if (tm.isCommitted(xmin)) { // 如果记录未被删除，或删除版本未提交，则该版本可见 if (xmax == 0 || (xmax != xid && !tm.isCommitted(xmax))) { return true; } } return false; }\"]},\"287\":{\"h\":\"可重复读\",\"t\":[\"可重复读（Repeatable Read）解决了读提交级别下的不可重复读问题。在该级别下，事务在其生命周期内多次读取同一数据项时，读取到的结果是一致的，即使其他事务并发地修改了数据。EasyDB 通过事务的快照机制实现这一点，确保事务只能读取到事务开始时已经提交的数据版本。\"]},\"288\":{\"h\":\"可重复读的事务可见性逻辑\",\"t\":[\"XMIN == Ti and XMAX == NULL： \",\"这个条件表示，当前版本的数据是由当前事务 Ti 创建的，并且尚未被删除。因此，这个版本对当前事务 Ti 是可见的。\",\"XMIN is committed and XMIN < Ti and XMIN is not in SP(Ti)： \",\"XMIN is committed 表示该版本是由一个已提交的事务创建的。\",\"XMIN < Ti 表示该版本是在当前事务 Ti 开始之前创建的。\",\"XMIN is not in SP(Ti) 表示该版本的创建事务不在当前事务 Ti 开始时的活跃事务集合中，因此该版本对当前事务是可见的。\",\"XMAX == NULL or (XMAX != Ti and (XMAX is not committed or XMAX > Ti or XMAX is in SP(Ti)))： \",\"XMAX == NULL 表示该版本尚未被删除。\",\"XMAX != Ti 表示删除该版本的事务不是当前事务 Ti。\",\"XMAX is not committed 表示删除操作尚未提交。\",\"XMAX > Ti 表示删除操作发生在当前事务 Ti 之后。\",\"XMAX is in SP(Ti) 表示删除操作发生在当前事务 Ti 开始之前但未提交。\",\"// 可重复读隔离级别下的事务可见性逻辑 (XMIN == Ti and // 由当前事务 Ti 创建且 (XMAX == NULL)) // 尚未被删除 or // 或 (XMIN is committed and // 由一个已提交的事务创建且 XMIN < Ti and // 该事务在当前事务 Ti 之前提交 XMIN is not in SP(Ti) and // 该事务不在当前事务 Ti 的快照中 (XMAX == NULL or // 尚未删除或 (XMAX != Ti and // 删除操作由其他事务执行但不是当前事务 Ti (XMAX is not committed or // 删除操作尚未提交或 XMAX > Ti or // 删除操作在当前事务 Ti 之后执行或 XMAX is in SP(Ti))))) // 删除操作在当前事务 Ti 开始时未提交\",\"private static boolean repeatableRead(TransactionManager tm, Transaction t, Entry e) { long xid = t.xid; long xmin = e.getXmin(); long xmax = e.getXmax(); // 当前事务创建且未删除的数据版本是可见的 if (xmin == xid && xmax == 0) return true; // 已提交事务创建的版本，且不在当前事务快照中的版本是可见的 if (tm.isCommitted(xmin) && xmin < xid && !t.isInSnapshot(xmin)) { // 如果记录未被删除，或删除版本未提交或不在快照中，则该版本可见 if (xmax == 0 || (xmax != xid && (!tm.isCommitted(xmax) || xmax > xid || t.isInSnapshot(xmax)))) { return true; } } return false; }\"]},\"289\":{\"h\":\"串行化\",\"t\":[\"串行化（Serializable）是最高级别的事务隔离，确保事务像是按顺序一个接一个执行的，从而避免了所有的并发问题。在这个级别下，事务之间不会相互影响，彻底解决了脏读、不可重复读和幻读问题。 在 EasyDB 中，串行化通过强制事务之间的完全隔离来实现。在串行化隔离级别下，每个事务只能看到它开始之前已经提交的版本，以及它自己创建或修改的版本。此逻辑与可重复读的一致性逻辑相似。\",\"private static boolean serializable(TransactionManager tm, Transaction t, Entry e) { long xid = t.xid; long xmin = e.getXmin(); long xmax = e.getXmax(); // 当前事务创建且尚未删除的版本是可见的 if (xmin == xid && xmax == 0) return true; // 已提交事务创建且在当前事务之前提交的版本是可见的 if (tm.isCommitted(xmin) && xmin < xid && !t.isInSnapshot(xmin)) { // 如果记录未被删除，或删除版本未提交或不在快照中，则该版本可见 if (xmax == 0 || (xmax != xid && (!tm.isCommitted(xmax) || xmax > xid || t.isInSnapshot(xmax)))) { return true; } } return false; }\"]},\"290\":{\"h\":\"事务结构\",\"t\":[\"由于可重复读和串行化隔离级别的特殊要求，EasyDB 为事务提供了一个结构，用来保存事务开始时的快照数据。\",\"public class Transaction { public long xid; // 事务的ID public int level; // 事务的隔离级别 public Map<Long, Boolean> snapshot; // 事务的快照，用于存储活跃事务的ID public Exception err; // 事务执行过程中的错误 public boolean autoAborted; // 标志事务是否自动中止 public long startTime; // 添加开始时间属性 public static Transaction newTransaction(long xid, IsolationLevel isolationLevel, Map<Long, Transaction> active) { Transaction t = new Transaction(); t.xid = xid; t.isolationLevel = isolationLevel; t.startTime = System.currentTimeMillis(); // 当隔离级别等于可重复读和串行化时需要创建快照 if(isolationLevel != IsolationLevel.READ_COMMITTED && isolationLevel != IsolationLevel.READ_UNCOMMITTED) { t.snapshot = new HashMap<>(); for(Long x : active.keySet()) { t.snapshot.put(x, true); } } return t; } public boolean isInSnapshot(long xid) { if(xid == TransactionManagerImpl.SUPER_XID) { return false; } return snapshot.containsKey(xid); } }\"]},\"291\":{\"h\":\"版本跳跃问题\",\"t\":[\"版本跳跃问题是指在多版本并发控制（MVCC）中，一个事务在修改数据项时可能会跳过中间版本，直接修改最新版本，这可能导致逻辑上的错误。具体来说，版本跳跃会在以下情况下发生：\",\"一个事务（Ti）试图修改数据项X，而在Ti开始之前，另一个事务（Tj）已经对X进行了修改，但由于隔离级别的原因，Ti看不到Tj的修改，这种情况下Ti直接修改X，可能会导致数据不一致。\",\"如果Ti在试图修改数据项X时，Tj的修改对Ti不可见，这意味着Ti并不真正了解X的最新状态。如果允许Ti继续修改X，可能会跳过Tj的修改，从而导致逻辑错误。\",\"版本跳跃问题与事务的隔离级别密切相关。在读未提交隔离级别下，版本跳跃是被允许的，因为该隔离级别不保证数据的可见性和一致性。然而，在读提交及以上的隔离级别，版本跳跃是不被允许的，系统必须进行检查并在必要时强制事务回滚。\"]},\"292\":{\"h\":\"版本跳跃的检查\",\"t\":[\"为了避免版本跳跃，系统需要在Ti修改X之前检查是否存在版本跳跃的风险。具体来说：\",\"如果Tj的事务ID（XID）大于Ti的事务ID，这意味着Tj在时间上晚于Ti开始，因此Ti应该回滚，避免版本跳跃。\",\"如果Tj在Ti的快照集合（SP(Ti)）中，则Tj在Ti开始之前已经提交，但Ti在开始之前并不能看到Tj的修改，因此Ti也应该回滚。\",\"代码示例：\",\"public static boolean isVersionSkip(TransactionManager tm, Transaction t, Entry e) { long xmax = e.getXmax(); // 读未提交隔离级别下不考虑版本跳跃问题 if (t.level == IsolationLevel.READ_UNCOMMITTED) { return false; } // 读提交及以上隔离级别需要检查版本跳跃 else if (t.level == IsolationLevel.READ_COMMITTED || t.level == IsolationLevel.REPEATABLE_READ || t.level == IsolationLevel.SERIALIZABLE) { return tm.isCommitted(xmax) && (xmax > t.xid || t.isInSnapshot(xmax)); } else { throw new IllegalArgumentException(\\\"Unknown isolation level: \\\" + t.isolationLevel); } }\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb6版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"293\":{\"c\":[\"VM\"]},\"294\":{\"c\":[\"transaction\",\"isolation\"]},\"295\":{\"h\":\"记录的版本\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/vm/Entry.java\",\"从这里开始，我们将深入探讨 Version Manager (VM) 的实现。VM 是 EasyDB 的事务和数据版本管理核心，类似于 Data Manager 是 EasyDB 的数据管理核心。VM 基于两段锁协议（2PL）实现了调度序列的可串行化，并通过多版本并发控制（MVCC）消除读写阻塞，同时支持多种事务隔离级别。\"]},\"296\":{\"h\":\"2PL 与 MVCC\"},\"297\":{\"h\":\"冲突与 2PL\",\"t\":[\"在数据库中，多个事务可能会同时操作同一个数据项，这就可能导致冲突。我们暂时不讨论插入操作，只考虑更新操作（U）和读操作（R）。当以下三个条件同时满足时，两个操作之间就存在冲突：\",\"这两个操作是由不同的事务执行的；\",\"它们针对的是同一个数据项；\",\"其中至少有一个是更新操作。\",\"这种情况下，冲突的顺序会影响最终的结果。举个简单的例子，假设有两个事务 T1 和 T2，它们同时对变量 x 进行操作，初始值为 0：\",\"T1 开始 T2 开始 T1 读取 x（得到 0） T2 读取 x（得到 0） T1 更新 x（加 1，x 变为 1） T2 更新 x（加 1，x 变为 1） T1 提交 T2 提交\",\"在这个场景中，最终 x 的值是 1，而不是我们期望的 2。这个问题的根源在于事务的执行顺序导致了冲突。为了解决这个问题，VM 采用了两段锁协议（Two-Phase Locking, 2PL）。 2PL 的基本思想是，当一个事务想要操作某个数据项时，它必须先获得这个数据项的锁。如果另一个事务已经持有了这个锁，当前事务就必须等待。例如：\",\"场景 1：假设 T1 对数据项 x 加了锁，并尝试更新它。这时，T2 也想读取或更新 x，但由于 x 已被 T1 锁定，T2 必须等待 T1 释放锁后才能继续操作。\",\"这种机制确保了事务的顺序执行，避免了数据不一致的问题。然而，2PL 也会带来一个新的问题：事务阻塞。当多个事务同时争夺同一资源时，它们可能会相互等待，最终可能导致死锁。\"]},\"298\":{\"h\":\"MVCC\",\"t\":[\"为了减少因 2PL 引起的事务阻塞，EasyDB 实现了多版本并发控制（Multi-Version Concurrency Control, MVCC）。在介绍 MVCC 之前，我们先明确两个概念：记录和版本。\",\"记录：在 EasyDB 中，每个记录代表数据的一项，类似于数据库表中的一行数据。\",\"版本：每当一个事务修改某条记录时，VM 会为这条记录创建一个新版本，而旧版本仍然保留，以供其他事务读取。\",\"通过 MVCC，EasyDB 能够降低事务之间的阻塞概率。以下是一个具体的例子：\",\"场景 2：假设 T1 正在更新记录 X，创建了一个新的版本 x3。在 T1 提交之前，T2 也想读取 X。在没有 MVCC 的情况下，T2 会被阻塞，直到 T1 提交。但在 MVCC 的帮助下，T2 可以读取 X 的旧版本 x2，不需要等待 T1 完成。这意味着 T2 的执行结果相当于先于 T1 执行，从而避免了阻塞。\",\"通过这种方式，MVCC 大大提高了系统的并发性能，减少了事务之间的等待时间。但要注意，如果 X 没有旧版本，那么 T2 还是必须等待 T1 释放锁。 为了保证数据的正确性，VM 层在与 DM 层交互时必须遵守以下两条规定：\",\"规定1：正在进行的事务不会读取其他未提交事务产生的数据。（为了增强数据库体验，增加了读未提交隔离级别）\",\"规定2：正在进行的事务不会修改其他未提交事务产生或修改的数据。\",\"2PL 和 MVCC 都自然地满足了这两条规定，确保了数据的一致性和安全性。\"]},\"299\":{\"h\":\"记录的实现\",\"t\":[\"在 EasyDB 中，版本记录是通过 Entry 类来管理的。每条记录会保存其创建和删除的事务信息，这些信息会被存储在 Entry 数据结构中，并通过特定的方式管理和访问。\"]},\"300\":{\"h\":\"Entry 格式数据\",\"t\":[\"Entry 的格式如下：\",\"[XMIN] [XMAX] [DATA]\",\"XMIN：创建该记录的事务编号。\",\"XMAX：删除该记录的事务编号。\",\"DATA：记录的实际数据。\"]},\"301\":{\"h\":\"Entry 结构\",\"t\":[\"在 EasyDB 中，尽管理论上 MVCC 支持多版本控制，但在实际实现中，VM 层只保留每条记录的一个版本，更新操作由后续的表和字段管理（TBM）来处理。每条记录保存在一个 DataItem 中，Entry 结构中包含一个指向 DataItem 的引用。\",\"public class Entry { private static final int OF_XMIN = 0; // XMIN 的偏移量 private static final int OF_XMAX = OF_XMIN + 8; // XMAX 的偏移量 private static final int OF_DATA = OF_XMAX + 8; // DATA 的偏移量 private long uid; // 唯一标识符 private DataItem dataItem; // 记录的数据项 private VersionManager vm; // 版本管理器 // 加载一个 Entry 实例 public static Entry loadEntry(VersionManager vm, long uid) throws Exception { DataItem di = ((VersionManagerImpl)vm).dm.read(uid); return newEntry(vm, di, uid); } // 移除一个 Entry 实例 public void remove() { dataItem.release(); } }\"]},\"302\":{\"h\":\"日志格式操作\"},\"303\":{\"h\":\"\",\"t\":[\"这个方法用于生成日志格式的数据。当创建新版本时，事务 ID 会被作为 XMIN 存储，XMAX 预留为空，数据会附加在其后。\",\"public static byte[] wrapEntryRaw(long xid, byte[] data) { byte[] xmin = Parser.long2Byte(xid); // 将事务 ID 转为 8 字节数组 byte[] xmax = new byte[8]; // 预留 8 字节空间给 XMAX，初始为空 return Bytes.concat(xmin, xmax, data); // 合并为完整的 Entry 数据结构 }\"]},\"304\":{\"h\":\"\",\"t\":[\"这个方法用于返回记录中的实际数据部分。由于 XMIN 和 XMAX 占据了前 16 字节，数据部分会被截取并返回。\",\"public byte[] data() { dataItem.rLock(); // 加锁，确保数据访问的安全性 try { SubArray sa = dataItem.data(); // 获取存储的数据 byte[] data = new byte[sa.end - sa.start - OF_DATA]; // 去除前 16 字节（XMIN 和 XMAX） System.arraycopy(sa.raw, sa.start + OF_DATA, data, 0, data.length); // 复制数据部分 return data; } finally { dataItem.rUnLock(); // 释放锁 } }\"]},\"305\":{\"h\":\"\",\"t\":[\"当记录被删除时，XMAX 会被设置为删除该记录的事务 ID。这是版本控制中的一个关键步骤，用于标记记录的删除状态。\",\"public void setXmax(long xid) { dataItem.before(); // 备份原始数据，以便支持回滚 try { SubArray sa = dataItem.data(); System.arraycopy(Parser.long2Byte(xid), 0, sa.raw, sa.start + OF_XMAX, 8); // 设置 XMAX 为当前事务 ID } finally { dataItem.after(xid); // 记录修改操作的日志 } }\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb6版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"306\":{\"c\":[\"VM\"]},\"307\":{\"c\":[\"version\"]},\"308\":{\"h\":\"VM 的实现\",\"t\":[\"本章涉及代码：com/dyx/simpledb/backend/vm/*\"]},\"309\":{\"h\":\"VM（Version Manager）的基本定义与实现优化\",\"t\":[\"VM（Version Manager）层通过 VersionManager 接口向上层提供了一组用于管理事务和数据操作的基本功能。这个层次主要负责事务的管理，包括事务的开始、提交、回滚，以及数据的插入、读取和删除。 以下是 VersionManager 接口的基本定义：\",\"public interface VersionManager { byte[] read(long xid, long uid) throws Exception; long insert(long xid, byte[] data) throws Exception; boolean delete(long xid, long uid) throws Exception; long begin(int level); void commit(long xid) throws Exception; void abort(long xid); }\",\"VM 的实现类还继承了 AbstractCache<Entry>，以实现对数据条目的缓存管理。以下是缓存管理方法的实现：\",\"@Override protected Entry getForCache(long uid) throws Exception { // 从存储层读取 Entry 数据 Entry entry = Entry.loadEntry(this, uid); if (entry == null) { throw Error.NullEntryException; } return entry; } @Override protected void releaseForCache(Entry entry) { // 从缓存中释放 Entry entry.remove(); }\"]},\"310\":{\"h\":\"具体实现功能的优化\"},\"311\":{\"h\":\"方法\",\"t\":[\"begin() 方法用于启动一个新事务，并初始化事务的相关结构。为了实现串行化隔离级别，需要确保事务的串行执行。在该方法的开始部分，我们引入了一个全局锁（globalLock），以确保在同一时间内只有一个事务可以执行，从而达到串行化隔离的效果。\",\"@Override public long begin(IsolationLevel isolationLevel) { globalLock.lock(); // 获取全局锁 lock.lock(); try { if (isolationLevel != IsolationLevel.SERIALIZABLE) { globalLock.unlock(); // 非串行化需要解除全局锁 } long xid = tm.begin(); Transaction t = Transaction.newTransaction( xid, isolationLevel == null ? IsolationLevel.READ_COMMITTED : isolationLevel, activeTransaction); activeTransaction.put(xid, t); return xid; } finally { lock.unlock(); } }\"]},\"312\":{\"h\":\"方法\",\"t\":[\"commit() 方法用于提交事务并释放事务持有的锁，若事务的隔离级别是串行化，还需释放全局锁。\",\"@Override public void commit(long xid) throws Exception { lock.lock(); Transaction t = activeTransaction.get(xid); lock.unlock(); try { if (t.err != null) { throw t.err; } } catch (NullPointerException n) { System.out.println(xid); System.out.println(activeTransaction.keySet()); Panic.panic(n); } lock.lock(); activeTransaction.remove(xid); lock.unlock(); lt.remove(xid); tm.commit(xid); if (t.isolationLevel == IsolationLevel.SERIALIZABLE && globalLock.tryLock()) { globalLock.unlock(); // 释放全局锁 } }\"]},\"313\":{\"h\":\"方法\",\"t\":[\"abort() 方法用于中止事务，支持手动和自动回滚，若事务的隔离级别是串行化，还需释放全局锁。确保全局锁释放是在末尾，避免产生锁相关的问题。\",\"@Override public void abort(long xid) { internAbort(xid, false); } private void internAbort(long xid, boolean autoAborted) { lock.lock(); Transaction t = activeTransaction.get(xid); if (!autoAborted) { activeTransaction.remove(xid); } lock.unlock(); if (t.autoAborted){ if (t.isolationLevel == IsolationLevel.SERIALIZABLE) globalLock.unlock(); // 释放全局锁 return; } lt.remove(xid); tm.abort(xid); if (t.isolationLevel == IsolationLevel.SERIALIZABLE) globalLock.unlock(); // 释放全局锁 }\"]},\"314\":{\"h\":\"方法\",\"t\":[\"read() 方法用于读取数据，确保数据对当前事务是可见的。\",\"@Override public byte[] read(long xid, long uid) throws Exception { lock.lock(); Transaction t = activeTransaction.get(xid); lock.unlock(); if (t.err != null) { throw t.err; } Entry entry; try { entry = super.get(uid); // 获取数据项 } catch (Exception e) { if (e == Error.NullEntryException) { return null; } else { throw e; } } try { if (Visibility.isVisible(tm, t, entry)) { return entry.data(); // 如果可见，返回数据 } else { return null; } } finally { entry.release(); // 释放数据项 } }\"]},\"315\":{\"h\":\"方法\",\"t\":[\"insert() 方法将数据包装为 Entry 后插入数据存储层。\",\"@Override public long insert(long xid, byte[] data) throws Exception { lock.lock(); Transaction t = activeTransaction.get(xid); lock.unlock(); if (t.err != null) { throw t.err; } byte[] raw = Entry.wrapEntryRaw(xid, data); // 包装数据 return dm.insert(xid, raw); // 插入数据并返回唯一标识符 }\"]},\"316\":{\"h\":\"方法\",\"t\":[\"delete() 方法用于删除数据，同时确保版本的正确性。\",\"@Override public boolean delete(long xid, long uid) throws Exception { // 获取锁，防止并发问题 lock.lock(); // 从活动事务中获取事务对象 Transaction t = activeTransaction.get(xid); // 释放锁 lock.unlock(); // 如果事务已经出错，那么抛出错误 if (t.err != null) { throw t.err; } Entry entry = null; try { // 尝试获取数据项 entry = super.get(uid); } catch (Exception e) { // 如果数据项不存在，那么返回false if (e == Error.NullEntryException) { return false; } else { // 如果出现其他错误，那么抛出错误 throw e; } } try { // 如果数据项对当前事务不可见，那么返回false if (!Visibility.isVisible(tm, t, entry)) { return false; } Lock l = null; try { // 尝试为数据项添加锁 l = lt.add(xid, uid); } catch (Exception e) { // 如果出现并发更新的错误，那么中止事务，并抛出错误 t.err = Error.ConcurrentUpdateException; internAbort(xid, true); t.autoAborted = true; throw t.err; } // 如果成功获取到锁，那么锁定并立即解锁 if (l != null) { l.lock(); l.unlock(); } // 如果数据项已经被当前事务删除，那么返回false if (entry.getXmax() == xid) { return false; } // 如果数据项的版本被跳过，那么中止事务，并抛出错误 if (Visibility.isVersionSkip(tm, t, entry)) { t.err = Error.ConcurrentUpdateException; internAbort(xid, true); t.autoAborted = true; throw t.err; } // 设置数据项的xmax为当前事务的ID，表示数据项被当前事务删除 entry.setXmax(xid); // 返回true，表示删除操作成功 return true; } finally { // 释放数据项 entry.release(); } }\"]},\"317\":{\"h\":\"总结\",\"t\":[\"通过上述优化实现，VM 层的事务管理更加高效且安全。通过锁机制确保了并发事务的正确性，通过可见性判断确保事务读取到的数据是符合隔离级别要求的。自动回滚机制也能够有效应对死锁和版本跳跃问题，保证系统的稳定性和一致性。\",\"注\",\"本文作者：blockCloth部分内容转载自：https://shinya.click/projects/mydb/mydb7版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0许可协议。转载请注明来自 blockCloth\"]},\"318\":{\"c\":[\"VM\"]},\"319\":{\"c\":[\"VM\"]},\"320\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"自动回滚机制也能够有效应对死锁和版本跳跃问题\",{\"1\":{\"317\":1}}],[\"自增字段类型必须为int\",{\"1\":{\"219\":1}}],[\"自增\",{\"1\":{\"219\":1}}],[\"自增性等多种约束条件\",{\"1\":{\"2\":1}}],[\"非串行化需要解除全局锁\",{\"1\":{\"311\":1}}],[\"非空\",{\"1\":{\"219\":1}}],[\"非空性\",{\"1\":{\"2\":1}}],[\"备份原始数据\",{\"1\":{\"305\":1}}],[\"复制数据部分\",{\"1\":{\"304\":1}}],[\"去除前\",{\"1\":{\"304\":1}}],[\"去掉前后的括号\",{\"1\":{\"199\":1}}],[\"占据了前\",{\"1\":{\"304\":1}}],[\"合并为完整的\",{\"1\":{\"303\":1}}],[\"预留\",{\"1\":{\"303\":1}}],[\"预留为空\",{\"1\":{\"303\":1}}],[\"转为\",{\"1\":{\"303\":1}}],[\"转载请注明来自\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"尽管理论上\",{\"1\":{\"301\":1}}],[\"尽管目前不支持删除索引操作\",{\"1\":{\"148\":1}}],[\"规定2\",{\"1\":{\"298\":1}}],[\"规定1\",{\"1\":{\"298\":1}}],[\"规则\",{\"1\":{\"87\":2}}],[\"没有旧版本\",{\"1\":{\"298\":1}}],[\"没有找到合适的页面\",{\"1\":{\"114\":1}}],[\"大大提高了系统的并发性能\",{\"1\":{\"298\":1}}],[\"大于ti的事务id\",{\"1\":{\"292\":1}}],[\"大于等于该节点的最大键值\",{\"1\":{\"145\":1}}],[\"场景\",{\"1\":{\"297\":1,\"298\":1}}],[\"变为\",{\"1\":{\"297\":2}}],[\"得到\",{\"1\":{\"297\":2}}],[\"得到日志的大小\",{\"1\":{\"83\":1}}],[\"初始为空\",{\"1\":{\"303\":1}}],[\"初始值为\",{\"1\":{\"297\":1}}],[\"初始化文件长度为0\",{\"1\":{\"242\":1}}],[\"初始化一个新的可重入锁\",{\"1\":{\"104\":1}}],[\"初始化一个页面对象\",{\"1\":{\"72\":1}}],[\"初始化一个页面信息对象\",{\"1\":{\"72\":1}}],[\"初始化校验和为\",{\"1\":{\"82\":1}}],[\"初始化\",{\"1\":{\"73\":1,\"81\":1,\"198\":1}}],[\"初始化空闲空间大小为0\",{\"1\":{\"72\":1}}],[\"初始化与加载\",{\"1\":{\"44\":1}}],[\"初始化与销毁数据库\",{\"0\":{\"44\":1}}],[\"举个简单的例子\",{\"1\":{\"297\":1}}],[\"举个例子\",{\"1\":{\"219\":1}}],[\"冲突的顺序会影响最终的结果\",{\"1\":{\"297\":1}}],[\"冲突与\",{\"0\":{\"297\":1}}],[\"试图修改数据项x\",{\"1\":{\"291\":1}}],[\"添加开始时间属性\",{\"1\":{\"290\":1}}],[\"添加页面信息\",{\"0\":{\"115\":1}}],[\"彻底解决了脏读\",{\"1\":{\"289\":1}}],[\"且不在当前事务快照中的版本是可见的\",{\"1\":{\"288\":1}}],[\"之前\",{\"1\":{\"298\":1}}],[\"之前提交\",{\"1\":{\"288\":1}}],[\"之后执行或\",{\"1\":{\"288\":1}}],[\"之后\",{\"1\":{\"288\":1}}],[\"之间会产生死锁\",{\"1\":{\"255\":1}}],[\"由当前事务\",{\"1\":{\"288\":1}}],[\"由已提交事务创建的版本是可见的\",{\"1\":{\"286\":1}}],[\"由一个未提交的事务删除\",{\"1\":{\"286\":1}}],[\"由一个已提交的事务创建且\",{\"1\":{\"286\":1,\"288\":1}}],[\"由ti创建且\",{\"1\":{\"286\":1}}],[\"由于可重复读和串行化隔离级别的特殊要求\",{\"1\":{\"290\":1}}],[\"由于头插法的特性\",{\"1\":{\"226\":1}}],[\"由于页面的最大容量为8k\",{\"1\":{\"124\":1}}],[\"由于\",{\"1\":{\"87\":1,\"129\":1,\"146\":1,\"147\":1,\"256\":3,\"304\":1}}],[\"由于对文件的读写是以页为单位进行的\",{\"1\":{\"71\":1}}],[\"由于内存的访问速度远高于磁盘\",{\"1\":{\"51\":1}}],[\"算法检测图中是否存在环\",{\"1\":{\"278\":1}}],[\"意味着存在版本跳跃问题\",{\"1\":{\"277\":1}}],[\"意味着索引数据直接存储在数据库文件中\",{\"1\":{\"166\":1}}],[\"版本记录是通过\",{\"1\":{\"299\":1}}],[\"版本\",{\"1\":{\"298\":1}}],[\"版本跳跃的检查\",{\"0\":{\"292\":1}}],[\"版本跳跃是不被允许的\",{\"1\":{\"291\":1}}],[\"版本跳跃是被允许的\",{\"1\":{\"291\":1}}],[\"版本跳跃会在以下情况下发生\",{\"1\":{\"291\":1}}],[\"版本跳跃问题与事务的隔离级别密切相关\",{\"1\":{\"291\":1}}],[\"版本跳跃问题与解决方案\",{\"0\":{\"277\":1}}],[\"版本跳跃问题是指在多版本并发控制\",{\"1\":{\"291\":1}}],[\"版本跳跃问题是指当一个事务在修改数据时跳过了其他事务的中间版本\",{\"1\":{\"277\":1}}],[\"版本跳跃问题\",{\"0\":{\"291\":1}}],[\"版本是由一个已提交的事务创建的\",{\"1\":{\"286\":1}}],[\"版本管理\",{\"0\":{\"272\":1}}],[\"版本管理器\",{\"1\":{\"226\":1,\"301\":1}}],[\"完全避免了并发问题\",{\"1\":{\"276\":1}}],[\"完成\",{\"1\":{\"298\":1}}],[\"完成操作\",{\"1\":{\"274\":1}}],[\"完成修改\",{\"1\":{\"66\":1}}],[\"幻读\",{\"1\":{\"276\":1}}],[\"问题\",{\"1\":{\"276\":1}}],[\"脏读\",{\"1\":{\"276\":2,\"284\":1}}],[\"脏页面在缓存驱逐时需要被写回到磁盘\",{\"1\":{\"97\":1}}],[\"另一个事务\",{\"1\":{\"274\":1,\"291\":1}}],[\"机制\",{\"1\":{\"273\":1}}],[\"机制来恢复数据\",{\"1\":{\"84\":1}}],[\"甚至引发死锁\",{\"1\":{\"273\":1}}],[\"防止并发问题\",{\"1\":{\"316\":1}}],[\"防止了死锁的发生\",{\"1\":{\"269\":1}}],[\"防止遗漏或混淆\",{\"1\":{\"245\":1}}],[\"综合运作流程\",{\"0\":{\"269\":1}}],[\"超时回滚\",{\"1\":{\"269\":1}}],[\"超时\",{\"1\":{\"266\":1}}],[\"超时检测线程\",{\"0\":{\"265\":1}}],[\"超时检测与回滚机制的基本思想是\",{\"1\":{\"264\":1}}],[\"超时检测与事务回滚\",{\"0\":{\"264\":1}}],[\"超级事务标识以及\",{\"1\":{\"251\":1}}],[\"超级事务\",{\"1\":{\"240\":1}}],[\"进入等待\",{\"1\":{\"260\":1}}],[\"进行操作\",{\"1\":{\"297\":1}}],[\"进行更新时\",{\"1\":{\"274\":1}}],[\"进行锁管理\",{\"1\":{\"255\":1}}],[\"进行初始化\",{\"1\":{\"251\":1}}],[\"进行中\",{\"1\":{\"245\":2}}],[\"进行第二次索引查询\",{\"1\":{\"154\":1}}],[\"进行撤销更新操作\",{\"1\":{\"91\":1}}],[\"进行撤销插入操作\",{\"1\":{\"91\":1}}],[\"进行重做操作\",{\"1\":{\"90\":2}}],[\"进行按位与操作可以提取出偏移量\",{\"1\":{\"69\":1}}],[\"进行按位与运算\",{\"1\":{\"69\":1}}],[\"进行按行读写\",{\"1\":{\"33\":1}}],[\"进行文件的初始化和校验\",{\"1\":{\"68\":1}}],[\"进行解码\",{\"1\":{\"31\":1}}],[\"进行数据传输与处理\",{\"1\":{\"26\":1}}],[\"进行数据库操作之间必须输入init命令进行初始化\",{\"1\":{\"24\":1}}],[\"进行交互\",{\"0\":{\"17\":1,\"184\":1}}],[\"路径缓存优化\",{\"0\":{\"263\":1}}],[\"路径缓存\",{\"1\":{\"259\":1,\"263\":2}}],[\"检测死锁\",{\"1\":{\"258\":1}}],[\"检查数据是否被删除\",{\"1\":{\"284\":1}}],[\"检查超时并回滚\",{\"0\":{\"266\":1}}],[\"检查字节缓冲区的第一个字节是否等于给定的状态\",{\"1\":{\"249\":1}}],[\"检查字段类型有效性\",{\"1\":{\"220\":1}}],[\"检查事务状态\",{\"0\":{\"249\":1}}],[\"检查是否已有同名表存在\",{\"1\":{\"228\":1}}],[\"检查并创建隐藏字段\",{\"1\":{\"222\":1}}],[\"检查并移除bad\",{\"1\":{\"82\":1}}],[\"检查自增字段的类型\",{\"1\":{\"219\":1}}],[\"检查列名与值的数量是否匹配\",{\"1\":{\"199\":1}}],[\"检查记录是否满足单个条件\",{\"1\":{\"159\":1}}],[\"检查单个条件\",{\"0\":{\"159\":1}}],[\"检查当前位置加上日志的大小是否超过了文件的大小\",{\"1\":{\"83\":1}}],[\"检查当前位置是否已经超过了文件的大小\",{\"1\":{\"83\":1}}],[\"详解与实现教程\",{\"0\":{\"257\":1}}],[\"详细讲解事务管理模块是如何在\",{\"1\":{\"231\":1}}],[\"→\",{\"1\":{\"256\":4}}],[\"现在形成了\",{\"1\":{\"256\":1}}],[\"准备请求锁定\",{\"1\":{\"256\":2}}],[\"继续执行\",{\"1\":{\"256\":2}}],[\"继续查找下一个区间\",{\"1\":{\"72\":1,\"114\":1}}],[\"未被占用\",{\"1\":{\"256\":2}}],[\"未被插入到父节点中\",{\"1\":{\"147\":1}}],[\"上\",{\"1\":{\"255\":1}}],[\"上层模块可以通过\",{\"1\":{\"64\":1}}],[\"死锁是指两个或多个事务互相等待对方持有的资源\",{\"1\":{\"278\":1}}],[\"死锁检测实现\",{\"0\":{\"262\":1}}],[\"死锁检测与处理\",{\"0\":{\"278\":1}}],[\"死锁检测与路径缓存优化\",{\"0\":{\"261\":1}}],[\"死锁检测与解决\",{\"1\":{\"257\":1}}],[\"死锁检测与解决之前\",{\"1\":{\"255\":1}}],[\"死锁检测\",{\"1\":{\"260\":1,\"269\":1}}],[\"死锁及超时检测\",{\"0\":{\"254\":1}}],[\"计数器\",{\"1\":{\"251\":1}}],[\"计算事务id在xid文件中的位置\",{\"1\":{\"249\":1}}],[\"计算条件\",{\"0\":{\"161\":1}}],[\"计算空闲空间对应的区间编号\",{\"1\":{\"115\":1}}],[\"计算对应的区间编号\",{\"1\":{\"114\":2}}],[\"计算页码对应的偏移量\",{\"1\":{\"104\":1}}],[\"计算page在文件中的偏移量\",{\"1\":{\"100\":1}}],[\"计算总校验值\",{\"1\":{\"83\":1}}],[\"计算日志数据的校验和\",{\"1\":{\"83\":1}}],[\"计算校验和\",{\"1\":{\"82\":1}}],[\"计算需要的空间大小对应的区间编号\",{\"1\":{\"72\":1}}],[\"计算数据字节大小\",{\"1\":{\"72\":1}}],[\"构造函数中\",{\"1\":{\"251\":1}}],[\"长度为xid\",{\"1\":{\"249\":1}}],[\"想象一下\",{\"1\":{\"245\":1}}],[\"永远为commited状态\",{\"1\":{\"240\":1}}],[\"常量定义\",{\"0\":{\"240\":1}}],[\"常规的日志数据\",{\"1\":{\"79\":1}}],[\"格式数据\",{\"0\":{\"300\":1}}],[\"格式的文件\",{\"1\":{\"237\":1}}],[\"格式如下\",{\"1\":{\"79\":1}}],[\"已经对x进行了修改\",{\"1\":{\"291\":1}}],[\"已删除的数据时不可见的\",{\"1\":{\"284\":1}}],[\"已拥有资源\",{\"1\":{\"260\":1}}],[\"已被\",{\"1\":{\"256\":3,\"297\":1}}],[\"已取消\",{\"1\":{\"246\":1}}],[\"已完成\",{\"1\":{\"246\":1}}],[\"已撤销或回滚\",{\"1\":{\"236\":1}}],[\"已提交事务创建且在当前事务之前提交的版本是可见的\",{\"1\":{\"289\":1}}],[\"已提交事务创建的版本\",{\"1\":{\"288\":1}}],[\"已提交事务的更改也必须被撤销\",{\"1\":{\"87\":1}}],[\"已提交\",{\"1\":{\"87\":1,\"231\":1,\"236\":1}}],[\"尚未被删除\",{\"1\":{\"288\":1}}],[\"尚未删除或\",{\"1\":{\"286\":1,\"288\":1}}],[\"尚未结束\",{\"1\":{\"236\":1}}],[\"尚未提交\",{\"1\":{\"87\":1}}],[\"三种状态\",{\"1\":{\"236\":1}}],[\"哪些被取消\",{\"1\":{\"234\":1}}],[\"哪些已经完成\",{\"1\":{\"234\":1}}],[\"就像是一位任务管理员\",{\"1\":{\"234\":1}}],[\"就像每个任务在清单上都有它的专属编号\",{\"1\":{\"234\":1}}],[\"就是通过一个指定的种子实现的\",{\"1\":{\"80\":1}}],[\"帮助读者理解\",{\"1\":{\"280\":1}}],[\"帮助你实时跟踪和管理每个任务的状态\",{\"1\":{\"233\":1}}],[\"帮助系统快速定位有足够空间的页面\",{\"1\":{\"129\":1}}],[\"顺利执行\",{\"1\":{\"233\":1}}],[\"特性\",{\"1\":{\"231\":1}}],[\"特别适用于那些需要灵活控制数据管理和优化数据库操作的应用场景\",{\"1\":{\"1\":1}}],[\"隔离性和持久性\",{\"1\":{\"231\":1}}],[\"一旦发生无法恢复的错误\",{\"1\":{\"242\":1}}],[\"一致性\",{\"1\":{\"231\":1}}],[\"一个事务\",{\"1\":{\"291\":1}}],[\"一个事务在修改数据项时可能会跳过中间版本\",{\"1\":{\"291\":1}}],[\"一个类型\",{\"1\":{\"217\":1}}],[\"一个\",{\"1\":{\"72\":1}}],[\"解决了读提交级别下的不可重复读问题\",{\"1\":{\"287\":1}}],[\"解决了\",{\"1\":{\"276\":1}}],[\"解锁等待事务\",{\"1\":{\"268\":1}}],[\"解锁以允许其他操作\",{\"1\":{\"228\":1}}],[\"解除事务等待的资源\",{\"1\":{\"267\":1}}],[\"解析\",{\"0\":{\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"解析不同类型的\",{\"0\":{\"197\":1}}],[\"解析和处理不同类型的\",{\"1\":{\"194\":1}}],[\"解析日志记录\",{\"1\":{\"90\":2,\"91\":2}}],[\"解析成一条完整的log日志\",{\"1\":{\"83\":1}}],[\"解析出第一个表的uid\",{\"1\":{\"227\":1}}],[\"解析出一个\",{\"1\":{\"70\":1}}],[\"解析出\",{\"1\":{\"70\":1}}],[\"锁请求与等待管理\",{\"0\":{\"260\":1}}],[\"锁管理是至关重要的一部分\",{\"1\":{\"257\":1}}],[\"锁\",{\"1\":{\"226\":1}}],[\"锁定且\",{\"1\":{\"256\":1}}],[\"锁定给\",{\"1\":{\"256\":2}}],[\"锁定\",{\"1\":{\"255\":2,\"256\":4,\"297\":1}}],[\"锁定文件\",{\"1\":{\"104\":1}}],[\"锁定数据项并保存原始数据\",{\"1\":{\"66\":1}}],[\"隐藏字段的\",{\"1\":{\"222\":1}}],[\"隐藏字段的实现\",{\"0\":{\"222\":1}}],[\"若事务的隔离级别是串行化\",{\"1\":{\"312\":1,\"313\":1}}],[\"若某个字段设置了唯一性约束\",{\"1\":{\"221\":1}}],[\"若缓存中不存在则调用\",{\"1\":{\"72\":1}}],[\"比如是否允许为空\",{\"1\":{\"220\":1}}],[\"比较启动和关闭时的校验字节\",{\"1\":{\"123\":1}}],[\"比较计算得到的校验和和日志中的校验和\",{\"1\":{\"83\":1}}],[\"比较计算得到的校验和和文件中的校验和\",{\"1\":{\"82\":1}}],[\"持久化表对象\",{\"1\":{\"219\":1}}],[\"代码示例\",{\"1\":{\"219\":1,\"220\":1,\"292\":1}}],[\"代码实现\",{\"0\":{\"154\":1}}],[\"否则返回false\",{\"1\":{\"249\":1}}],[\"否则\",{\"1\":{\"217\":1}}],[\"订单id\",{\"1\":{\"217\":1}}],[\"订单表\",{\"1\":{\"216\":1}}],[\"下一个表的唯一标识符\",{\"1\":{\"216\":1}}],[\"下面就来介绍一下\",{\"1\":{\"234\":1}}],[\"下面我们通过一个实际的案例来展示其效果\",{\"1\":{\"135\":1}}],[\"下面是操作步骤\",{\"1\":{\"13\":1,\"180\":1}}],[\"那么锁定并立即解锁\",{\"1\":{\"316\":1}}],[\"那么中止事务\",{\"1\":{\"316\":2}}],[\"那么返回false\",{\"1\":{\"316\":3}}],[\"那么抛出错误\",{\"1\":{\"316\":2}}],[\"那么\",{\"1\":{\"298\":1}}],[\"那么这个标识符指向该索引的根节点\",{\"1\":{\"217\":1}}],[\"那么每个表会链接到下一个表\",{\"1\":{\"216\":1}}],[\"那么当前线程将等待一毫秒然后继续循环\",{\"1\":{\"57\":1}}],[\"具体来说\",{\"1\":{\"274\":1,\"291\":1,\"292\":1}}],[\"具体结构如下\",{\"1\":{\"216\":1}}],[\"具体实现功能的优化\",{\"0\":{\"310\":1}}],[\"具体实现\",{\"0\":{\"152\":1}}],[\"唯一约束\",{\"1\":{\"219\":1}}],[\"唯一性和非空约束\",{\"1\":{\"209\":1,\"214\":1}}],[\"唯一标识符\",{\"1\":{\"65\":1,\"208\":1,\"301\":1}}],[\"除了常见的\",{\"1\":{\"203\":1}}],[\"列定义和索引等信息\",{\"1\":{\"202\":1}}],[\"列名\",{\"1\":{\"200\":1}}],[\"列名和值\",{\"1\":{\"199\":1}}],[\"^\",{\"1\":{\"199\":1}}],[\"条件\",{\"1\":{\"198\":1,\"200\":1,\"201\":1}}],[\"条件为空或查询的字段未建立索引时\",{\"1\":{\"167\":1}}],[\"子句\",{\"1\":{\"198\":1}}],[\"子句和\",{\"1\":{\"198\":1}}],[\"子句仅支持已建立索引的字段\",{\"1\":{\"9\":1,\"176\":1}}],[\"表缓存\",{\"1\":{\"226\":1}}],[\"表管理器\",{\"1\":{\"216\":1}}],[\"表的创建与持久化\",{\"0\":{\"218\":1}}],[\"表的字段列表\",{\"1\":{\"216\":1}}],[\"表的状态\",{\"1\":{\"216\":1}}],[\"表的唯一标识符\",{\"1\":{\"216\":1}}],[\"表的名称\",{\"1\":{\"216\":2}}],[\"表的存储结构\",{\"0\":{\"216\":1}}],[\"表结构和字段是数据存储的核心组成部分\",{\"1\":{\"214\":1}}],[\"表结构管理与字段约束\",{\"0\":{\"209\":1}}],[\"表结构管理以及sql解析等方面\",{\"1\":{\"207\":1}}],[\"表达式\",{\"1\":{\"198\":2}}],[\"表名\",{\"1\":{\"198\":1}}],[\"表示数据项被当前事务删除\",{\"1\":{\"316\":1}}],[\"表示数据正常\",{\"1\":{\"31\":1}}],[\"表示删除操作成功\",{\"1\":{\"316\":1}}],[\"表示删除操作发生在当前事务\",{\"1\":{\"288\":2}}],[\"表示删除操作尚未提交\",{\"1\":{\"288\":1}}],[\"表示删除该版本的事务不是当前事务\",{\"1\":{\"288\":1}}],[\"表示它当前的状态是正在进行\",{\"1\":{\"231\":1}}],[\"表示原始的字节数组\",{\"1\":{\"134\":1}}],[\"表示已经读取到日志文件的末尾\",{\"1\":{\"90\":1,\"91\":1}}],[\"表示事务\",{\"1\":{\"85\":2}}],[\"表示pg的数据已经被修改\",{\"1\":{\"72\":1,\"106\":2}}],[\"表示\",{\"1\":{\"65\":1,\"79\":1,\"286\":1}}],[\"表示该版本的创建事务不在当前事务\",{\"1\":{\"288\":1}}],[\"表示该版本是在当前事务\",{\"1\":{\"288\":1}}],[\"表示该版本是由一个已提交的事务创建的\",{\"1\":{\"288\":1}}],[\"表示该版本尚未被删除\",{\"1\":{\"286\":1,\"288\":1}}],[\"表示该页的空闲位置的偏移量\",{\"1\":{\"124\":1}}],[\"表示该\",{\"1\":{\"65\":1}}],[\"表示发生错误\",{\"1\":{\"31\":1}}],[\"便于在应用程序中进行后续处理\",{\"1\":{\"195\":1}}],[\"便于在获取页面时快速释放页面的缓存操作\",{\"1\":{\"97\":1}}],[\"简称\",{\"1\":{\"231\":1}}],[\"简介\",{\"0\":{\"195\":1}}],[\"简化了启动和配置流程\",{\"1\":{\"2\":1}}],[\"讲解如何使用\",{\"1\":{\"194\":1}}],[\"库\",{\"1\":{\"194\":1,\"195\":1}}],[\"新的启动信息文件不可读写\",{\"1\":{\"191\":1}}],[\"新建的页面需要立刻写回\",{\"1\":{\"101\":1}}],[\"新建页面时\",{\"1\":{\"101\":1}}],[\"新建页面\",{\"0\":{\"101\":1}}],[\"移动文件过程中出现异常\",{\"1\":{\"191\":1}}],[\"移除一个\",{\"1\":{\"301\":1}}],[\"移除\",{\"1\":{\"82\":1}}],[\"刷新输出流\",{\"1\":{\"191\":1}}],[\"临时文件不可读写\",{\"1\":{\"191\":1}}],[\"基本定义\",{\"0\":{\"188\":1,\"226\":1}}],[\"基于两段锁协议\",{\"1\":{\"295\":1}}],[\"基于websocket通信协议\",{\"0\":{\"40\":1}}],[\"基于\",{\"1\":{\"2\":1,\"7\":2,\"174\":2}}],[\"原子性更新\",{\"1\":{\"187\":1}}],[\"原始数据\",{\"1\":{\"65\":1}}],[\"希望能为开发者在实际项目中实现高效的数据管理与查询提供帮助\",{\"1\":{\"167\":1}}],[\"希望通过本文的分享\",{\"1\":{\"161\":1}}],[\"索引的唯一标识符\",{\"1\":{\"217\":1}}],[\"索引的插入与搜索操作\",{\"1\":{\"166\":1}}],[\"索引\",{\"2\":{\"168\":1}}],[\"索引管理器作为\",{\"1\":{\"165\":1}}],[\"索引管理器\",{\"0\":{\"166\":1},\"1\":{\"142\":1,\"165\":1}}],[\"索引管理\",{\"0\":{\"141\":1,\"164\":1}}],[\"旨在解决多事务并发操作时的资源竞争问题\",{\"1\":{\"258\":1}}],[\"旨在通过高效的数据结构来加速数据库的查询操作\",{\"1\":{\"166\":1}}],[\"旨在为开发者提供一个简洁且高效的数据库管理解决方案\",{\"1\":{\"26\":1}}],[\"深入探讨这两个模块的实现细节与应用场景\",{\"1\":{\"165\":1}}],[\"起初使用的是field进行处理的\",{\"1\":{\"160\":1}}],[\"先了解一下死锁是如何发生的\",{\"1\":{\"255\":1}}],[\"先初始化处理singleexp1\",{\"1\":{\"158\":1}}],[\"先创建数据库并打开它\",{\"1\":{\"15\":1,\"182\":1}}],[\"判断是否存在循环依赖\",{\"1\":{\"269\":1}}],[\"判断是否符合条件\",{\"0\":{\"158\":1}}],[\"判断字段的各类约束\",{\"1\":{\"219\":1}}],[\"判断记录是否符合条件\",{\"1\":{\"158\":1}}],[\"判断日志记录的类型\",{\"1\":{\"90\":1,\"91\":2}}],[\"取消一个事务\",{\"1\":{\"238\":1}}],[\"取并集\",{\"1\":{\"154\":3}}],[\"取交集\",{\"1\":{\"154\":3}}],[\"全局锁\",{\"1\":{\"259\":1}}],[\"全表扫描是在查询条件无法通过索引优化时的一种查询策略\",{\"1\":{\"167\":1}}],[\"全表扫描的判断逻辑发生在table\",{\"1\":{\"154\":1}}],[\"全表扫描的实现思路因人而异\",{\"1\":{\"153\":1}}],[\"全表扫描\",{\"0\":{\"151\":1,\"167\":1}}],[\"全部插入\",{\"1\":{\"22\":1}}],[\"节点的插入操作中\",{\"1\":{\"147\":1}}],[\"节点间关系错误\",{\"1\":{\"147\":1}}],[\"节点内部的错误影响将被消除\",{\"1\":{\"147\":1}}],[\"节点内部错误\",{\"1\":{\"147\":1}}],[\"节点内部错误和节点间关系错误\",{\"1\":{\"147\":1}}],[\"依赖\",{\"1\":{\"147\":1,\"251\":1}}],[\"突然崩溃\",{\"1\":{\"147\":1}}],[\"发生在事务\",{\"1\":{\"147\":1}}],[\"发送\",{\"1\":{\"26\":1}}],[\"错误处理与恢复\",{\"0\":{\"147\":1}}],[\"时\",{\"1\":{\"146\":1,\"268\":1}}],[\"k\",{\"1\":{\"160\":2}}],[\"kth\",{\"1\":{\"145\":9}}],[\"keyn\",{\"1\":{\"143\":2}}],[\"keynumber\",{\"1\":{\"143\":2}}],[\"key1\",{\"1\":{\"143\":1}}],[\"key0\",{\"1\":{\"143\":1}}],[\"keyset\",{\"1\":{\"59\":1,\"262\":1,\"290\":1,\"312\":1}}],[\"keys\",{\"1\":{\"59\":2}}],[\"key\",{\"1\":{\"21\":1,\"43\":1,\"55\":1,\"57\":13,\"58\":7,\"59\":4,\"67\":1,\"68\":1,\"70\":1,\"104\":2,\"144\":3,\"145\":2}}],[\"方便继续搜索下一个节点\",{\"1\":{\"145\":1}}],[\"方法负责检查是否有事务等待超时\",{\"1\":{\"266\":1}}],[\"方法负责初始化数据库\",{\"1\":{\"44\":1}}],[\"方法则负责关闭文件通道和文件\",{\"1\":{\"251\":1}}],[\"方法则可以直接调用\",{\"1\":{\"246\":1}}],[\"方法确认事务的当前状态\",{\"1\":{\"251\":1}}],[\"方法分别用于提交和回滚事务\",{\"1\":{\"251\":1}}],[\"方法更新\",{\"1\":{\"251\":1}}],[\"方法校验\",{\"1\":{\"251\":1}}],[\"方法来更新事务状态\",{\"1\":{\"251\":1}}],[\"方法来完成任务的提交或回滚操作\",{\"1\":{\"246\":1}}],[\"方法来实现\",{\"1\":{\"246\":1}}],[\"方法就做了这样的工作\",{\"1\":{\"245\":1}}],[\"方法时\",{\"1\":{\"219\":1}}],[\"方法解析\",{\"1\":{\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"方法是解析\",{\"1\":{\"196\":1}}],[\"方法用于删除数据\",{\"1\":{\"316\":1}}],[\"方法用于读取数据\",{\"1\":{\"314\":1}}],[\"方法用于中止事务\",{\"1\":{\"313\":1}}],[\"方法用于提交事务并释放事务持有的锁\",{\"1\":{\"312\":1}}],[\"方法用于启动一个新事务\",{\"1\":{\"311\":1}}],[\"方法用于检查事务状态\",{\"1\":{\"251\":1}}],[\"方法用于开始一个新事务\",{\"1\":{\"251\":1}}],[\"方法用于更新\",{\"1\":{\"191\":1}}],[\"方法用于加载\",{\"1\":{\"190\":1}}],[\"方法用于创建或打开启动信息文件\",{\"1\":{\"189\":1}}],[\"方法用于在上层模块使用完页面后\",{\"1\":{\"115\":1}}],[\"方法用于在数据库崩溃后重新插入数据和恢复修改\",{\"1\":{\"106\":1}}],[\"方法首先将数据写入一个临时文件\",{\"1\":{\"187\":1}}],[\"方法进行解析\",{\"1\":{\"167\":1}}],[\"方法进行比较\",{\"1\":{\"159\":1}}],[\"方法中\",{\"1\":{\"154\":1,\"228\":1}}],[\"方法在\",{\"1\":{\"116\":1}}],[\"方法根据需要的空间大小\",{\"1\":{\"114\":1}}],[\"方法根据页面编号获取一个\",{\"1\":{\"70\":1}}],[\"方法通过读取数据库文件中的页面数据\",{\"1\":{\"104\":1}}],[\"方法实现\",{\"1\":{\"100\":1}}],[\"方法将数据包装为\",{\"1\":{\"315\":1}}],[\"方法将事务\",{\"1\":{\"251\":1}}],[\"方法将其内容写入磁盘\",{\"1\":{\"105\":1}}],[\"方法将\",{\"1\":{\"83\":1}}],[\"方法将读取到的\",{\"1\":{\"83\":1}}],[\"方法计算数据的校验和\",{\"1\":{\"83\":1}}],[\"方法不断获取下一条日志\",{\"1\":{\"83\":1}}],[\"方法处理异常\",{\"1\":{\"82\":2,\"83\":2}}],[\"方法释放缓存\",{\"1\":{\"66\":1}}],[\"方法释放对该资源的引用\",{\"1\":{\"53\":1}}],[\"方法可以释放缓存中的\",{\"1\":{\"64\":1}}],[\"方法会检查页面是否是脏页面\",{\"1\":{\"105\":1}}],[\"方法会确保缓存中的所有资源都被安全地释放\",{\"1\":{\"59\":1}}],[\"方法会首先检查资源是否已经在缓存中\",{\"1\":{\"57\":1}}],[\"方法执行必要的回源处理\",{\"1\":{\"58\":1}}],[\"方法减少引用计数\",{\"1\":{\"58\":1}}],[\"方法从数据源获取资源并缓存\",{\"1\":{\"57\":1}}],[\"方法发送\",{\"1\":{\"37\":1}}],[\"方法\",{\"0\":{\"196\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1},\"1\":{\"34\":1,\"72\":1,\"107\":1,\"242\":1}}],[\"范围为\",{\"1\":{\"145\":1}}],[\"搜索与插入操作\",{\"0\":{\"145\":1}}],[\"根节点并不是固定的\",{\"1\":{\"146\":1}}],[\"根节点的管理\",{\"0\":{\"146\":1}}],[\"根节点的初始化\",{\"0\":{\"144\":1},\"1\":{\"166\":1}}],[\"根据事务xid取得其在xid文件中对应的位置\",{\"1\":{\"243\":1}}],[\"根据不同的\",{\"1\":{\"195\":1}}],[\"根据字段和表达式计算条件范围\",{\"1\":{\"161\":1}}],[\"根据给定的键值\",{\"1\":{\"145\":1}}],[\"根据给定的空间大小选择一个\",{\"1\":{\"72\":1}}],[\"根据空间大小选择页面\",{\"0\":{\"114\":1}}],[\"根据pagenumber从数据库文件中读取页数据\",{\"1\":{\"104\":1}}],[\"根据最大页号截断缓存\",{\"1\":{\"98\":1}}],[\"根据\",{\"1\":{\"72\":1}}],[\"根据获取到的\",{\"1\":{\"70\":1}}],[\"根据数据库文件是否存在\",{\"1\":{\"44\":1}}],[\"根据客户端发送的\",{\"1\":{\"43\":1}}],[\"交替存储子节点和键值对\",{\"1\":{\"143\":1}}],[\"交互的启动\",{\"1\":{\"7\":1,\"174\":1}}],[\"指向下一个表的链接以及表中各个字段的唯一标识符\",{\"1\":{\"216\":1}}],[\"指向兄弟节点在\",{\"1\":{\"143\":1}}],[\"指定查找\",{\"1\":{\"22\":1}}],[\"指定插入\",{\"1\":{\"22\":1}}],[\"二叉树索引结构\",{\"0\":{\"143\":1}}],[\"虽然可以通过兄弟节点间接找到\",{\"1\":{\"147\":1}}],[\"虽然\",{\"1\":{\"138\":1}}],[\"虽然这种格式增加了通信的效率\",{\"1\":{\"30\":1}}],[\"或删除版本未提交或不在快照中\",{\"1\":{\"288\":1,\"289\":1}}],[\"或删除版本未提交\",{\"1\":{\"286\":1}}],[\"或者\",{\"1\":{\"268\":1}}],[\"或者两个需要查询的字段中其中一个没有建立索引\",{\"1\":{\"153\":1}}],[\"或\",{\"1\":{\"138\":1,\"216\":1,\"217\":1,\"286\":1,\"288\":1}}],[\"演示结果\",{\"0\":{\"137\":1}}],[\"接收一个事务id\",{\"1\":{\"249\":1}}],[\"接下来\",{\"1\":{\"136\":1}}],[\"接口的基本定义\",{\"1\":{\"309\":1}}],[\"接口的静态方法\",{\"1\":{\"70\":1}}],[\"接口向上层提供了一组用于管理事务和数据操作的基本功能\",{\"1\":{\"309\":1}}],[\"接口向上层提供功能支持\",{\"1\":{\"279\":1}}],[\"接口\",{\"1\":{\"36\":1}}],[\"到\",{\"1\":{\"136\":1}}],[\"到位置\",{\"1\":{\"86\":1}}],[\"打印两个\",{\"1\":{\"136\":1}}],[\"打印原始数组的内容\",{\"1\":{\"136\":1}}],[\"打开一个已存在的booter对象\",{\"1\":{\"189\":1}}],[\"打开一个新的终端窗口\",{\"1\":{\"14\":1,\"181\":1}}],[\"打开文件时\",{\"1\":{\"81\":1}}],[\"打开\",{\"1\":{\"16\":1,\"183\":1}}],[\"9\",{\"1\":{\"136\":1,\"137\":2}}],[\"9999\",{\"1\":{\"14\":1,\"37\":1,\"181\":1}}],[\"6\",{\"1\":{\"136\":1,\"137\":2}}],[\"60000\",{\"1\":{\"46\":1}}],[\"60\",{\"1\":{\"46\":3}}],[\"7\",{\"1\":{\"136\":1,\"137\":3}}],[\"共享同一片内存区域的不同部分\",{\"1\":{\"134\":1}}],[\"共享内存数组\",{\"0\":{\"132\":1},\"1\":{\"129\":1}}],[\"所有数据版本对事务都是可见的\",{\"1\":{\"284\":1}}],[\"所有对数据的读写操作都必须先获取相应的锁\",{\"1\":{\"273\":1}}],[\"所有操作的结果直接以字节数组的形式返回\",{\"1\":{\"226\":1}}],[\"所以当前版本仍然是可见的\",{\"1\":{\"286\":1}}],[\"所以\",{\"1\":{\"256\":2}}],[\"所以这个方法也在table中实现了一份\",{\"1\":{\"160\":1}}],[\"所代表的数组的有效范围\",{\"1\":{\"134\":1}}],[\"所在的页\",{\"1\":{\"71\":1}}],[\"底层会进行一次数组复制\",{\"1\":{\"133\":1}}],[\"你会将其标记为\",{\"1\":{\"246\":2}}],[\"你需要先给它分配一个编号\",{\"1\":{\"245\":1}}],[\"你需要提交文档以确认其状态\",{\"1\":{\"233\":1}}],[\"你的工具就是这篇教程中的\",{\"1\":{\"233\":1}}],[\"你的职责是确保这些任务被准确记录\",{\"1\":{\"233\":1}}],[\"你则需要将文档恢复到最初状态\",{\"1\":{\"233\":1}}],[\"你将看到这些设计理念是如何在\",{\"1\":{\"129\":1}}],[\"你可以在其中输入\",{\"1\":{\"17\":1,\"184\":1}}],[\"你可以在浏览器中访问\",{\"1\":{\"13\":1,\"180\":1}}],[\"你可以利用启动配置来自动化数据库的创建和启动过程\",{\"1\":{\"15\":1,\"182\":1}}],[\"你可以通过发送\",{\"1\":{\"13\":1,\"180\":1}}],[\"探讨它如何在保障数据库性能的同时\",{\"1\":{\"129\":1}}],[\"环境下\",{\"1\":{\"129\":1}}],[\"环境下运行\",{\"1\":{\"13\":1,\"180\":1}}],[\"设计了一个\",{\"1\":{\"129\":1}}],[\"设置数据项的xmax为当前事务的id\",{\"1\":{\"316\":1}}],[\"设置查询字段和表名\",{\"1\":{\"198\":1}}],[\"设置空闲空间偏移量\",{\"1\":{\"125\":1}}],[\"设置关闭时的校验字节\",{\"1\":{\"123\":1}}],[\"设置启动时的校验字节\",{\"1\":{\"123\":1}}],[\"设置页面缓存\",{\"1\":{\"104\":1}}],[\"设置页面实际包含的字节数据\",{\"1\":{\"104\":1}}],[\"设置页面的页号\",{\"1\":{\"104\":1}}],[\"设置文件通道的位置为计算出的偏移量\",{\"1\":{\"104\":1}}],[\"设置文件通道的位置\",{\"1\":{\"100\":1}}],[\"设置\",{\"1\":{\"16\":1,\"183\":1,\"198\":2,\"305\":1}}],[\"空闲空间偏移量\",{\"0\":{\"125\":1}}],[\"普通页\",{\"1\":{\"124\":1}}],[\"普通页面\",{\"1\":{\"124\":1}}],[\"普通页的管理核心在于管理空闲空间偏移量\",{\"1\":{\"125\":1}}],[\"普通页的管理\",{\"0\":{\"124\":1}}],[\"校验过程相对简单\",{\"1\":{\"242\":1}}],[\"校验xid文件\",{\"0\":{\"242\":1}}],[\"校验字节是否一致\",{\"1\":{\"123\":1}}],[\"校验di是否有效\",{\"1\":{\"72\":1}}],[\"优化了系统性能\",{\"1\":{\"117\":1}}],[\"优化了并发操作\",{\"1\":{\"2\":1}}],[\"显著提高了数据库插入操作的效率\",{\"1\":{\"117\":1}}],[\"被设计为可以拥有多个版本\",{\"1\":{\"275\":1}}],[\"被加入到\",{\"1\":{\"256\":3}}],[\"被特殊定义为超级事务\",{\"1\":{\"235\":1}}],[\"被创建时调用\",{\"1\":{\"116\":1}}],[\"被选择的页面从页面索引中移除\",{\"1\":{\"112\":1}}],[\"填充页面索引\",{\"0\":{\"116\":1}}],[\"向上取整\",{\"1\":{\"114\":1}}],[\"向上寻找合适的\",{\"1\":{\"72\":1}}],[\"有效地管理了资源的并发访问\",{\"1\":{\"269\":1}}],[\"有效避免了频繁的磁盘访问\",{\"1\":{\"112\":1}}],[\"有时用户在创建表时可能没有显式指定主键或索引字段\",{\"1\":{\"222\":1}}],[\"有如下事务操作\",{\"1\":{\"86\":1}}],[\"总的来说\",{\"1\":{\"112\":1}}],[\"总结\",{\"0\":{\"60\":1,\"74\":1,\"107\":1,\"117\":1,\"138\":1,\"251\":1,\"280\":1,\"317\":1}}],[\"包装数据\",{\"1\":{\"315\":1}}],[\"包含具有相同空闲空间大小的页面信息\",{\"1\":{\"112\":1}}],[\"包括那些尚未提交的数据版本\",{\"1\":{\"284\":1}}],[\"包括事务的开始\",{\"1\":{\"231\":1,\"251\":1,\"309\":1}}],[\"包括创建\",{\"1\":{\"226\":1}}],[\"包括启动信息管理\",{\"1\":{\"207\":1}}],[\"包括处理where条件中的逻辑运算\",{\"1\":{\"158\":1}}],[\"包括校验和\",{\"1\":{\"129\":1}}],[\"包括第一页的特殊用途和普通页的空闲空间管理\",{\"1\":{\"121\":1}}],[\"包括新建页面\",{\"1\":{\"98\":1}}],[\"包括数据库连接\",{\"1\":{\"46\":1}}],[\"包括会话的创建\",{\"1\":{\"46\":1}}],[\"数组的某一部分可以直接指向原数组的内存区域\",{\"1\":{\"133\":1}}],[\"数组被视为对象\",{\"1\":{\"133\":1}}],[\"数组中的每个元素都是一个列表\",{\"1\":{\"112\":1}}],[\"数据部分会被截取并返回\",{\"1\":{\"304\":1}}],[\"数据会附加在其后\",{\"1\":{\"303\":1}}],[\"数据会被转换为十六进制字符串并在末尾加上换行符\",{\"1\":{\"33\":1}}],[\"数据结构\",{\"1\":{\"303\":1}}],[\"数据结构中\",{\"1\":{\"299\":1}}],[\"数据结构与字段介绍\",{\"0\":{\"259\":1}}],[\"数据存储结构\",{\"0\":{\"215\":1}}],[\"数据存储和访问\",{\"1\":{\"64\":1}}],[\"数据一致性和事务管理的支持\",{\"1\":{\"207\":1}}],[\"数据\",{\"1\":{\"309\":1},\"2\":{\"130\":1}}],[\"数据大小等信息\",{\"1\":{\"129\":1}}],[\"数据管理\",{\"0\":{\"129\":1}}],[\"数据管理器\",{\"1\":{\"65\":1,\"226\":1}}],[\"数据插入\",{\"0\":{\"126\":1}}],[\"数据页管理\",{\"0\":{\"120\":1}}],[\"数据页缓存\",{\"0\":{\"95\":1}}],[\"数据恢复操作是为了确保在系统崩溃后\",{\"1\":{\"106\":1}}],[\"数据恢复操作\",{\"0\":{\"106\":1}}],[\"数据的一致性和完整性\",{\"1\":{\"68\":1}}],[\"数据缓存与管理\",{\"1\":{\"68\":1}}],[\"数据修改前准备\",{\"1\":{\"66\":1}}],[\"数据修改与事务管理\",{\"1\":{\"64\":1}}],[\"数据访问与操作\",{\"1\":{\"68\":1}}],[\"数据访问\",{\"1\":{\"66\":1}}],[\"数据共享与内存管理\",{\"1\":{\"64\":1}}],[\"数据库表结构与字段约束的实现\",{\"0\":{\"214\":1}}],[\"数据库中的表和字段信息以二进制形式存储在称为\",{\"1\":{\"215\":1}}],[\"数据库中的表和字段信息以二进制形式存储\",{\"1\":{\"209\":1}}],[\"数据库启动信息文件\",{\"1\":{\"188\":1}}],[\"数据库启动信息文件的路径\",{\"1\":{\"188\":1}}],[\"数据库启动信息文件的临时后缀\",{\"1\":{\"188\":1}}],[\"数据库启动信息文件的后缀\",{\"1\":{\"188\":1}}],[\"数据库重启后\",{\"1\":{\"147\":1}}],[\"数据库文件的第一页通常被用于存储元数据和执行启动检查\",{\"1\":{\"122\":1}}],[\"数据库文件管理\",{\"1\":{\"44\":1}}],[\"数据库页面管理\",{\"0\":{\"121\":1}}],[\"数据库系统在处理大量插入操作时表现得更加高效\",{\"1\":{\"117\":1}}],[\"数据库系统中\",{\"1\":{\"102\":1}}],[\"数据库系统通常尽量将数据保留在内存中以提高性能\",{\"1\":{\"51\":1}}],[\"数据库崩溃时尚未写完的日志数据\",{\"1\":{\"79\":1}}],[\"数据库的上层模块可以方便地对数据进行操作\",{\"1\":{\"68\":1}}],[\"数据库初始化与销毁等多个重要功能模块\",{\"1\":{\"41\":1}}],[\"数据库创建后\",{\"1\":{\"14\":1,\"181\":1}}],[\"数据库服务将会运行在指定的端口\",{\"1\":{\"13\":1,\"180\":1}}],[\"数据抽象\",{\"1\":{\"9\":1,\"176\":1}}],[\"映射到某一个区间\",{\"1\":{\"112\":1}}],[\"划分为40个区间\",{\"1\":{\"112\":1}}],[\"能够降低事务之间的阻塞概率\",{\"1\":{\"298\":1}}],[\"能够有效减少频繁的数据加载操作\",{\"1\":{\"279\":1}}],[\"能够有效地管理和查询不同事务创建的数据版本\",{\"1\":{\"275\":1}}],[\"能够解析各种sql语句\",{\"1\":{\"210\":1}}],[\"能够解析各种\",{\"1\":{\"195\":1}}],[\"能够在索引失效的情况下依然保证查询的完整性与正确性\",{\"1\":{\"167\":1}}],[\"能够对读者在全表扫描及其优化的实现上有所帮助\",{\"1\":{\"161\":1}}],[\"能够快速找到一个合适的页面\",{\"1\":{\"111\":1}}],[\"能够从日志或其他持久化存储中恢复数据\",{\"1\":{\"106\":1}}],[\"限制条件\",{\"0\":{\"102\":1}}],[\"限制同时活跃的用户数量\",{\"1\":{\"46\":1}}],[\"都自然地满足了这两条规定\",{\"1\":{\"298\":1}}],[\"都是检查一个\",{\"1\":{\"249\":1}}],[\"都可以通过同一个操作\",{\"1\":{\"246\":1}}],[\"都要解锁\",{\"1\":{\"100\":1,\"104\":1}}],[\"都会将一条日志记录到磁盘上\",{\"1\":{\"78\":1}}],[\"无论是完成还是取消\",{\"1\":{\"246\":1}}],[\"无论是否发生异常\",{\"1\":{\"100\":1,\"104\":1}}],[\"无效释放缓存\",{\"1\":{\"72\":1}}],[\"强制将文件通道中的所有未写入的数据写入到磁盘\",{\"1\":{\"246\":1,\"247\":1}}],[\"强制将数据从操作系统的缓存刷新到磁盘\",{\"1\":{\"100\":1}}],[\"强制终止运行\",{\"1\":{\"242\":1}}],[\"强制转换为\",{\"1\":{\"159\":1}}],[\"强行释放一个缓存\",{\"1\":{\"58\":1}}],[\"加了锁\",{\"1\":{\"297\":1}}],[\"加\",{\"1\":{\"297\":2}}],[\"加载一个\",{\"1\":{\"301\":1}}],[\"加载booter文件内容\",{\"1\":{\"227\":1}}],[\"加载数据库中的所有表到缓存中\",{\"1\":{\"227\":1}}],[\"加载启动信息\",{\"0\":{\"190\":1}}],[\"加载并检查第一页\",{\"1\":{\"73\":1}}],[\"加锁以防止并发问题\",{\"1\":{\"228\":1}}],[\"加锁\",{\"1\":{\"100\":1,\"304\":1}}],[\"决定是否将其写回文件系统\",{\"1\":{\"99\":1}}],[\"决定是创建新的数据库还是加载现有的数据库\",{\"1\":{\"44\":1}}],[\"两个操作之间就存在冲突\",{\"1\":{\"297\":1}}],[\"两个方法\",{\"1\":{\"99\":1}}],[\"两段锁协议\",{\"0\":{\"273\":1}}],[\"两者的协作使得数据库系统能够以高效\",{\"1\":{\"74\":1}}],[\"操作时\",{\"1\":{\"133\":1}}],[\"操作\",{\"1\":{\"96\":1,\"107\":1,\"146\":1,\"203\":1,\"251\":1}}],[\"值为日志列表\",{\"1\":{\"91\":1}}],[\"键为事务id\",{\"1\":{\"91\":1}}],[\"分别表示\",{\"1\":{\"251\":1}}],[\"分别引用原数组的不同部分\",{\"1\":{\"136\":1}}],[\"分别对应插入操作和更新操作\",{\"1\":{\"89\":1}}],[\"分配一个大小为page\",{\"1\":{\"104\":1}}],[\"分页管理和缓存\",{\"1\":{\"129\":1}}],[\"分页管理\",{\"1\":{\"9\":1,\"176\":1}}],[\"不需要等待\",{\"1\":{\"298\":1}}],[\"不需要记录状态\",{\"1\":{\"237\":1}}],[\"不可重复读和幻读问题\",{\"1\":{\"289\":1}}],[\"不可重复读\",{\"1\":{\"276\":2}}],[\"不符合规范\",{\"1\":{\"242\":1}}],[\"不允许直接共享数组的内存部分\",{\"1\":{\"138\":1}}],[\"不允许单条数据跨页存储\",{\"1\":{\"102\":1}}],[\"不同的事务隔离级别提供了不同的并发控制和数据一致性保障\",{\"1\":{\"283\":1}}],[\"不同\",{\"1\":{\"129\":1}}],[\"不更新update\",{\"1\":{\"106\":1}}],[\"不过首先\",{\"1\":{\"96\":1}}],[\"不会读取\",{\"1\":{\"87\":1}}],[\"不进行数据拷贝\",{\"1\":{\"66\":1}}],[\"然而\",{\"1\":{\"87\":1,\"273\":1,\"291\":1,\"297\":1}}],[\"然后尝试锁定\",{\"1\":{\"255\":2}}],[\"然后标记它为\",{\"1\":{\"245\":1}}],[\"然后基于语句的类型调用不同的解析方法\",{\"1\":{\"196\":1}}],[\"然后通过操作系统的文件重命名操作将临时文件重命名为\",{\"1\":{\"187\":1}}],[\"然后通过按位与操作提取出页面编号\",{\"1\":{\"69\":1}}],[\"然后打印出原始数组和两个\",{\"1\":{\"136\":1}}],[\"然后使用\",{\"1\":{\"136\":1}}],[\"然后将数据写入该位置\",{\"1\":{\"126\":1}}],[\"然后将校验和转换为字节数组\",{\"1\":{\"83\":1}}],[\"然后直接从该区间中选择一个页面\",{\"1\":{\"112\":1}}],[\"然后返回这个字节数组\",{\"1\":{\"83\":1}}],[\"然后写入文件\",{\"1\":{\"83\":1}}],[\"然后运行打开数据库的启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"案例背景\",{\"0\":{\"255\":1}}],[\"案例代码\",{\"0\":{\"136\":1}}],[\"案例演示\",{\"0\":{\"135\":1}}],[\"案例\",{\"1\":{\"87\":2}}],[\"案例讲解\",{\"1\":{\"86\":1,\"87\":1}}],[\"导致事务永远无法完成\",{\"1\":{\"278\":1}}],[\"导致数据版本不连续\",{\"1\":{\"277\":1}}],[\"导致数据不一致的问题\",{\"1\":{\"87\":1}}],[\"导致死锁\",{\"1\":{\"256\":1}}],[\"导致需要时再从磁盘加载回源\",{\"1\":{\"52\":1}}],[\"多个事务可能会同时操作同一个数据项\",{\"1\":{\"297\":1}}],[\"多个事务可能并发执行\",{\"1\":{\"87\":1}}],[\"多版本管理和死锁检测等机制\",{\"1\":{\"280\":1}}],[\"多版本并发控制\",{\"0\":{\"274\":1},\"1\":{\"2\":1,\"272\":1}}],[\"多线程环境下的恢复\",{\"0\":{\"87\":1}}],[\"假如你是一名负责管理重要文档的管理员\",{\"1\":{\"233\":1}}],[\"假设\",{\"1\":{\"297\":1,\"298\":1}}],[\"假设有两个事务\",{\"1\":{\"297\":1}}],[\"假设有两个并发事务\",{\"1\":{\"87\":1}}],[\"假设我们有三个事务\",{\"1\":{\"255\":1}}],[\"假设事务\",{\"1\":{\"87\":1}}],[\"假设在一个单线程环境中\",{\"1\":{\"86\":1}}],[\"假需要存储的字节大小为5168\",{\"1\":{\"72\":1}}],[\"逻辑删除\",{\"1\":{\"86\":1}}],[\"倒序扫描事务\",{\"1\":{\"86\":1}}],[\"撤销或回滚事务\",{\"1\":{\"238\":1}}],[\"撤销所有未完成的事务操作\",{\"1\":{\"91\":1}}],[\"撤销操作通过倒序扫描日志记录\",{\"1\":{\"91\":1}}],[\"撤销未完成的事务\",{\"0\":{\"91\":1}}],[\"撤销它会导致数据不一致\",{\"1\":{\"87\":1}}],[\"撤销\",{\"1\":{\"86\":1}}],[\"重新分配资源\",{\"1\":{\"268\":1}}],[\"重新插入位置\",{\"1\":{\"86\":2}}],[\"重置日志文件的读取位置到开始\",{\"1\":{\"90\":1}}],[\"重做所有已完成的事务操作\",{\"1\":{\"90\":1}}],[\"重做操作通过扫描所有日志记录\",{\"1\":{\"90\":1}}],[\"重做已完成的事务\",{\"0\":{\"90\":1}}],[\"重做\",{\"1\":{\"86\":2}}],[\"重复以上步骤\",{\"1\":{\"16\":1,\"183\":1}}],[\"只考虑更新操作\",{\"1\":{\"297\":1}}],[\"只处理单列索引\",{\"1\":{\"202\":1}}],[\"只可能有一个事务在操作数据库\",{\"1\":{\"86\":1}}],[\"只需要将\",{\"1\":{\"71\":1}}],[\"只需要从\",{\"1\":{\"70\":1}}],[\"只需将其有效位设置为\",{\"1\":{\"65\":1}}],[\"单线程环境下的恢复\",{\"0\":{\"86\":1}}],[\"必须等待\",{\"1\":{\"297\":1}}],[\"必须将其重新插入页面索引\",{\"1\":{\"112\":1}}],[\"必须先进行对应的日志操作\",{\"1\":{\"85\":1}}],[\"必要时执行恢复操作\",{\"1\":{\"73\":1}}],[\"借鉴而来的\",{\"1\":{\"84\":1}}],[\"恢复系统的正常运行\",{\"1\":{\"278\":1}}],[\"恢复过程的复杂性增加\",{\"1\":{\"87\":1}}],[\"恢复过程将撤销这些操作\",{\"1\":{\"86\":1}}],[\"恢复过程将\",{\"1\":{\"86\":1}}],[\"恢复策略的具体实现代码\",{\"0\":{\"88\":1}}],[\"恢复策略的基本原理\",{\"0\":{\"85\":1}}],[\"恢复策略是从\",{\"1\":{\"84\":1}}],[\"恢复策略详解\",{\"0\":{\"84\":1}}],[\"恢复原始数据并解锁数据项\",{\"1\":{\"66\":1}}],[\"写\",{\"1\":{\"279\":1}}],[\"写入文件过程中出现异常\",{\"1\":{\"191\":1}}],[\"写入到指定位置\",{\"1\":{\"83\":1}}],[\"写前分析\",{\"0\":{\"153\":1}}],[\"写回数据源\",{\"1\":{\"71\":1}}],[\"写回所有资源\",{\"1\":{\"59\":1}}],[\"个字节的数据转换为\",{\"1\":{\"83\":1}}],[\"个字节的数据到\",{\"1\":{\"83\":2}}],[\"流程图看个大概意思即可\",{\"1\":{\"83\":1}}],[\"函数实现了日志的读取和校验逻辑\",{\"1\":{\"83\":1}}],[\"部分\",{\"1\":{\"83\":1}}],[\"部分的长度\",{\"1\":{\"65\":1}}],[\"异常\",{\"1\":{\"82\":1,\"83\":2}}],[\"说明类型不匹配或字段不存在\",{\"1\":{\"159\":1}}],[\"说明日志不完整\",{\"1\":{\"83\":1}}],[\"说明日志已经被破坏\",{\"1\":{\"82\":1,\"83\":1}}],[\"说明没有更多的日志可以读取\",{\"1\":{\"82\":1,\"83\":1}}],[\"说明如何使用事务控制命令\",{\"1\":{\"23\":1}}],[\"说明如何在数据库中创建\",{\"1\":{\"21\":1}}],[\"直到\",{\"1\":{\"298\":1}}],[\"直到没有下一个表\",{\"1\":{\"227\":1}}],[\"直到没有更多的日志可以读取\",{\"1\":{\"82\":1}}],[\"直接修改最新版本\",{\"1\":{\"291\":1}}],[\"直接扫描整个表的实现方式\",{\"1\":{\"165\":1}}],[\"直接基于数据管理器\",{\"1\":{\"166\":1}}],[\"直接基于\",{\"1\":{\"142\":1}}],[\"直接返回缓存的值\",{\"1\":{\"262\":1}}],[\"直接返回所有uid\",{\"1\":{\"155\":1}}],[\"直接返回原始数据的引用\",{\"1\":{\"66\":1}}],[\"直接返回资源\",{\"1\":{\"57\":1}}],[\"直接在\",{\"1\":{\"13\":1,\"180\":1}}],[\"直接管理数据库的\",{\"1\":{\"9\":1,\"176\":1}}],[\"循环加载所有表\",{\"1\":{\"227\":1}}],[\"循环读取日志文件中的所有日志记录\",{\"1\":{\"90\":1,\"91\":1}}],[\"循环读取日志\",{\"1\":{\"82\":1}}],[\"循环直到获取资源\",{\"1\":{\"57\":1}}],[\"段的字节数\",{\"1\":{\"79\":1}}],[\"四字节整数\",{\"1\":{\"79\":2}}],[\"四字节的整数\",{\"1\":{\"79\":1}}],[\"~\",{\"1\":{\"79\":1}}],[\"再将其重命名为正式文件\",{\"1\":{\"208\":1}}],[\"再次处理singleexp2的结果\",{\"1\":{\"158\":1}}],[\"再次启动时\",{\"1\":{\"78\":1}}],[\"再重做\",{\"1\":{\"87\":1}}],[\"再根据偏移\",{\"1\":{\"70\":1}}],[\"层的事务管理更加高效且安全\",{\"1\":{\"317\":1}}],[\"层通过\",{\"1\":{\"309\":1}}],[\"层只保留每条记录的一个版本\",{\"1\":{\"301\":1}}],[\"层交互时必须遵守以下两条规定\",{\"1\":{\"298\":1}}],[\"层在与\",{\"1\":{\"298\":1}}],[\"层\",{\"1\":{\"85\":1}}],[\"层对底层数据进行操作时\",{\"1\":{\"78\":1}}],[\"层直接对外提供方法的类\",{\"1\":{\"67\":1}}],[\"每种隔离级别都有其特定的可见性规则和应用场景\",{\"1\":{\"283\":1}}],[\"每条记录保存在一个\",{\"1\":{\"301\":1}}],[\"每条记录会保存其创建和删除的事务信息\",{\"1\":{\"299\":1}}],[\"每条数据记录\",{\"1\":{\"275\":1}}],[\"每条日志的结构如下\",{\"1\":{\"79\":1}}],[\"每秒检测一次\",{\"1\":{\"265\":1}}],[\"每份文档都代表着一项关键任务\",{\"1\":{\"233\":1}}],[\"每次表的创建都会导致链表头部的变化\",{\"1\":{\"226\":1}}],[\"每次对文件系统的读写操作都以页面为单位进行\",{\"1\":{\"129\":1}}],[\"每次插入数据时\",{\"1\":{\"125\":1}}],[\"每次数据库启动时\",{\"1\":{\"123\":2}}],[\"每当一个事务修改某条记录时\",{\"1\":{\"298\":1}}],[\"每当一个事务对记录进行修改时\",{\"1\":{\"275\":1}}],[\"每当一个事务进入等待状态\",{\"1\":{\"269\":1}}],[\"每当你进行一次数据库操作\",{\"1\":{\"231\":1}}],[\"每当\",{\"1\":{\"78\":1}}],[\"每个记录代表数据的一项\",{\"1\":{\"298\":1}}],[\"每个版本记录了两个重要的元数据\",{\"1\":{\"275\":1}}],[\"每个事务只能看到它开始之前已经提交的版本\",{\"1\":{\"289\":1}}],[\"每个事务的占用长度\",{\"1\":{\"240\":1,\"251\":1}}],[\"每个事务在获取资源时\",{\"1\":{\"264\":1}}],[\"每个事务在\",{\"1\":{\"237\":1}}],[\"每个事务在清单中都有一个唯一的编号\",{\"1\":{\"231\":1}}],[\"每个事务都有一个唯一的事务标识符\",{\"1\":{\"235\":1}}],[\"每个事务都有一个独特的编号\",{\"1\":{\"234\":1}}],[\"每个字段都具有一个名称\",{\"1\":{\"217\":1}}],[\"每个表的信息都按照一定的结构存储\",{\"1\":{\"216\":1}}],[\"每个节点都存储在一条\",{\"1\":{\"143\":1}}],[\"每个普通页以一个2字节的无符号数开头\",{\"1\":{\"124\":1}}],[\"每个区间存储的页面信息\",{\"1\":{\"113\":1}}],[\"每个区间大小为204字节\",{\"1\":{\"113\":1}}],[\"每个\",{\"1\":{\"31\":1,\"43\":2}}],[\"崩溃恢复功能概述\",{\"0\":{\"78\":1}}],[\"事务阻塞\",{\"1\":{\"297\":1}}],[\"事务执行过程中的错误\",{\"1\":{\"290\":1}}],[\"事务结构\",{\"0\":{\"290\":1}}],[\"事务之间不会相互影响\",{\"1\":{\"289\":1}}],[\"事务在其生命周期内多次读取同一数据项时\",{\"1\":{\"287\":1}}],[\"事务可以读取其他事务未提交的数据\",{\"1\":{\"284\":1}}],[\"事务可能会由于等待时间过长而被回滚\",{\"1\":{\"264\":1}}],[\"事务隔离级别实现\",{\"0\":{\"283\":1}}],[\"事务请求资源\",{\"1\":{\"269\":1}}],[\"事务将进入等待状态\",{\"1\":{\"260\":1}}],[\"事务状态检查与关闭\",{\"0\":{\"248\":1}}],[\"事务总数加一\",{\"1\":{\"247\":1}}],[\"事务的快照\",{\"1\":{\"290\":1}}],[\"事务的id\",{\"1\":{\"290\":1}}],[\"事务的隔离级别\",{\"0\":{\"276\":1,\"282\":1},\"1\":{\"290\":1}}],[\"事务的执行顺序如下\",{\"1\":{\"255\":1}}],[\"事务的开始与状态更新\",{\"0\":{\"244\":1}}],[\"事务的三种状态\",{\"1\":{\"240\":1,\"251\":1}}],[\"事务的状态\",{\"0\":{\"236\":1}}],[\"事务标识符\",{\"1\":{\"235\":1}}],[\"事务表缓存\",{\"1\":{\"226\":1}}],[\"事务\",{\"1\":{\"86\":2,\"233\":1,\"237\":1,\"303\":1},\"2\":{\"232\":1,\"252\":1,\"253\":1}}],[\"事务处理和日志记录\",{\"1\":{\"74\":1}}],[\"事务管理实现与解析\",{\"0\":{\"233\":1}}],[\"事务管理模块不仅仅是数据库的核心功能之一\",{\"1\":{\"231\":1}}],[\"事务管理模块通过维护一个称为\",{\"1\":{\"231\":1}}],[\"事务管理能够保证在事务提交或回滚时\",{\"1\":{\"68\":1}}],[\"事务管理\",{\"0\":{\"231\":1},\"1\":{\"68\":1,\"231\":1}}],[\"事务管理器和表管理器等\",{\"1\":{\"46\":1}}],[\"正常情况下\",{\"1\":{\"155\":1}}],[\"正常关闭时\",{\"1\":{\"72\":1,\"123\":1}}],[\"正在更新记录\",{\"1\":{\"298\":1}}],[\"正在进行的事务不会修改其他未提交事务产生或修改的数据\",{\"1\":{\"298\":1}}],[\"正在进行的事务不会读取其他未提交事务产生的数据\",{\"1\":{\"298\":1}}],[\"正在进行的事务不得修改其他任何未提交的事务修改或产生的数据\",{\"1\":{\"87\":1}}],[\"正在进行的事务不得读取任何未提交的事务产生的数据\",{\"1\":{\"87\":1}}],[\"正在进行\",{\"1\":{\"236\":1}}],[\"正在获取资源的线程标记\",{\"1\":{\"56\":1}}],[\"正序重做\",{\"1\":{\"86\":1}}],[\"正序扫描事务\",{\"1\":{\"86\":1}}],[\"关闭tm\",{\"1\":{\"238\":1}}],[\"关闭事务管理器\",{\"0\":{\"250\":1}}],[\"关闭事务\",{\"1\":{\"238\":1}}],[\"关闭\",{\"1\":{\"72\":1}}],[\"关闭缓存\",{\"0\":{\"59\":1},\"1\":{\"59\":1,\"98\":1}}],[\"形成一个完整的插入日志\",{\"1\":{\"72\":1}}],[\"定期检查每个事务的等待时间\",{\"1\":{\"265\":1}}],[\"定期检查与清理\",{\"1\":{\"46\":1}}],[\"定义一个方法\",{\"1\":{\"249\":1}}],[\"定义一个静态方法\",{\"1\":{\"72\":1}}],[\"定义了页面缓存的接口\",{\"1\":{\"98\":1}}],[\"而旧版本仍然保留\",{\"1\":{\"298\":1}}],[\"而这些锁只有在事务提交或回滚后才会释放\",{\"1\":{\"273\":1}}],[\"而当任务被取消时\",{\"1\":{\"246\":1}}],[\"而如果在执行过程中出现问题\",{\"1\":{\"233\":1}}],[\"而全表扫描则是当查询条件无法通过索引优化时\",{\"1\":{\"165\":1}}],[\"而是重点描述其在\",{\"1\":{\"142\":1}}],[\"而无需重新计算\",{\"1\":{\"263\":1}}],[\"而无需经过版本管理\",{\"1\":{\"142\":1,\"166\":1}}],[\"而无需遍历磁盘或缓存中的所有页面\",{\"1\":{\"117\":1}}],[\"而无需遍历所有的页面\",{\"1\":{\"111\":1}}],[\"而没有依赖\",{\"1\":{\"142\":1}}],[\"而在ti开始之前\",{\"1\":{\"291\":1}}],[\"而在\",{\"1\":{\"133\":1}}],[\"而在本节中\",{\"1\":{\"96\":1}}],[\"而普通页的fso管理则确保了数据插入和存储的高效与准确\",{\"1\":{\"126\":1}}],[\"而不必等待\",{\"1\":{\"274\":1}}],[\"而不必担心多余的内存开销或数据复制\",{\"1\":{\"138\":1}}],[\"而不是我们期望的\",{\"1\":{\"297\":1}}],[\"而不是直接覆盖原有的数据\",{\"1\":{\"274\":1}}],[\"而不是常见的\",{\"1\":{\"129\":1}}],[\"而不是由缓存系统自动决定\",{\"1\":{\"52\":1}}],[\"而不更新空闲空间的偏移量\",{\"1\":{\"106\":1}}],[\"而由于\",{\"1\":{\"87\":1}}],[\"而该未提交事务在崩溃后被撤销时\",{\"1\":{\"87\":1}}],[\"而\",{\"1\":{\"74\":1,\"137\":1,\"219\":1,\"246\":1,\"255\":1,\"275\":1}}],[\"而26\",{\"1\":{\"72\":1}}],[\"此逻辑与可重复读的一致性逻辑相似\",{\"1\":{\"289\":1}}],[\"此方法的实现强调了线程安全性\",{\"1\":{\"228\":1}}],[\"此外\",{\"1\":{\"209\":1,\"210\":1}}],[\"此时\",{\"1\":{\"147\":1}}],[\"此时向上取整找到\",{\"1\":{\"72\":1}}],[\"此时计算出来的区间号是25\",{\"1\":{\"72\":1}}],[\"此处+1主要为了向上取整\",{\"1\":{\"72\":1}}],[\"此命令会在指定路径下创建一个新的数据库实例\",{\"1\":{\"14\":1,\"181\":1}}],[\"拼接dataitem\",{\"1\":{\"72\":1}}],[\"证明此时为非法数据\",{\"1\":{\"72\":1}}],[\"标志事务是否自动中止\",{\"1\":{\"290\":1}}],[\"标志页面是否是脏页面\",{\"1\":{\"97\":1}}],[\"标识了该版本的创建事务\",{\"1\":{\"275\":1}}],[\"标识data的长度\",{\"1\":{\"72\":1}}],[\"标记来避免数据的不一致性\",{\"1\":{\"148\":1}}],[\"标记该节点是否为叶子节点\",{\"1\":{\"143\":1}}],[\"标记页面为脏页面\",{\"1\":{\"126\":1}}],[\"标记为无效\",{\"1\":{\"86\":1}}],[\"标记哪些资源当前正在从数据源获取\",{\"1\":{\"56\":1}}],[\"跳出循环\",{\"1\":{\"72\":1,\"82\":1,\"90\":1,\"91\":1}}],[\"尝试为数据项添加锁\",{\"1\":{\"316\":1}}],[\"尝试获取数据项\",{\"1\":{\"316\":1}}],[\"尝试获取资源\",{\"1\":{\"57\":2}}],[\"尝试锁定\",{\"1\":{\"255\":1,\"256\":1}}],[\"尝试将文件的读取位置设置为当前位置\",{\"1\":{\"82\":1}}],[\"尝试将文件截断到当前位置\",{\"1\":{\"82\":1}}],[\"尝试5次找到一个可以容纳新数据项的页面\",{\"1\":{\"72\":1}}],[\"插入完成后\",{\"1\":{\"126\":1}}],[\"插入和更新日志的操作实现\",{\"0\":{\"92\":1}}],[\"插入和修改等数据操作方法\",{\"1\":{\"68\":1}}],[\"插入了数据\",{\"1\":{\"85\":1,\"86\":1}}],[\"插入新数据\",{\"1\":{\"85\":1}}],[\"插入的位置和页面信息都是通过页号和偏移量进行管理的\",{\"1\":{\"72\":1}}],[\"插入数据并返回唯一标识符\",{\"1\":{\"315\":1}}],[\"插入数据时的约束检查\",{\"1\":{\"221\":1}}],[\"插入数据\",{\"1\":{\"72\":1}}],[\"需要确保事务的串行执行\",{\"1\":{\"311\":1}}],[\"需要扫描磁盘来获取uid\",{\"1\":{\"155\":1}}],[\"需要全表扫描\",{\"1\":{\"154\":1}}],[\"需要查询的字段都没有建立索引\",{\"1\":{\"153\":1}}],[\"需要解决如何在内存中共享数组的问题\",{\"1\":{\"129\":1}}],[\"需要注意的是\",{\"1\":{\"96\":1}}],[\"需要定义出页面的结构\",{\"1\":{\"96\":1}}],[\"需要的空间大小\",{\"1\":{\"72\":1}}],[\"需要将\",{\"1\":{\"71\":1}}],[\"需要对\",{\"1\":{\"69\":1}}],[\"即事务的执行顺序可以调整为一个等效的串行执行顺序\",{\"1\":{\"273\":1}}],[\"即更新了xid文件的头部信息\",{\"1\":{\"247\":1}}],[\"即文件的开始位置\",{\"1\":{\"247\":1}}],[\"即\",{\"1\":{\"246\":1}}],[\"即每个事务当前持有的资源\",{\"1\":{\"259\":1}}],[\"即每次新表创建都会插入到链表的头部\",{\"1\":{\"226\":1}}],[\"即每条数据的大小不能超过单个页面的大小\",{\"1\":{\"102\":1}}],[\"即使其他事务并发地修改了数据\",{\"1\":{\"287\":1}}],[\"即使这两个数组的长度不同\",{\"1\":{\"133\":1}}],[\"即使在大数据量环境下也能保持高效的查询性能\",{\"1\":{\"2\":1}}],[\"即其数据已被修改但尚未写回磁盘\",{\"1\":{\"105\":1}}],[\"即一个已提交的事务读取了未提交事务的数据\",{\"1\":{\"87\":1}}],[\"即size日志文件的大小\",{\"1\":{\"83\":1}}],[\"即可\",{\"1\":{\"70\":1,\"71\":1}}],[\"也想读取\",{\"1\":{\"298\":1}}],[\"也想读取或更新\",{\"1\":{\"297\":1}}],[\"也会带来一个新的问题\",{\"1\":{\"297\":1}}],[\"也对数据进行了一个简单的过滤\",{\"1\":{\"284\":1}}],[\"也可能导致事务之间的相互阻塞\",{\"1\":{\"273\":1}}],[\"也可以适当增大这个值\",{\"1\":{\"96\":1}}],[\"也可以使用明文传输\",{\"1\":{\"30\":1}}],[\"也就是进行回滚\",{\"1\":{\"233\":1}}],[\"也确保了系统的灵活性和扩展性\",{\"1\":{\"161\":1}}],[\"也需要被撤销\",{\"1\":{\"87\":1}}],[\"也是继承自abstractcache\",{\"1\":{\"70\":1}}],[\"右移32位\",{\"1\":{\"69\":1,\"70\":1}}],[\"右移\",{\"1\":{\"69\":1}}],[\"偏移量和当前的\",{\"1\":{\"70\":1}}],[\"偏移量占\",{\"1\":{\"69\":1}}],[\"偏移量是\",{\"1\":{\"69\":1,\"70\":1}}],[\"位对齐到低位\",{\"1\":{\"69\":1}}],[\"位全1\",{\"1\":{\"69\":1}}],[\"位\",{\"1\":{\"69\":2}}],[\"按位与操作提取出页面编号\",{\"1\":{\"69\":1}}],[\"按位与操作提取出低16位的偏移量\",{\"1\":{\"69\":1}}],[\"按位或运算将页号和偏移量合并成一个uid\",{\"1\":{\"69\":1}}],[\"按钮\",{\"1\":{\"16\":1,\"183\":1}}],[\"左移32位表示页号\",{\"1\":{\"69\":1}}],[\"|\",{\"1\":{\"69\":1,\"199\":1}}],[\"||\",{\"1\":{\"43\":2,\"46\":1,\"158\":1,\"189\":2,\"191\":2,\"196\":2,\"219\":3,\"286\":1,\"288\":3,\"289\":3,\"292\":3}}],[\"组成\",{\"1\":{\"143\":1}}],[\"组成的一个\",{\"1\":{\"69\":1}}],[\"组合成一个\",{\"1\":{\"69\":1}}],[\"生成一个空的根节点数据的方法如下\",{\"1\":{\"144\":1}}],[\"生成根节点数据的方法如下\",{\"1\":{\"144\":1}}],[\"生成并设置随机校验字节\",{\"1\":{\"123\":1}}],[\"生成插入日志\",{\"1\":{\"72\":1}}],[\"生成\",{\"1\":{\"69\":1}}],[\"来处理\",{\"1\":{\"301\":1}}],[\"来管理并发控制和死锁检测\",{\"1\":{\"279\":1}}],[\"来管理正在获取的资源\",{\"1\":{\"53\":1}}],[\"来降低事务之间的阻塞概率\",{\"1\":{\"274\":1}}],[\"来记录事务的数量\",{\"1\":{\"251\":1}}],[\"来更新任务的状态\",{\"1\":{\"246\":1}}],[\"来自booter文件\",{\"1\":{\"227\":1}}],[\"来实现的\",{\"1\":{\"69\":1}}],[\"可能导致\",{\"1\":{\"276\":1}}],[\"可能会跳过tj的修改\",{\"1\":{\"291\":1}}],[\"可能会导致数据不一致\",{\"1\":{\"291\":1}}],[\"可能会反复检查相同的事务路径\",{\"1\":{\"263\":1}}],[\"可能会出现两种主要错误\",{\"1\":{\"147\":1}}],[\"可能发生在某次对\",{\"1\":{\"147\":1}}],[\"可能不存在\",{\"1\":{\"79\":1}}],[\"可靠地工作\",{\"1\":{\"129\":1}}],[\"可靠的方式管理和操作底层数据\",{\"1\":{\"74\":1}}],[\"可以读取\",{\"1\":{\"274\":1,\"298\":1}}],[\"可以显著减少重复计算的开销\",{\"1\":{\"263\":1}}],[\"可以通过\",{\"1\":{\"246\":1}}],[\"可以通过自定义的\",{\"1\":{\"133\":1}}],[\"可以快速找到一个合适的页面\",{\"1\":{\"117\":1}}],[\"可以快速定位到合适的空闲空间\",{\"1\":{\"68\":1}}],[\"可以减少频繁的磁盘\",{\"1\":{\"96\":1}}],[\"可重复读隔离级别下的事务可见性逻辑\",{\"1\":{\"288\":1}}],[\"可重复读的事务可见性逻辑\",{\"0\":{\"288\":1}}],[\"可重复读确保事务期间多次读取数据结果一致\",{\"1\":{\"276\":1}}],[\"可重复读\",{\"0\":{\"287\":1},\"1\":{\"23\":1,\"283\":1,\"287\":1}}],[\"可重复读和串行化\",{\"1\":{\"2\":1,\"276\":1}}],[\"还需释放全局锁\",{\"1\":{\"312\":1,\"313\":1}}],[\"还是必须等待\",{\"1\":{\"298\":1}}],[\"还是已回滚\",{\"1\":{\"231\":1}}],[\"还未被删除\",{\"1\":{\"286\":1}}],[\"还提供了强大的数据恢复功能\",{\"1\":{\"129\":1}}],[\"还更新了位置\",{\"1\":{\"86\":1}}],[\"还实现了页面索引管理功能\",{\"1\":{\"68\":1}}],[\"还萌生了对其进行二次开发的想法\",{\"1\":{\"4\":1,\"171\":1}}],[\"减少多次查找同一字段的开销\",{\"1\":{\"160\":1}}],[\"减少了事务之间的等待时间\",{\"1\":{\"298\":1}}],[\"减少了磁盘访问次数\",{\"1\":{\"117\":1}}],[\"减少了对底层存储的频繁访问\",{\"1\":{\"68\":1}}],[\"减少不必要的回源操作\",{\"1\":{\"60\":1}}],[\"页码和当前对象创建一个新的pageimpl对象并返回\",{\"1\":{\"104\":1}}],[\"页面管理\",{\"2\":{\"128\":1}}],[\"页面管理的设计目标之一是确保系统在启动时能够正确恢复\",{\"1\":{\"121\":1}}],[\"页面被标记为脏页面\",{\"1\":{\"126\":1}}],[\"页面数据校验机制\",{\"0\":{\"123\":1}}],[\"页面数据一旦创建就会立刻写入磁盘\",{\"1\":{\"101\":1}}],[\"页面索引将页面划分为若干区间\",{\"1\":{\"129\":1}}],[\"页面索引通过缓存页面的空闲空间信息\",{\"1\":{\"112\":1,\"117\":1}}],[\"页面索引通过将每个页面划分为一定数量的区间\",{\"1\":{\"112\":1}}],[\"页面索引的实现通过一个数组来存储这些信息\",{\"1\":{\"112\":1}}],[\"页面索引的基本介绍\",{\"0\":{\"112\":1}}],[\"页面索引的设计应运而生\",{\"1\":{\"111\":1}}],[\"页面索引设计与实现\",{\"0\":{\"111\":1}}],[\"页面索引\",{\"0\":{\"110\":1},\"1\":{\"129\":1},\"2\":{\"131\":1}}],[\"页面索引管理\",{\"1\":{\"68\":1}}],[\"页面写回文件系统\",{\"0\":{\"100\":1}}],[\"页面实际包含的字节数据\",{\"1\":{\"97\":1}}],[\"页面的页号\",{\"1\":{\"97\":1}}],[\"页面\",{\"1\":{\"97\":1,\"121\":1}}],[\"页面结构定义\",{\"0\":{\"97\":1}}],[\"页面结构是存储在内存中的\",{\"1\":{\"96\":1}}],[\"页面缓存\",{\"2\":{\"109\":1,\"131\":1}}],[\"页面缓存会自增页面数量\",{\"1\":{\"101\":1}}],[\"页面缓存的设计和实现对于提升数据库系统的读写性能至关重要\",{\"1\":{\"107\":1}}],[\"页面缓存的操作方法\",{\"0\":{\"103\":1}}],[\"页面缓存的具体实现类继承了抽象缓存框架\",{\"1\":{\"99\":1}}],[\"页面缓存的实现\",{\"0\":{\"99\":1}}],[\"页面缓存接口定义\",{\"0\":{\"98\":1}}],[\"页面缓存是为了提升读写效率而设计的一种缓存机制\",{\"1\":{\"96\":1}}],[\"页面缓存设计与实现\",{\"0\":{\"96\":1}}],[\"页面编号是\",{\"1\":{\"70\":1}}],[\"页面编号占\",{\"1\":{\"69\":1}}],[\"页面对象\",{\"1\":{\"65\":1}}],[\"页号和偏移各占\",{\"1\":{\"67\":1}}],[\"调用相应的解析方法\",{\"1\":{\"195\":1,\"196\":1}}],[\"调用panic\",{\"1\":{\"100\":1,\"104\":1,\"246\":2,\"247\":2,\"249\":1}}],[\"调用\",{\"1\":{\"66\":1,\"82\":2,\"83\":2}}],[\"后插入数据存储层\",{\"1\":{\"315\":1}}],[\"后台线程定期检查事务的等待时间\",{\"1\":{\"269\":1}}],[\"后\",{\"1\":{\"66\":1}}],[\"后端支持两种启动方式\",{\"1\":{\"7\":1,\"174\":1}}],[\"后端会尝试执行并返回结果\",{\"1\":{\"7\":1,\"174\":1}}],[\"后端则承担了更多的任务\",{\"1\":{\"7\":1,\"174\":1}}],[\"后端\",{\"0\":{\"7\":1,\"174\":1}}],[\"修改共享数组中的某个数据\",{\"1\":{\"136\":1}}],[\"修改和事务处理\",{\"1\":{\"67\":1}}],[\"修改完成后调用\",{\"1\":{\"66\":1}}],[\"修改用户数据\",{\"1\":{\"22\":1}}],[\"返回数据\",{\"1\":{\"314\":1}}],[\"返回数据插入位置\",{\"1\":{\"126\":1}}],[\"返回true\",{\"1\":{\"249\":1,\"316\":1}}],[\"返回创建表的成功消息\",{\"1\":{\"228\":1}}],[\"返回打开的booter对象\",{\"1\":{\"189\":1}}],[\"返回新创建的booter对象\",{\"1\":{\"189\":1}}],[\"返回新插入的数据项的唯一标识符\",{\"1\":{\"72\":1}}],[\"返回并移除找到的页面信息\",{\"1\":{\"114\":1}}],[\"返回读取到的日志\",{\"1\":{\"83\":1}}],[\"返回插入位置\",{\"1\":{\"72\":2,\"126\":1}}],[\"返回第一个\",{\"1\":{\"72\":1}}],[\"返回一个完整的\",{\"1\":{\"72\":1}}],[\"返回\",{\"1\":{\"66\":1,\"72\":2,\"83\":3,\"114\":1,\"159\":1}}],[\"返回的错误提示信息\",{\"1\":{\"31\":1}}],[\"旧的原始数据\",{\"1\":{\"65\":1}}],[\"字符串并返回相应的事务操作对象\",{\"1\":{\"203\":1}}],[\"字符串转换为值\",{\"0\":{\"160\":1}}],[\"字节空间给\",{\"1\":{\"303\":1}}],[\"字节数组\",{\"1\":{\"303\":1}}],[\"字节数字推算出文件的理论长度\",{\"1\":{\"242\":1}}],[\"字节的位置处\",{\"1\":{\"237\":1}}],[\"字节的数字\",{\"1\":{\"237\":1}}],[\"字节无符号整数来生成\",{\"1\":{\"69\":1}}],[\"字节无符号整数\",{\"1\":{\"67\":1,\"68\":1,\"69\":1,\"72\":1}}],[\"字节\",{\"1\":{\"65\":2,\"67\":1,\"68\":1,\"69\":1,\"123\":2,\"304\":2}}],[\"字段约束的实现\",{\"0\":{\"221\":1}}],[\"字段则必须是唯一的且不能为空\",{\"1\":{\"219\":1}}],[\"字段是唯一的且自动增长\",{\"1\":{\"219\":1}}],[\"字段是数据库表中的基本单元\",{\"1\":{\"217\":1}}],[\"字段类型\",{\"1\":{\"217\":1}}],[\"字段名称\",{\"1\":{\"217\":1}}],[\"字段所属的表\",{\"1\":{\"217\":1}}],[\"字段的创建与约束实现\",{\"0\":{\"220\":1}}],[\"字段的唯一标识符\",{\"1\":{\"217\":1}}],[\"字段的数据类型\",{\"1\":{\"217\":1}}],[\"字段的存储结构如下\",{\"1\":{\"217\":1}}],[\"字段的存储结构\",{\"0\":{\"217\":1}}],[\"字段与表\",{\"2\":{\"211\":1}}],[\"字段与表管理\",{\"0\":{\"206\":1,\"213\":1}}],[\"字段\",{\"1\":{\"198\":2}}],[\"字段2是否存在索引\",{\"1\":{\"154\":1}}],[\"字段1是否存在索引\",{\"1\":{\"154\":1}}],[\"字段修改为\",{\"1\":{\"16\":1,\"183\":1}}],[\"字段中\",{\"1\":{\"16\":2,\"183\":2}}],[\"字段中输入合适的名称\",{\"1\":{\"16\":1,\"183\":1}}],[\"记录修改操作的日志\",{\"1\":{\"305\":1}}],[\"记录\",{\"1\":{\"298\":1}}],[\"记录和版本\",{\"1\":{\"298\":1}}],[\"记录的数据项\",{\"1\":{\"301\":1}}],[\"记录的实际数据\",{\"1\":{\"300\":1}}],[\"记录的实现\",{\"0\":{\"299\":1}}],[\"记录的版本\",{\"0\":{\"295\":1}}],[\"记录的多版本存储与管理\",{\"0\":{\"275\":1}}],[\"记录了每个事务的状态\",{\"1\":{\"231\":1}}],[\"记录每个事务的检测结果\",{\"1\":{\"263\":1}}],[\"记录每个事务进入等待状态的时间\",{\"1\":{\"259\":1}}],[\"记录每个事务修改过的表\",{\"1\":{\"226\":1}}],[\"记录每个资源的引用计数\",{\"1\":{\"56\":1}}],[\"记录中没有对应的字段\",{\"1\":{\"159\":1}}],[\"记录该条日志的校验和\",{\"1\":{\"79\":1}}],[\"记录插入日志\",{\"1\":{\"72\":1}}],[\"记录日志并解锁数据项\",{\"1\":{\"66\":1}}],[\"记录日志等流程\",{\"1\":{\"64\":1}}],[\"对数据项\",{\"1\":{\"297\":1}}],[\"对数组的处理方式与其他语言\",{\"1\":{\"129\":1}}],[\"对于校验未通过的情况\",{\"1\":{\"242\":1}}],[\"对我而言\",{\"1\":{\"153\":1}}],[\"对节点的数据进行更改时\",{\"1\":{\"147\":1}}],[\"对所有活跃的事务的日志进行倒序撤销\",{\"1\":{\"91\":1}}],[\"对象初始化时\",{\"1\":{\"226\":1}}],[\"对象之间的映射关系\",{\"1\":{\"160\":1}}],[\"对象返回\",{\"1\":{\"104\":1}}],[\"对象返回给上层模块\",{\"1\":{\"64\":1}}],[\"对象的缓存管理\",{\"1\":{\"67\":1}}],[\"对象\",{\"1\":{\"64\":1,\"68\":1,\"70\":4,\"72\":2,\"99\":1,\"194\":1,\"195\":1}}],[\"对象由底层\",{\"1\":{\"64\":1}}],[\"对象读取或修改数据内容\",{\"1\":{\"64\":1}}],[\"对方收到后\",{\"1\":{\"31\":1}}],[\"存储\",{\"1\":{\"303\":1}}],[\"存储正在等待资源的事务的锁\",{\"1\":{\"259\":1}}],[\"存储等待某个资源的事务队列\",{\"1\":{\"259\":1}}],[\"存储每个事务正在等待的资源id\",{\"1\":{\"259\":1}}],[\"存储每个事务已获得的资源列表\",{\"1\":{\"259\":1}}],[\"存储每个资源被哪个事务持有\",{\"1\":{\"259\":1}}],[\"存储已加载的表对象\",{\"1\":{\"226\":1}}],[\"存储的\",{\"1\":{\"67\":1}}],[\"存储了数据的具体内容\",{\"1\":{\"64\":1}}],[\"存储实际缓存的数据\",{\"1\":{\"56\":1}}],[\"释放数据项\",{\"1\":{\"314\":1,\"316\":1}}],[\"释放全局锁\",{\"1\":{\"312\":1,\"313\":2}}],[\"释放所有已占用资源\",{\"1\":{\"267\":1}}],[\"释放该事务占用的资源\",{\"1\":{\"267\":1}}],[\"释放页面\",{\"1\":{\"72\":1,\"98\":1,\"116\":1}}],[\"释放缓存\",{\"1\":{\"59\":1,\"66\":1}}],[\"释放锁后才能继续操作\",{\"1\":{\"297\":1}}],[\"释放锁\",{\"1\":{\"58\":1,\"59\":1,\"72\":1,\"114\":1,\"115\":1,\"298\":1,\"304\":1,\"316\":1}}],[\"释放资源\",{\"0\":{\"58\":1}}],[\"更新操作由后续的表和字段管理\",{\"1\":{\"301\":1}}],[\"更新路径缓存\",{\"1\":{\"262\":4}}],[\"更新xid事务的状态为status\",{\"1\":{\"246\":1}}],[\"更新事务\",{\"1\":{\"246\":1}}],[\"更新事务状态\",{\"0\":{\"246\":1}}],[\"更新表链表的头部uid\",{\"1\":{\"228\":1}}],[\"更新\",{\"1\":{\"226\":1,\"297\":2}}],[\"更新唯一约束值集合\",{\"1\":{\"221\":1}}],[\"更新和删除操作\",{\"1\":{\"207\":1}}],[\"更新值和\",{\"1\":{\"200\":1}}],[\"更新file字段为新的启动信息文件\",{\"1\":{\"191\":1}}],[\"更新启动信息\",{\"0\":{\"191\":1}}],[\"更新空闲空间偏移量\",{\"1\":{\"126\":1}}],[\"更新后的数据\",{\"1\":{\"87\":1}}],[\"更新为\",{\"1\":{\"85\":1,\"86\":1,\"87\":2}}],[\"更新总校验值\",{\"1\":{\"83\":2}}],[\"更新当前位置\",{\"1\":{\"83\":1}}],[\"更新pg的空闲空间偏移量\",{\"1\":{\"72\":1}}],[\"更新资源的引用计数\",{\"1\":{\"58\":1}}],[\"更新最后访问时间\",{\"1\":{\"43\":1}}],[\"抛出异常\",{\"1\":{\"57\":1,\"72\":2,\"82\":1,\"189\":4,\"191\":2,\"242\":1}}],[\"则tj在ti开始之前已经提交\",{\"1\":{\"292\":1}}],[\"则该版本可见\",{\"1\":{\"286\":1,\"288\":1,\"289\":1}}],[\"则用于标识删除该版本的事务\",{\"1\":{\"275\":1}}],[\"则执行回滚操作\",{\"1\":{\"265\":1}}],[\"则下次再遇到该路径时直接返回缓存结果\",{\"1\":{\"263\":1}}],[\"则认为该\",{\"1\":{\"242\":1}}],[\"则创建一个新的条目\",{\"1\":{\"228\":1}}],[\"则返回兄弟节点的\",{\"1\":{\"145\":2}}],[\"则规定了\",{\"1\":{\"134\":1}}],[\"则意味着需要执行数据恢复流程\",{\"1\":{\"123\":1}}],[\"则表明上次关闭是正常的\",{\"1\":{\"123\":1}}],[\"则需要等待\",{\"1\":{\"264\":1}}],[\"则需要通过\",{\"1\":{\"105\":1}}],[\"则需要将其数据写回到磁盘\",{\"1\":{\"100\":1}}],[\"则通过\",{\"1\":{\"57\":1}}],[\"则增加其引用计数并返回\",{\"1\":{\"57\":1}}],[\"则会提示用户\",{\"1\":{\"7\":1,\"174\":1}}],[\"维护一个\",{\"1\":{\"237\":1}}],[\"维护了三个核心的\",{\"1\":{\"56\":1}}],[\"维护和销毁\",{\"1\":{\"46\":1}}],[\"其状态永远是committed\",{\"1\":{\"235\":1}}],[\"其他比较操作\",{\"1\":{\"159\":1}}],[\"其数据结构如下\",{\"1\":{\"143\":1}}],[\"其结构如下\",{\"1\":{\"97\":1}}],[\"其核心是通过严格的日志管理和操作规则来确保数据库在崩溃后的数据一致性\",{\"1\":{\"84\":1}}],[\"其空闲空间大于或等于给定的空间大小\",{\"1\":{\"72\":1}}],[\"其中至少有一个是更新操作\",{\"1\":{\"297\":1}}],[\"其中\",{\"1\":{\"285\":1}}],[\"其中记录了每章的名称以及它们的位置\",{\"1\":{\"216\":1}}],[\"其中存储了根节点的\",{\"1\":{\"146\":1}}],[\"其中页号和偏移量各占\",{\"1\":{\"69\":1}}],[\"其中页号和页内偏移各占\",{\"1\":{\"68\":1}}],[\"其中包含两个需要子类实现的抽象方法\",{\"1\":{\"55\":1}}],[\"其主要任务包括\",{\"1\":{\"9\":1,\"176\":1}}],[\"抽象类\",{\"0\":{\"55\":1},\"1\":{\"55\":1}}],[\"获取数据项\",{\"1\":{\"314\":1}}],[\"获取全局锁\",{\"1\":{\"311\":1}}],[\"获取存储的数据\",{\"1\":{\"304\":1}}],[\"获取事务xid在xid文件中对应的位置\",{\"1\":{\"246\":1}}],[\"获取事务id\",{\"1\":{\"90\":2,\"91\":2}}],[\"获取xid位置\",{\"0\":{\"243\":1}}],[\"获取下一个表的uid\",{\"1\":{\"227\":1}}],[\"获取下一条日志\",{\"1\":{\"83\":1}}],[\"获取第一个表的uid\",{\"1\":{\"227\":2}}],[\"获取值\",{\"1\":{\"199\":1}}],[\"获取列名\",{\"1\":{\"199\":1}}],[\"获取所有uid\",{\"0\":{\"155\":1}}],[\"获取所有资源key\",{\"1\":{\"59\":1}}],[\"获取当前空闲空间偏移量\",{\"1\":{\"126\":1}}],[\"获取当前页面数量\",{\"1\":{\"116\":1}}],[\"获取当前页面数量以及刷新页面等方法\",{\"1\":{\"98\":1}}],[\"获取pg的当前空闲空间偏移量\",{\"1\":{\"106\":1}}],[\"获取pg的空闲空间偏移量\",{\"1\":{\"72\":1}}],[\"获取page的页码\",{\"1\":{\"100\":1}}],[\"获取更新日志信息\",{\"1\":{\"90\":1,\"91\":1}}],[\"获取插入日志信息\",{\"1\":{\"90\":1,\"91\":1}}],[\"获取页面的空闲空间大小\",{\"1\":{\"125\":1}}],[\"获取页面的空闲空间偏移量\",{\"1\":{\"125\":1}}],[\"获取页面的第一个空闲空间的偏移量\",{\"1\":{\"72\":1}}],[\"获取页面\",{\"1\":{\"98\":1,\"116\":1}}],[\"获取页面信息对象中的页面\",{\"1\":{\"72\":1}}],[\"获取缓存\",{\"1\":{\"59\":1}}],[\"获取锁\",{\"1\":{\"57\":1,\"58\":1,\"72\":1,\"114\":1,\"115\":1,\"316\":1}}],[\"获取资源的引用计数并减一\",{\"1\":{\"58\":1}}],[\"获取资源\",{\"0\":{\"57\":1}}],[\"获取完成后\",{\"1\":{\"53\":1}}],[\"获取客户端的真实\",{\"1\":{\"45\":1}}],[\"获取客户端\",{\"1\":{\"45\":1}}],[\"避免产生锁相关的问题\",{\"1\":{\"313\":1}}],[\"避免版本跳跃\",{\"1\":{\"292\":1}}],[\"避免重复创建\",{\"1\":{\"228\":1}}],[\"避免重复回源\",{\"1\":{\"53\":1}}],[\"避免上层模块无法感知资源被驱逐的尴尬情况\",{\"1\":{\"129\":1}}],[\"避免级联回滚\",{\"1\":{\"87\":1}}],[\"避免数据不一致\",{\"1\":{\"87\":1}}],[\"避免数据拷贝\",{\"1\":{\"64\":1}}],[\"避免数据丢失\",{\"1\":{\"59\":1}}],[\"避免了数据不一致的问题\",{\"1\":{\"297\":1}}],[\"避免了\",{\"1\":{\"60\":1,\"276\":1}}],[\"避免不必要的回源\",{\"1\":{\"52\":1}}],[\"降低了系统的\",{\"1\":{\"52\":1}}],[\"缓存能够稳定\",{\"1\":{\"129\":1}}],[\"缓存设计采用了引用计数策略\",{\"1\":{\"129\":1}}],[\"缓存\",{\"1\":{\"74\":1}}],[\"缓存释放\",{\"1\":{\"71\":1}}],[\"缓存管理\",{\"1\":{\"64\":2}}],[\"缓存关闭\",{\"1\":{\"53\":1}}],[\"缓存会将该资源从内存中移除\",{\"1\":{\"53\":1}}],[\"缓存会记录该资源的引用次数\",{\"1\":{\"53\":1}}],[\"缓存未命中\",{\"1\":{\"53\":1}}],[\"缓存满时的处理\",{\"1\":{\"52\":1}}],[\"缓存才会将其移除\",{\"1\":{\"52\":1}}],[\"缓存策略对于性能的影响至关重要\",{\"1\":{\"50\":1}}],[\"资源被占用\",{\"1\":{\"260\":1}}],[\"资源未被占用\",{\"1\":{\"260\":1}}],[\"资源将直接分配给请求的事务\",{\"1\":{\"260\":1}}],[\"资源将从缓存中移除\",{\"1\":{\"58\":1}}],[\"资源的引用个数\",{\"1\":{\"56\":1}}],[\"资源的释放由上层模块主动触发\",{\"1\":{\"52\":1}}],[\"资源可能会因为缓存满而被驱逐\",{\"1\":{\"52\":1}}],[\"资源管理可控\",{\"1\":{\"52\":1}}],[\"资源释放与重分配\",{\"0\":{\"268\":1}}],[\"资源释放与驱逐\",{\"1\":{\"53\":1}}],[\"资源释放\",{\"1\":{\"46\":1,\"269\":1}}],[\"策略可能引发的问题\",{\"1\":{\"60\":1}}],[\"策略中\",{\"1\":{\"52\":1}}],[\"策略中可能出现的资源被意外驱逐而导致的回源操作\",{\"1\":{\"52\":1}}],[\"策略\",{\"1\":{\"52\":1,\"129\":1}}],[\"策略通常用于管理缓存\",{\"1\":{\"50\":1}}],[\"相比\",{\"1\":{\"52\":1}}],[\"速度远低于内存访问速度\",{\"1\":{\"51\":1}}],[\"因为该隔离级别不保证数据的可见性和一致性\",{\"1\":{\"291\":1}}],[\"因为它可能会破坏事务的逻辑一致性\",{\"1\":{\"277\":1}}],[\"因为它们共享同一片内存区域\",{\"1\":{\"137\":1}}],[\"因为\",{\"1\":{\"237\":1,\"256\":2}}],[\"因为第一个条件字段没有索引\",{\"1\":{\"154\":1}}],[\"因为磁盘\",{\"1\":{\"51\":1}}],[\"因此ti也应该回滚\",{\"1\":{\"292\":1}}],[\"因此ti应该回滚\",{\"1\":{\"292\":1}}],[\"因此该版本对当前事务是可见的\",{\"1\":{\"288\":1}}],[\"因此仍然是可见的\",{\"1\":{\"286\":1}}],[\"因此对其他事务是可见的\",{\"1\":{\"286\":1}}],[\"因此对原始数组的修改会直接反映在\",{\"1\":{\"136\":1}}],[\"因此需要更新\",{\"1\":{\"226\":1}}],[\"因此需要移除以确保文件一致性\",{\"1\":{\"82\":1}}],[\"因此2字节的偏移量足以表达这一页的所有可能偏移\",{\"1\":{\"124\":1}}],[\"因此恢复过程较为简单\",{\"1\":{\"86\":1}}],[\"因此\",{\"1\":{\"4\":1,\"87\":1,\"171\":1,\"286\":1,\"288\":1}}],[\"从活动事务中获取事务对象\",{\"1\":{\"316\":1}}],[\"从存储层读取\",{\"1\":{\"309\":1}}],[\"从这里开始\",{\"1\":{\"295\":1}}],[\"从等待队列中选择一个xid来占用uid\",{\"1\":{\"268\":1}}],[\"从等待时间记录中移除\",{\"1\":{\"266\":1}}],[\"从记录中获取字段值\",{\"1\":{\"159\":1}}],[\"从输出结果可以看出\",{\"1\":{\"137\":1}}],[\"从第二页开始处理每个页面\",{\"1\":{\"116\":1}}],[\"从第二页开始\",{\"1\":{\"116\":1}}],[\"从当前区间向上查找\",{\"1\":{\"114\":1}}],[\"从文件通道读取数据到字节缓冲区\",{\"1\":{\"249\":1}}],[\"从文件通道读取数据到bytebuffer\",{\"1\":{\"104\":1}}],[\"从文件通道中读取\",{\"1\":{\"83\":2}}],[\"从1开始计数\",{\"1\":{\"97\":1}}],[\"从而达到串行化隔离的效果\",{\"1\":{\"311\":1}}],[\"从而导致逻辑错误\",{\"1\":{\"291\":1}}],[\"从而防止脏读\",{\"1\":{\"285\":1}}],[\"从而打破死锁\",{\"1\":{\"278\":1}}],[\"从而保证数据库的正确性\",{\"1\":{\"273\":1}}],[\"从而保证了启动信息的安全性和正确性\",{\"1\":{\"208\":1}}],[\"从而保证了启动信息的一致性\",{\"1\":{\"187\":1}}],[\"从而识别死锁\",{\"1\":{\"261\":1}}],[\"从而实现对数据库的各种操作\",{\"1\":{\"226\":1}}],[\"从而模拟共享数组的效果\",{\"1\":{\"133\":1}}],[\"从而提高死锁检测的效率\",{\"1\":{\"263\":1}}],[\"从而提高数据库的查询效率\",{\"1\":{\"165\":1}}],[\"从而提高插入操作的效率\",{\"1\":{\"129\":1}}],[\"从而提高系统的整体性能\",{\"1\":{\"96\":1}}],[\"从而加速了插入操作的执行\",{\"1\":{\"112\":1}}],[\"从而在插入数据时\",{\"1\":{\"111\":1}}],[\"从而避免了阻塞\",{\"1\":{\"298\":1}}],[\"从而避免了所有的并发问题\",{\"1\":{\"289\":1}}],[\"从而避免死锁或资源饥饿\",{\"1\":{\"264\":1}}],[\"从而避免数据不一致的问题\",{\"1\":{\"87\":1}}],[\"从而避免这种问题\",{\"1\":{\"87\":1}}],[\"从而确保数据的一致性\",{\"1\":{\"273\":1}}],[\"从而确保数据的一致性和完整性\",{\"1\":{\"78\":1}}],[\"从而确保事务的一致性和数据的完整性\",{\"1\":{\"9\":1,\"176\":1}}],[\"从日志中读取校验和\",{\"1\":{\"83\":1}}],[\"从已有文件打开\",{\"1\":{\"73\":1}}],[\"从空文件创建\",{\"1\":{\"73\":1}}],[\"从计算出的区间编号开始\",{\"1\":{\"72\":1}}],[\"从页面索引中选择一个可以容纳新数据项的页面\",{\"1\":{\"72\":1}}],[\"从缓存页面中读取到dataitemimpl\",{\"1\":{\"72\":1}}],[\"从缓存中释放\",{\"1\":{\"309\":1}}],[\"从缓存中获取\",{\"1\":{\"72\":1}}],[\"从缓存中获取资源\",{\"1\":{\"57\":1,\"58\":1}}],[\"从缓存中移除资源\",{\"1\":{\"58\":1}}],[\"从\",{\"1\":{\"69\":2,\"70\":3,\"87\":2,\"235\":1}}],[\"从引用计数的映射中移除资源\",{\"1\":{\"58\":1}}],[\"从数据源获取资源\",{\"1\":{\"53\":1}}],[\"从磁盘读取数据并加载到内存\",{\"1\":{\"51\":1}}],[\"从持久化存储\",{\"1\":{\"51\":1}}],[\"回滚\",{\"1\":{\"309\":1}}],[\"回滚以及状态检查\",{\"1\":{\"251\":1}}],[\"回滚以及事务状态的检查和管理\",{\"1\":{\"231\":1}}],[\"回滚修改\",{\"1\":{\"66\":1}}],[\"回滚事务意味着\",{\"1\":{\"267\":1}}],[\"回滚事务\",{\"0\":{\"267\":1},\"1\":{\"23\":1}}],[\"回源操作的管理通过以下流程实现\",{\"1\":{\"53\":1}}],[\"回源操作指的是当需要的数据不在内存缓存中时\",{\"1\":{\"51\":1}}],[\"回源\",{\"0\":{\"51\":1}}],[\"尤其是在涉及回源操作时\",{\"1\":{\"50\":1}}],[\"但要注意\",{\"1\":{\"298\":1}}],[\"但由于\",{\"1\":{\"297\":1}}],[\"但由于隔离级别的原因\",{\"1\":{\"291\":1}}],[\"但ti在开始之前并不能看到tj的修改\",{\"1\":{\"292\":1}}],[\"但该删除操作尚未提交\",{\"1\":{\"286\":1}}],[\"但性能开销较大\",{\"1\":{\"276\":1}}],[\"但可能出现\",{\"1\":{\"276\":2}}],[\"但可以通过\",{\"1\":{\"148\":1}}],[\"但它在确保数据的唯一性和加快查询速度方面起到了关键作用\",{\"1\":{\"222\":1}}],[\"但是会存在多个字段使用同一个索引的问题\",{\"1\":{\"160\":1}}],[\"但是25\",{\"1\":{\"72\":1}}],[\"但我设计了隐藏字段以及主键\",{\"1\":{\"155\":1}}],[\"但这并不是理想状态\",{\"1\":{\"147\":1}}],[\"但\",{\"1\":{\"147\":1}}],[\"但通过定义子数组的方式\",{\"1\":{\"138\":1}}],[\"但在实际实现中\",{\"1\":{\"301\":1}}],[\"但在\",{\"1\":{\"129\":1,\"298\":1}}],[\"但在某些情况下\",{\"1\":{\"50\":1}}],[\"但至关重要\",{\"1\":{\"122\":1}}],[\"但如果顺序相反\",{\"1\":{\"87\":1}}],[\"但如果需要\",{\"1\":{\"30\":1}}],[\"最终可能导致死锁\",{\"1\":{\"297\":1}}],[\"最终\",{\"1\":{\"297\":1}}],[\"最后把这个信息写入你的任务清单中\",{\"1\":{\"245\":1}}],[\"最后一个键值始终为\",{\"1\":{\"143\":1}}],[\"最后更新fso\",{\"1\":{\"126\":1}}],[\"最后\",{\"1\":{\"100\":1}}],[\"最近最少使用\",{\"1\":{\"50\":1}}],[\"最大用户限制\",{\"1\":{\"46\":1}}],[\"传统的\",{\"1\":{\"50\":1}}],[\"引起的事务阻塞\",{\"1\":{\"298\":1}}],[\"引起了我的极大兴趣\",{\"1\":{\"4\":1,\"171\":1}}],[\"引入\",{\"1\":{\"160\":1}}],[\"引入了以下两条规则\",{\"1\":{\"87\":1}}],[\"引用页面缓存\",{\"1\":{\"97\":1}}],[\"引用计数移除缓存\",{\"1\":{\"59\":1}}],[\"引用计数管理\",{\"0\":{\"56\":1}}],[\"引用计数策略通过引用计数的管理\",{\"1\":{\"52\":1}}],[\"引用计数策略通过以下方式优化了回源操作\",{\"1\":{\"52\":1}}],[\"引用计数策略的优势\",{\"0\":{\"52\":1}}],[\"引用计数策略可能更为有效\",{\"1\":{\"50\":1}}],[\"引用计数缓存框架结合了灵活的资源管理和有效的回源策略\",{\"1\":{\"60\":1}}],[\"引用计数缓存框架的核心是\",{\"1\":{\"55\":1}}],[\"引用计数缓存框架的实现\",{\"0\":{\"54\":1}}],[\"引用计数缓存框架会安全地释放所有资源\",{\"1\":{\"53\":1}}],[\"引用计数缓存框架\",{\"0\":{\"49\":1,\"50\":1},\"1\":{\"129\":1},\"2\":{\"62\":1,\"131\":1}}],[\"当记录被删除时\",{\"1\":{\"305\":1}}],[\"当创建新版本时\",{\"1\":{\"303\":1}}],[\"当多个事务同时争夺同一资源时\",{\"1\":{\"297\":1}}],[\"当以下三个条件同时满足时\",{\"1\":{\"297\":1}}],[\"当隔离级别等于可重复读和串行化时需要创建快照\",{\"1\":{\"290\":1}}],[\"当某个事务对数据进行修改时\",{\"1\":{\"274\":1}}],[\"当事务请求资源时\",{\"1\":{\"269\":1}}],[\"当检测到事务等待超时后\",{\"1\":{\"264\":1}}],[\"当一个事务想要操作某个数据项时\",{\"1\":{\"297\":1}}],[\"当一个事务\",{\"1\":{\"268\":1,\"274\":1}}],[\"当一个事务请求获取某个资源时\",{\"1\":{\"260\":1}}],[\"当一个任务完成时\",{\"1\":{\"246\":1}}],[\"当你在任务清单上新增一个任务时\",{\"1\":{\"245\":1}}],[\"当你执行类似的\",{\"1\":{\"133\":1}}],[\"当我们调用\",{\"1\":{\"219\":1}}],[\"当我们修改了原数组中的某个元素后\",{\"1\":{\"137\":1}}],[\"当\",{\"1\":{\"167\":1}}],[\"当where条件为空时\",{\"1\":{\"155\":1}}],[\"当前事务就必须等待\",{\"1\":{\"297\":1}}],[\"当前事务创建且尚未删除的版本是可见的\",{\"1\":{\"289\":1}}],[\"当前事务创建且未删除的数据版本是可见的\",{\"1\":{\"286\":1,\"288\":1}}],[\"当前版本的数据是由当前事务\",{\"1\":{\"286\":1,\"288\":1}}],[\"当前区间没有可用页面\",{\"1\":{\"114\":1}}],[\"当前线程会稍后再试\",{\"1\":{\"53\":1}}],[\"当进行插入操作时\",{\"1\":{\"112\":1}}],[\"当页面不再需要时\",{\"1\":{\"105\":1}}],[\"当页面缓存决定驱逐某个页面时\",{\"1\":{\"100\":1}}],[\"当打开一个日志文件时\",{\"1\":{\"82\":1}}],[\"当需要获取资源时\",{\"1\":{\"57\":1}}],[\"当需要访问的数据不在缓存中时\",{\"1\":{\"51\":1}}],[\"当资源被驱逐时的写回行为\",{\"1\":{\"55\":1}}],[\"当资源不在缓存时的获取行为\",{\"1\":{\"55\":1}}],[\"当上层模块不再需要某个资源时\",{\"1\":{\"53\":1,\"58\":1}}],[\"当系统需要的数据不在缓存中时\",{\"1\":{\"53\":1}}],[\"当用户会话结束时\",{\"1\":{\"46\":1}}],[\"当有请求到来时\",{\"1\":{\"36\":1}}],[\"26\",{\"1\":{\"72\":1}}],[\"2字节\",{\"1\":{\"72\":1}}],[\"2\",{\"1\":{\"46\":1,\"65\":1,\"69\":1,\"72\":1,\"87\":5,\"116\":1,\"123\":1,\"125\":1,\"137\":1,\"144\":1,\"240\":1,\"297\":1,\"298\":1}}],[\"204=5304\",{\"1\":{\"72\":1}}],[\"204=5100显然是不满足条件的\",{\"1\":{\"72\":1}}],[\"20\",{\"1\":{\"46\":1}}],[\"2pl\",{\"0\":{\"273\":1,\"296\":1,\"297\":1},\"1\":{\"2\":1,\"273\":4,\"295\":1,\"297\":3,\"298\":2}}],[\"与并发控制\",{\"0\":{\"273\":1}}],[\"与已经持久化到磁盘的抽象页面有一定的区别\",{\"1\":{\"96\":1}}],[\"与\",{\"0\":{\"46\":1,\"296\":1}}],[\"与数据库进行交互\",{\"1\":{\"17\":1,\"184\":1}}],[\"x2\",{\"1\":{\"298\":1}}],[\"x2u\",{\"1\":{\"259\":1,\"260\":2,\"262\":1,\"267\":1,\"268\":2}}],[\"x3\",{\"1\":{\"298\":1}}],[\"xmin记录了创建版本的事务编号\",{\"1\":{\"285\":1}}],[\"xmin和xmax\",{\"1\":{\"285\":1}}],[\"xmin\",{\"1\":{\"275\":2,\"286\":8,\"288\":16,\"289\":5,\"300\":2,\"301\":3,\"303\":3,\"304\":2}}],[\"xmax记录了删除版本的事务编号\",{\"1\":{\"285\":1}}],[\"xmax\",{\"1\":{\"148\":1,\"275\":2,\"284\":2,\"286\":16,\"288\":24,\"289\":7,\"292\":4,\"300\":2,\"301\":3,\"303\":4,\"304\":2,\"305\":3}}],[\"xi\",{\"1\":{\"90\":2,\"91\":2,\"92\":8}}],[\"xidstamp\",{\"1\":{\"259\":1,\"262\":4}}],[\"xidcounter++\",{\"1\":{\"247\":1}}],[\"xidcounter\",{\"1\":{\"242\":2,\"245\":1,\"247\":1,\"251\":1}}],[\"xid文件的校验与读取\",{\"0\":{\"241\":1}}],[\"xid文件后缀\",{\"1\":{\"240\":1}}],[\"xid文件头长度\",{\"1\":{\"240\":1}}],[\"xid文件结构以及规则\",{\"0\":{\"234\":1}}],[\"xidtablecache\",{\"1\":{\"226\":2,\"228\":3}}],[\"xidraw\",{\"1\":{\"72\":2}}],[\"xid\",{\"0\":{\"235\":1,\"237\":1},\"1\":{\"9\":1,\"66\":2,\"72\":4,\"89\":2,\"90\":6,\"91\":12,\"146\":3,\"154\":4,\"157\":2,\"176\":1,\"219\":4,\"220\":2,\"221\":2,\"222\":1,\"226\":8,\"228\":5,\"231\":1,\"234\":4,\"235\":3,\"237\":7,\"238\":10,\"240\":5,\"242\":4,\"243\":4,\"245\":4,\"246\":3,\"249\":5,\"251\":10,\"260\":10,\"262\":13,\"266\":2,\"267\":6,\"268\":10,\"286\":4,\"288\":6,\"289\":6,\"290\":8,\"292\":2,\"303\":2,\"305\":3,\"309\":5,\"311\":4,\"312\":6,\"313\":7,\"314\":2,\"315\":4,\"316\":7}}],[\"xcheck\",{\"1\":{\"80\":4,\"82\":4}}],[\"xchecksum\",{\"1\":{\"79\":2,\"81\":5,\"82\":3,\"83\":3}}],[\"x\",{\"1\":{\"45\":1,\"85\":2,\"86\":7,\"87\":6,\"262\":3,\"274\":2,\"290\":2,\"297\":11,\"298\":4}}],[\"拦截握手请求\",{\"1\":{\"45\":1}}],[\"请求锁定\",{\"1\":{\"256\":5}}],[\"请求锁定资源\",{\"1\":{\"256\":2}}],[\"请求头信息\",{\"1\":{\"45\":1}}],[\"请求或使用\",{\"1\":{\"13\":1,\"180\":1}}],[\"地址\",{\"1\":{\"45\":3}}],[\"地址为每个用户创建一个独立的数据库文件目录\",{\"1\":{\"44\":1}}],[\"握手阶段添加自定义逻辑\",{\"1\":{\"45\":1}}],[\"握手阶段获取客户端的\",{\"1\":{\"45\":1}}],[\"握手拦截器\",{\"0\":{\"45\":1}}],[\"$\",{\"1\":{\"43\":1,\"46\":1,\"199\":1}}],[\"保证系统的稳定性和一致性\",{\"1\":{\"317\":1}}],[\"保证事务只能读取已经提交的数据版本\",{\"1\":{\"285\":1}}],[\"保证了调度序列的可串行化\",{\"1\":{\"273\":1}}],[\"保证了数据的一致性\",{\"1\":{\"129\":1}}],[\"保证\",{\"1\":{\"87\":2}}],[\"保证并发操作的独立性\",{\"1\":{\"43\":1}}],[\"保证数据的一致性\",{\"1\":{\"9\":1,\"176\":1}}],[\"会被设置为删除该记录的事务\",{\"1\":{\"305\":1}}],[\"会被作为\",{\"1\":{\"303\":1}}],[\"会被阻塞\",{\"1\":{\"298\":1}}],[\"会被撤销\",{\"1\":{\"147\":1}}],[\"会为这条记录创建一个新版本\",{\"1\":{\"298\":1}}],[\"会动态构建一个等待图\",{\"1\":{\"278\":1}}],[\"会检查最新版本的创建者对当前事务是否可见\",{\"1\":{\"277\":1}}],[\"会检查资源是否被其他事务占用\",{\"1\":{\"269\":1}}],[\"会释放该事务持有的资源\",{\"1\":{\"269\":1}}],[\"会释放该事务持有的所有资源锁\",{\"1\":{\"268\":1}}],[\"会执行死锁检测\",{\"1\":{\"269\":1}}],[\"会造成类型转换异常\",{\"1\":{\"160\":1}}],[\"会话\",{\"1\":{\"46\":1}}],[\"会话管理\",{\"1\":{\"46\":1}}],[\"会话的属性中\",{\"1\":{\"45\":1}}],[\"会话的唯一标识符\",{\"1\":{\"43\":1}}],[\"会话都有一个独立的线程池\",{\"1\":{\"43\":1}}],[\"会启动一个新线程处理请求\",{\"1\":{\"36\":1}}],[\"线程池管理\",{\"1\":{\"43\":1}}],[\"命令选择相应的处理方法\",{\"1\":{\"43\":1}}],[\"命令解析与执行\",{\"1\":{\"43\":1}}],[\"命令\",{\"1\":{\"43\":2}}],[\"命令并返回执行结果\",{\"1\":{\"42\":1}}],[\"命令并实时获取结果\",{\"1\":{\"41\":1}}],[\"命令并即时接收结果\",{\"1\":{\"26\":1}}],[\"消息的核心类\",{\"1\":{\"43\":1}}],[\"消除读写阻塞\",{\"1\":{\"9\":1,\"176\":1,\"295\":1}}],[\"是最高级别的事务隔离\",{\"1\":{\"289\":1}}],[\"是最低级别的事务隔离级别\",{\"1\":{\"284\":1}}],[\"是可见的\",{\"1\":{\"286\":1,\"288\":1}}],[\"是通过维护\",{\"1\":{\"234\":1}}],[\"是否必须唯一\",{\"1\":{\"220\":1}}],[\"是否允许为空\",{\"1\":{\"218\":1}}],[\"是否有效\",{\"1\":{\"65\":1}}],[\"是解析\",{\"1\":{\"195\":1}}],[\"是\",{\"1\":{\"142\":1,\"166\":1,\"274\":1,\"295\":2}}],[\"是用于实际存储数据的页面\",{\"1\":{\"124\":1}}],[\"是数据存储和管理的基本单位\",{\"1\":{\"121\":1}}],[\"是数据库中存储数据的基本单元\",{\"1\":{\"97\":1}}],[\"是数据库系统中数据管理的关键组件\",{\"1\":{\"74\":1}}],[\"是数据库系统中的核心组件\",{\"1\":{\"67\":1}}],[\"是数据库系统中的数据抽象层\",{\"1\":{\"64\":1}}],[\"是因崩溃而未能完整写入的日志数据\",{\"1\":{\"82\":1}}],[\"是对后续所有日志计算的校验和\",{\"1\":{\"79\":1}}],[\"是满足插入条件的\",{\"1\":{\"72\":1}}],[\"是由页面编号\",{\"1\":{\"69\":1}}],[\"是由页号和页内偏移组成的一个\",{\"1\":{\"67\":1,\"72\":1}}],[\"是处理\",{\"1\":{\"43\":1}}],[\"是一种较为常用的事务隔离级别\",{\"1\":{\"285\":1}}],[\"是一种全双工通信协议\",{\"1\":{\"42\":1}}],[\"是一个用于管理事务锁的类\",{\"1\":{\"258\":1}}],[\"是一个至关重要的模块\",{\"1\":{\"231\":1}}],[\"是一个强大的\",{\"1\":{\"194\":1}}],[\"是一个\",{\"1\":{\"68\":1}}],[\"是一个基于\",{\"1\":{\"29\":1}}],[\"是一个轻量级的数据库系统\",{\"1\":{\"26\":1}}],[\"是一个轻量级\",{\"1\":{\"1\":1}}],[\"处理超时等待\",{\"1\":{\"258\":1}}],[\"处理主键\",{\"1\":{\"219\":1}}],[\"处理事务隔离级别的解析\",{\"1\":{\"203\":1}}],[\"处理事务语句\",{\"0\":{\"203\":1}}],[\"处理事务控制语句\",{\"1\":{\"196\":1}}],[\"处理\",{\"1\":{\"196\":1,\"198\":2}}],[\"处理异常\",{\"1\":{\"116\":1,\"189\":1,\"190\":1,\"191\":3}}],[\"处理资源的释放\",{\"1\":{\"58\":1}}],[\"处理器\",{\"0\":{\"43\":1}}],[\"处理完成后\",{\"1\":{\"6\":1,\"173\":1}}],[\"用来保存事务开始时的快照数据\",{\"1\":{\"290\":1}}],[\"用来松散地规定数组的可使用范围\",{\"1\":{\"129\":1}}],[\"用于标记记录的删除状态\",{\"1\":{\"305\":1}}],[\"用于存储活跃事务的id\",{\"1\":{\"290\":1}}],[\"用于优化死锁检测时的dfs\",{\"1\":{\"259\":1}}],[\"用于死锁检测中的标记\",{\"1\":{\"259\":1}}],[\"用于记录这个\",{\"1\":{\"237\":1}}],[\"用于记录各个事务的状态\",{\"1\":{\"237\":1}}],[\"用于保证\",{\"1\":{\"259\":1}}],[\"用于保证页面操作的线程安全\",{\"1\":{\"97\":1}}],[\"用于保存其状态\",{\"1\":{\"237\":1}}],[\"用于表示在没有申请事务的情况下进行的操作\",{\"1\":{\"235\":1}}],[\"用于确保多线程环境下的操作安全\",{\"1\":{\"226\":1}}],[\"用于管理数据库的启动信息\",{\"1\":{\"226\":1}}],[\"用于管理数据库表\",{\"1\":{\"216\":1}}],[\"用于处理事务和数据的版本控制\",{\"1\":{\"226\":1}}],[\"用于处理该会话的\",{\"1\":{\"43\":1}}],[\"用于索引字段值\",{\"1\":{\"217\":1}}],[\"用于加快查询速度\",{\"1\":{\"217\":1}}],[\"用于解析\",{\"1\":{\"194\":1}}],[\"用于后续的查询优化\",{\"1\":{\"156\":1}}],[\"用于辅助\",{\"1\":{\"145\":1}}],[\"用于方便快速修改和释放数据\",{\"1\":{\"143\":1}}],[\"用于从文件中读取页面数据\",{\"1\":{\"99\":1}}],[\"用于读取完整的日志\",{\"1\":{\"83\":1}}],[\"用于读取日志的大小\",{\"1\":{\"83\":1}}],[\"用于创建插入日志\",{\"1\":{\"72\":1}}],[\"用于在驱逐页面时根据页面是否为脏页面\",{\"1\":{\"99\":1}}],[\"用于在缓存未命中时获取资源和在资源被驱逐时进行必要的处理\",{\"1\":{\"55\":1}}],[\"用于在\",{\"1\":{\"45\":1}}],[\"用于接收客户端的\",{\"1\":{\"42\":1}}],[\"用户id\",{\"1\":{\"219\":1}}],[\"用户名\",{\"1\":{\"217\":1,\"219\":1}}],[\"用户表\",{\"1\":{\"216\":1}}],[\"用户会话管理\",{\"0\":{\"46\":1},\"1\":{\"41\":1}}],[\"用户可以快速掌握数据库的基础操作\",{\"1\":{\"24\":1}}],[\"用户可以在此输入类\",{\"1\":{\"14\":1,\"181\":1}}],[\"用户可以方便地与数据库进行交互\",{\"1\":{\"6\":1,\"173\":1}}],[\"双向的数据交换\",{\"1\":{\"42\":1}}],[\"整个实现涵盖了\",{\"1\":{\"41\":1}}],[\"整体结构\",{\"0\":{\"5\":1,\"172\":1}}],[\"连接成一个新的字节数组\",{\"1\":{\"83\":1}}],[\"连接到服务器\",{\"1\":{\"37\":1,\"41\":1}}],[\"连接服务器\",{\"1\":{\"26\":1}}],[\"结语\",{\"0\":{\"148\":1}}],[\"结合在一起\",{\"1\":{\"34\":1}}],[\"结构中包含一个指向\",{\"1\":{\"301\":1}}],[\"结构如下\",{\"1\":{\"72\":1}}],[\"结构数据\",{\"1\":{\"72\":2}}],[\"结构\",{\"0\":{\"301\":1},\"1\":{\"29\":1}}],[\"header\",{\"1\":{\"240\":1,\"242\":2,\"243\":1,\"247\":1,\"251\":1}}],[\"hex\",{\"1\":{\"33\":2}}],[\"hexdecode\",{\"1\":{\"33\":2}}],[\"hexencode\",{\"1\":{\"33\":2}}],[\"has\",{\"1\":{\"267\":1}}],[\"hasnext\",{\"1\":{\"266\":1}}],[\"hascycle\",{\"1\":{\"262\":3}}],[\"hasdeadlock\",{\"1\":{\"260\":1,\"262\":1}}],[\"hashset<>\",{\"1\":{\"154\":3,\"219\":3}}],[\"hashmap<long\",{\"1\":{\"56\":3}}],[\"hashmap<>\",{\"1\":{\"46\":1,\"91\":1,\"226\":2,\"262\":2,\"290\":1}}],[\"hashmap\",{\"1\":{\"53\":1,\"56\":1}}],[\"hasactivesessions\",{\"1\":{\"46\":1}}],[\"handshakeinterceptor\",{\"1\":{\"45\":1}}],[\"handlesqlcommand\",{\"1\":{\"43\":1}}],[\"handlesocket\",{\"1\":{\"36\":1}}],[\"handleinitcommand\",{\"1\":{\"43\":1,\"44\":2}}],[\"handletextmessage\",{\"1\":{\"43\":1}}],[\"html\",{\"1\":{\"13\":1,\"180\":1}}],[\"http\",{\"1\":{\"13\":2,\"24\":1,\"45\":1,\"180\":2}}],[\"httpservletrequest\",{\"1\":{\"45\":2}}],[\"httpsessionhandshakeinterceptor\",{\"1\":{\"45\":2}}],[\"https\",{\"1\":{\"3\":4,\"13\":1,\"17\":1,\"24\":1,\"37\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"170\":4,\"180\":1,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"one\",{\"1\":{\"196\":1}}],[\"operation\",{\"1\":{\"158\":1,\"159\":1}}],[\"open\",{\"1\":{\"14\":1,\"16\":1,\"73\":4,\"181\":1,\"183\":1,\"189\":2}}],[\"orderbyexpression\",{\"1\":{\"198\":4}}],[\"orderbyelement\",{\"1\":{\"198\":3}}],[\"orderfield\",{\"1\":{\"198\":2}}],[\"orderfields\",{\"1\":{\"198\":3}}],[\"orderascfields\",{\"1\":{\"198\":3}}],[\"order\",{\"1\":{\"198\":5}}],[\"or\",{\"1\":{\"158\":1,\"286\":3,\"288\":7}}],[\"orelse\",{\"1\":{\"156\":1,\"160\":1}}],[\"original\",{\"1\":{\"136\":1,\"137\":1}}],[\"out\",{\"1\":{\"136\":6,\"191\":3,\"267\":2,\"312\":2},\"2\":{\"271\":1}}],[\"outputstreamwriter\",{\"1\":{\"33\":1}}],[\"oldb\",{\"1\":{\"86\":3}}],[\"oldx\",{\"1\":{\"85\":2,\"86\":3}}],[\"oldraw\",{\"1\":{\"65\":1,\"66\":4,\"89\":1,\"92\":1}}],[\"ofdata\",{\"1\":{\"125\":2}}],[\"offsetraw\",{\"1\":{\"72\":2}}],[\"offset\",{\"1\":{\"69\":7,\"70\":4,\"72\":6,\"89\":1,\"92\":7,\"100\":2,\"104\":2,\"106\":6,\"126\":4,\"246\":2,\"249\":2}}],[\"of\",{\"1\":{\"66\":1,\"83\":9,\"123\":7,\"125\":2,\"196\":1,\"301\":5,\"304\":2,\"305\":1}}],[\"object\",{\"1\":{\"159\":2,\"160\":1,\"196\":1}}],[\"object>\",{\"1\":{\"45\":1,\"157\":1,\"158\":1,\"159\":1,\"221\":2}}],[\"obj\",{\"1\":{\"55\":1,\"57\":6,\"58\":2,\"59\":2}}],[\"o\",{\"1\":{\"51\":1,\"52\":1,\"96\":1,\"107\":1}}],[\"override\",{\"1\":{\"43\":1,\"45\":2,\"46\":2,\"66\":5,\"70\":1,\"71\":1,\"72\":3,\"83\":2,\"100\":1,\"104\":1,\"105\":1,\"198\":1,\"199\":1,\"228\":1,\"309\":2,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1}}],[\"<=\",{\"1\":{\"72\":1,\"114\":1,\"116\":1,\"136\":1,\"145\":1,\"159\":2}}],[\"<<\",{\"1\":{\"69\":3,\"70\":2}}],[\"<\",{\"1\":{\"32\":1,\"72\":2,\"106\":1,\"114\":1,\"136\":1,\"145\":4,\"159\":2,\"219\":1,\"242\":1,\"262\":1,\"288\":4,\"289\":1}}],[\"<isolation\",{\"1\":{\"23\":1}}],[\"0并转换成四字节的数字\",{\"1\":{\"81\":1}}],[\"0为合法\",{\"1\":{\"72\":1}}],[\"0xffff\",{\"1\":{\"69\":1}}],[\"0来演示生成和解析\",{\"1\":{\"69\":1}}],[\"0\",{\"1\":{\"31\":1,\"32\":4,\"37\":2,\"45\":10,\"46\":1,\"57\":1,\"58\":1,\"65\":1,\"66\":2,\"72\":5,\"81\":4,\"82\":2,\"83\":3,\"87\":2,\"89\":1,\"91\":1,\"106\":2,\"114\":2,\"123\":1,\"125\":2,\"126\":1,\"136\":1,\"144\":7,\"145\":5,\"146\":1,\"155\":1,\"159\":6,\"198\":3,\"199\":2,\"200\":2,\"202\":7,\"203\":1,\"217\":1,\"219\":1,\"220\":1,\"227\":1,\"235\":1,\"237\":1,\"240\":2,\"242\":2,\"246\":1,\"247\":1,\"249\":1,\"262\":2,\"268\":6,\"284\":1,\"286\":2,\"288\":2,\"289\":2,\"297\":3,\"301\":1,\"304\":1,\"305\":1}}],[\"0许可协议\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"编号加一\",{\"1\":{\"72\":1}}],[\"编码和解码的规则如下\",{\"1\":{\"31\":1}}],[\"编译完成后\",{\"1\":{\"14\":1,\"181\":1}}],[\"同样会通过\",{\"1\":{\"31\":1}}],[\"同时支持多种事务隔离级别\",{\"1\":{\"295\":1}}],[\"同时确保版本的正确性\",{\"1\":{\"316\":1}}],[\"同时确保了事务的隔离性和数据的一致性\",{\"1\":{\"274\":1}}],[\"同时确保新表的正确创建和缓存更新\",{\"1\":{\"228\":1}}],[\"同时通过\",{\"1\":{\"251\":1,\"272\":1}}],[\"同时讲解如何处理字段的各种约束条件\",{\"1\":{\"214\":1}}],[\"同时保证数据的一致性和可靠性\",{\"1\":{\"107\":1}}],[\"同时也实现了对\",{\"1\":{\"67\":1}}],[\"同时也注意到一些可以进一步优化和扩展的地方\",{\"1\":{\"4\":1,\"171\":1}}],[\"同时\",{\"1\":{\"46\":1,\"129\":1}}],[\"同时提供相应的缓存机制\",{\"1\":{\"9\":1,\"176\":1}}],[\"实例\",{\"1\":{\"136\":1,\"301\":2}}],[\"实例会通过\",{\"1\":{\"31\":1}}],[\"实际上是共享了同一片内存\",{\"1\":{\"136\":1}}],[\"实际缓存移除缓存\",{\"1\":{\"59\":1}}],[\"实际缓存的数据\",{\"1\":{\"56\":1}}],[\"实际应用中的回源与缓存管理\",{\"0\":{\"53\":1}}],[\"实现了多版本并发控制\",{\"1\":{\"298\":1}}],[\"实现了调度序列的可串行化\",{\"1\":{\"295\":1}}],[\"实现了四种常见的事务隔离级别\",{\"1\":{\"283\":1}}],[\"实现了事务的并发控制\",{\"1\":{\"273\":1}}],[\"实现了不同事务之间的隔离\",{\"1\":{\"272\":1}}],[\"实现了基于深度优先搜索\",{\"1\":{\"261\":1}}],[\"实现了数据一致性保障\",{\"1\":{\"2\":1}}],[\"实现示例\",{\"1\":{\"216\":1,\"217\":1}}],[\"实现\",{\"1\":{\"142\":1,\"166\":1,\"222\":1}}],[\"实现内存共享\",{\"1\":{\"133\":1}}],[\"实现数据的高效管理和安全恢复\",{\"1\":{\"129\":1}}],[\"实现数据库\",{\"1\":{\"1\":1}}],[\"实现实时的数据库通信管理\",{\"1\":{\"26\":1}}],[\"核心类的实现以及服务器与客户端的工作原理\",{\"1\":{\"29\":1}}],[\"核心功能指南\",{\"0\":{\"20\":1}}],[\"核心功能与主要特性\",{\"0\":{\"2\":1}}],[\"服务器通过\",{\"1\":{\"36\":1}}],[\"服务器实现\",{\"0\":{\"36\":1}}],[\"服务器与客户端实现\",{\"0\":{\"35\":1}}],[\"服务端与客户端通信协议\",{\"0\":{\"29\":1}}],[\"服务进行处理\",{\"1\":{\"13\":1,\"180\":1}}],[\"技术来构建一个具有高实时性和可扩展性的数据库系统\",{\"1\":{\"26\":1}}],[\"您将全面了解如何使用\",{\"1\":{\"26\":1}}],[\"涵盖了从编码解码到服务器与客户端的整个工作流程\",{\"1\":{\"26\":1}}],[\"第一个表的uid\",{\"1\":{\"227\":1}}],[\"第一页的校验机制确保了数据库在启动时能够检测并处理未正常关闭的情况\",{\"1\":{\"126\":1}}],[\"第一页的作用非常简单\",{\"1\":{\"122\":1}}],[\"第一页的特殊用途\",{\"0\":{\"122\":1}}],[\"第一部分将讲解如何通过\",{\"1\":{\"26\":1}}],[\"第二部分则聚焦于\",{\"1\":{\"26\":1}}],[\"架构\",{\"1\":{\"26\":1}}],[\"采用了两段锁协议\",{\"1\":{\"297\":1}}],[\"采用了引用计数策略\",{\"1\":{\"52\":1}}],[\"采用\",{\"1\":{\"26\":1}}],[\"通知等待该事务的其他线程\",{\"1\":{\"267\":1}}],[\"通知其他等待的事务资源已经可用\",{\"1\":{\"267\":1}}],[\"通常用于主键字段\",{\"1\":{\"218\":1}}],[\"通信基础\",{\"0\":{\"42\":1}}],[\"通信\",{\"1\":{\"41\":1}}],[\"通信与数据库管理系统整合教程\",{\"0\":{\"41\":1}}],[\"通信与服务器进行交互\",{\"1\":{\"26\":1}}],[\"通信的基本结构是\",{\"1\":{\"30\":1}}],[\"通信机制\",{\"0\":{\"30\":1}}],[\"通信连接到服务器\",{\"1\":{\"29\":1}}],[\"通信规则\",{\"0\":{\"25\":1}}],[\"通过可见性判断确保事务读取到的数据是符合隔离级别要求的\",{\"1\":{\"317\":1}}],[\"通过锁机制确保了并发事务的正确性\",{\"1\":{\"317\":1}}],[\"通过事务的快照机制实现这一点\",{\"1\":{\"287\":1}}],[\"通过两段锁协议\",{\"1\":{\"280\":1}}],[\"通过管理这些版本\",{\"1\":{\"275\":1}}],[\"通过后台线程定期检查每个事务的等待时间\",{\"1\":{\"264\":1}}],[\"通过引入\",{\"1\":{\"263\":1}}],[\"通过引用计数\",{\"1\":{\"60\":1}}],[\"通过遍历事务依赖图\",{\"1\":{\"261\":1}}],[\"通过读取文件头的\",{\"1\":{\"242\":1}}],[\"通过uid加载表对象\",{\"1\":{\"227\":1}}],[\"通过将更新数据写入临时文件\",{\"1\":{\"208\":1}}],[\"通过将页面数据保存在内存中\",{\"1\":{\"96\":1}}],[\"通过将页面编号\",{\"1\":{\"69\":1}}],[\"通过对begin\",{\"1\":{\"210\":1}}],[\"通过对索引管理与全表扫描的深入解析\",{\"1\":{\"167\":1}}],[\"通过对\",{\"1\":{\"167\":1}}],[\"通过对日志的管理和恢复规则的严格遵守\",{\"1\":{\"92\":1}}],[\"通过上述优化实现\",{\"1\":{\"317\":1}}],[\"通过上述实现\",{\"1\":{\"161\":1}}],[\"通过上述设计与实现\",{\"1\":{\"148\":1}}],[\"通过所有uid进行过滤\",{\"1\":{\"157\":1}}],[\"通过这一系列操作\",{\"1\":{\"269\":1}}],[\"通过这个清单\",{\"1\":{\"234\":1}}],[\"通过这个简单的\",{\"1\":{\"138\":1}}],[\"通过这个类\",{\"1\":{\"134\":1}}],[\"通过这种方式\",{\"1\":{\"136\":1,\"273\":1,\"298\":1}}],[\"通过这些隔离级别\",{\"1\":{\"276\":1}}],[\"通过这些元数据\",{\"1\":{\"275\":1}}],[\"通过这些内容的讲解\",{\"1\":{\"207\":1}}],[\"通过这些实现\",{\"1\":{\"167\":1}}],[\"通过这些功能的实现\",{\"1\":{\"74\":1}}],[\"通过这些方法\",{\"1\":{\"68\":1}}],[\"通过这些改进\",{\"1\":{\"4\":1,\"171\":1}}],[\"通过具体的代码示例\",{\"1\":{\"129\":1}}],[\"通过分页管理来有效组织和访问数据库文件\",{\"1\":{\"129\":1}}],[\"通过以上机制\",{\"1\":{\"126\":1}}],[\"通过实现\",{\"1\":{\"117\":1}}],[\"通过实现两阶段锁协议\",{\"1\":{\"9\":1,\"176\":1}}],[\"通过页面缓存机制\",{\"1\":{\"107\":1}}],[\"通过页面索引\",{\"1\":{\"68\":1}}],[\"通过前面的内容我们已经实现了一个通用的缓存框架\",{\"1\":{\"96\":1}}],[\"通过前端客户端进行交互\",{\"1\":{\"13\":1,\"180\":1}}],[\"通过规则\",{\"1\":{\"87\":2}}],[\"通过计算日志文件的校验和来确保日志数据的完整性\",{\"1\":{\"80\":1}}],[\"通过与\",{\"1\":{\"69\":1}}],[\"通过缓存机制\",{\"1\":{\"279\":1}}],[\"通过缓存\",{\"1\":{\"68\":1}}],[\"通过调用\",{\"1\":{\"53\":1,\"251\":1}}],[\"通过解析\",{\"1\":{\"45\":1}}],[\"通过本文\",{\"1\":{\"26\":1}}],[\"通过本使用文档\",{\"1\":{\"24\":1}}],[\"通过维护\",{\"1\":{\"9\":1,\"176\":1}}],[\"通过拓扑排序可以清晰地看到各个模块的实现顺序\",{\"1\":{\"8\":1,\"175\":1}}],[\"通过二哥星球得知了\",{\"1\":{\"4\":1,\"171\":1}}],[\"通过详细的日志记录\",{\"1\":{\"2\":1}}],[\"通过\",{\"0\":{\"15\":1,\"182\":1},\"1\":{\"2\":1,\"26\":1,\"46\":1,\"58\":1,\"83\":1,\"107\":1,\"251\":1,\"269\":1,\"298\":1}}],[\"通过简洁的配置\",{\"1\":{\"2\":1}}],[\"体验地址\",{\"1\":{\"24\":1}}],[\"串行化通过强制事务之间的完全隔离来实现\",{\"1\":{\"289\":1}}],[\"串行化提供最高的隔离性\",{\"1\":{\"276\":1}}],[\"串行化\",{\"0\":{\"289\":1},\"1\":{\"23\":1,\"289\":1}}],[\"读者将能深入理解tbm模块如何在数据库系统中发挥作用\",{\"1\":{\"207\":1}}],[\"读取和删除\",{\"1\":{\"309\":1}}],[\"读取\",{\"1\":{\"297\":2}}],[\"读取到的结果是一致的\",{\"1\":{\"287\":1}}],[\"读取文件过程中出现异常\",{\"1\":{\"190\":1}}],[\"读取文件的所有字节\",{\"1\":{\"190\":1}}],[\"读取文件大小和\",{\"1\":{\"81\":1}}],[\"读取了\",{\"1\":{\"87\":2}}],[\"读取整条日志\",{\"1\":{\"83\":1}}],[\"读取下一条日志记录\",{\"1\":{\"90\":1,\"91\":1}}],[\"读取下一条日志\",{\"1\":{\"82\":1}}],[\"读取数据\",{\"1\":{\"72\":1}}],[\"读取用户输入并调用\",{\"1\":{\"37\":1}}],[\"读未提交隔离级别下不考虑版本跳跃问题\",{\"1\":{\"292\":1}}],[\"读未提交级别实现最为简单\",{\"1\":{\"284\":1}}],[\"读未提交允许读取未提交的数据\",{\"1\":{\"276\":1}}],[\"读未提交\",{\"0\":{\"284\":1},\"1\":{\"23\":1,\"276\":1,\"283\":1,\"284\":1}}],[\"读已提交\",{\"1\":{\"23\":2}}],[\"读提交及以上隔离级别需要检查版本跳跃\",{\"1\":{\"292\":1}}],[\"读提交的事务可见性逻辑\",{\"0\":{\"286\":1}}],[\"读提交通过维护两个关键字段来实现\",{\"1\":{\"285\":1}}],[\"读提交仅允许读取已提交的数据\",{\"1\":{\"276\":1}}],[\"读提交\",{\"0\":{\"285\":1},\"1\":{\"2\":1,\"276\":1,\"283\":1,\"285\":1}}],[\"开始\",{\"1\":{\"297\":2}}],[\"开始时未提交\",{\"1\":{\"288\":1}}],[\"开始时的活跃事务集合中\",{\"1\":{\"288\":1}}],[\"开始之前但未提交\",{\"1\":{\"288\":1}}],[\"开始之前创建的\",{\"1\":{\"288\":1}}],[\"开始一个事务\",{\"0\":{\"245\":1}}],[\"开始递增\",{\"1\":{\"235\":1}}],[\"开销\",{\"1\":{\"52\":1}}],[\"开启一个新事务\",{\"1\":{\"238\":1}}],[\"开启事务\",{\"1\":{\"238\":1}}],[\"开启指定事务的隔离级别\",{\"1\":{\"23\":1}}],[\"开启默认事务\",{\"1\":{\"23\":1}}],[\"开发环境\",{\"0\":{\"11\":1,\"178\":1}}],[\"开发环境与运行示例\",{\"0\":{\"10\":1,\"177\":1}}],[\"开发者可以快速启动并部署\",{\"1\":{\"2\":1}}],[\"==\",{\"1\":{\"32\":2,\"33\":1,\"43\":2,\"44\":1,\"46\":1,\"57\":1,\"58\":1,\"72\":2,\"82\":1,\"83\":1,\"90\":1,\"91\":1,\"92\":2,\"114\":1,\"145\":1,\"154\":3,\"157\":1,\"158\":1,\"159\":3,\"196\":1,\"202\":1,\"249\":1,\"262\":2,\"268\":2,\"284\":1,\"286\":10,\"288\":10,\"289\":3,\"290\":1,\"292\":4,\"309\":1,\"311\":1,\"312\":1,\"313\":2,\"314\":1,\"316\":2}}],[\"=\",{\"1\":{\"22\":3,\"31\":2,\"32\":5,\"33\":5,\"34\":4,\"36\":13,\"37\":9,\"43\":8,\"44\":8,\"45\":7,\"46\":19,\"57\":3,\"58\":2,\"59\":2,\"69\":6,\"70\":3,\"72\":21,\"73\":6,\"80\":2,\"81\":4,\"82\":4,\"83\":13,\"89\":2,\"90\":5,\"91\":9,\"92\":13,\"100\":3,\"101\":2,\"104\":7,\"106\":1,\"113\":3,\"114\":1,\"115\":1,\"116\":4,\"126\":1,\"133\":1,\"134\":3,\"136\":7,\"144\":2,\"145\":18,\"146\":4,\"154\":20,\"155\":2,\"157\":3,\"158\":2,\"159\":6,\"160\":3,\"161\":5,\"188\":2,\"189\":2,\"191\":3,\"196\":9,\"198\":14,\"199\":10,\"200\":6,\"201\":4,\"202\":17,\"203\":6,\"216\":1,\"219\":16,\"220\":5,\"221\":3,\"226\":6,\"227\":5,\"228\":1,\"240\":7,\"242\":6,\"245\":1,\"246\":4,\"247\":1,\"249\":2,\"260\":1,\"262\":10,\"266\":5,\"267\":6,\"268\":6,\"284\":1,\"286\":7,\"288\":7,\"289\":4,\"290\":7,\"292\":1,\"301\":4,\"303\":2,\"304\":2,\"305\":1,\"309\":1,\"311\":3,\"312\":2,\"313\":1,\"314\":3,\"315\":3,\"316\":11}}],[\"found\",{\"1\":{\"320\":1}}],[\"force\",{\"1\":{\"81\":1,\"83\":1,\"100\":1,\"246\":1,\"247\":1}}],[\"foreach\",{\"1\":{\"46\":1,\"198\":2,\"199\":2}}],[\"for\",{\"1\":{\"45\":1,\"59\":1,\"72\":1,\"80\":1,\"91\":2,\"116\":1,\"136\":2,\"145\":1,\"155\":1,\"157\":1,\"202\":3,\"219\":1,\"221\":2,\"262\":1,\"267\":1,\"290\":1}}],[\"forwarded\",{\"1\":{\"45\":1}}],[\"fullindex\",{\"2\":{\"169\":1}}],[\"fulltext\",{\"2\":{\"163\":1}}],[\"f\",{\"1\":{\"160\":2,\"189\":10,\"220\":5}}],[\"fd\",{\"1\":{\"155\":3}}],[\"fso会更新为新插入数据的末尾位置\",{\"1\":{\"125\":1}}],[\"fso指示了页面中第一个可用的空闲字节的位置\",{\"1\":{\"125\":1}}],[\"fso\",{\"0\":{\"125\":1},\"1\":{\"125\":1}}],[\"fc\",{\"1\":{\"81\":5,\"83\":10,\"100\":3,\"104\":2,\"242\":2,\"246\":3,\"247\":3,\"249\":2,\"250\":1,\"251\":2}}],[\"freespace\",{\"1\":{\"72\":2,\"115\":3}}],[\"free\",{\"1\":{\"72\":2,\"125\":1}}],[\"fromtypename\",{\"1\":{\"160\":1}}],[\"from\",{\"1\":{\"22\":3}}],[\"false\",{\"1\":{\"46\":1,\"81\":1,\"83\":1,\"100\":2,\"105\":1,\"144\":1,\"159\":3,\"219\":1,\"246\":1,\"247\":1,\"262\":5,\"286\":1,\"288\":1,\"289\":1,\"290\":1,\"292\":1,\"313\":1,\"316\":3}}],[\"failed\",{\"1\":{\"44\":1}}],[\"firsttableuid\",{\"1\":{\"227\":2,\"228\":1}}],[\"findfirst\",{\"1\":{\"156\":1,\"160\":1}}],[\"findindexedfield\",{\"1\":{\"154\":2,\"156\":1}}],[\"finally\",{\"1\":{\"58\":1,\"59\":1,\"72\":2,\"83\":2,\"92\":2,\"100\":1,\"114\":1,\"115\":1,\"145\":2,\"146\":2,\"228\":1,\"245\":1,\"260\":1,\"266\":1,\"268\":1,\"304\":1,\"305\":1,\"311\":1,\"314\":1,\"316\":1}}],[\"final\",{\"1\":{\"43\":1,\"46\":4,\"89\":2,\"113\":2,\"188\":2,\"240\":7,\"301\":3}}],[\"fielduids\",{\"1\":{\"216\":1}}],[\"fieldnuid\",{\"1\":{\"216\":1}}],[\"fieldnames\",{\"1\":{\"202\":3}}],[\"fieldname\",{\"1\":{\"156\":3,\"160\":3,\"198\":2,\"200\":1,\"202\":1,\"217\":3,\"219\":8,\"220\":2,\"221\":3}}],[\"field2uid\",{\"1\":{\"216\":1}}],[\"field1uid\",{\"1\":{\"216\":1}}],[\"fieldcalres\",{\"1\":{\"161\":1}}],[\"fieldcache\",{\"1\":{\"160\":1}}],[\"fieldcache用于缓存字段名和\",{\"1\":{\"160\":1}}],[\"fieldtypes\",{\"1\":{\"202\":3}}],[\"fieldtype\",{\"1\":{\"160\":1,\"202\":1,\"217\":1,\"219\":4,\"220\":3}}],[\"fields\",{\"1\":{\"155\":1,\"156\":1,\"160\":1,\"198\":5,\"199\":1,\"216\":1,\"219\":2,\"221\":2,\"222\":1}}],[\"field\",{\"1\":{\"154\":4,\"155\":5,\"156\":4,\"159\":2,\"160\":5,\"161\":3,\"213\":1,\"217\":1,\"219\":2,\"220\":3,\"221\":11,\"222\":1,\"240\":4,\"243\":1,\"245\":1,\"246\":2,\"249\":2,\"251\":4},\"2\":{\"212\":1,\"224\":1}}],[\"filter\",{\"1\":{\"156\":1,\"160\":1}}],[\"fillpageindex\",{\"1\":{\"73\":1,\"116\":2}}],[\"filechannel\",{\"1\":{\"251\":1}}],[\"filecannotrwexception\",{\"1\":{\"189\":2,\"191\":2}}],[\"filelen\",{\"1\":{\"242\":4}}],[\"filelock\",{\"1\":{\"100\":2,\"104\":2}}],[\"fileoutputstream\",{\"1\":{\"191\":2}}],[\"filenotexistsexception\",{\"1\":{\"189\":1}}],[\"fileexistsexception\",{\"1\":{\"189\":1}}],[\"filevisitresult\",{\"1\":{\"46\":4}}],[\"filesize\",{\"1\":{\"83\":2}}],[\"files\",{\"1\":{\"46\":3,\"190\":1,\"191\":1}}],[\"file\",{\"1\":{\"44\":4,\"46\":3,\"81\":1,\"82\":1,\"188\":2,\"189\":5,\"190\":1,\"191\":7,\"242\":1,\"250\":1,\"251\":2}}],[\"fixedrate\",{\"1\":{\"46\":1}}],[\"flushpage\",{\"1\":{\"73\":1,\"98\":1}}],[\"flush\",{\"1\":{\"33\":1,\"100\":3,\"101\":1,\"105\":2,\"191\":1}}],[\"flag\",{\"1\":{\"31\":3,\"92\":4}}],[\"float\",{\"1\":{\"21\":1,\"217\":1}}],[\"等基本数据操作的\",{\"1\":{\"22\":1}}],[\"等待数据库创建成功\",{\"1\":{\"16\":1,\"183\":1}}],[\"等待用户的下一次输入\",{\"1\":{\"6\":1,\"173\":1}}],[\"删除该记录的事务编号\",{\"1\":{\"300\":1}}],[\"删除操作在当前事务\",{\"1\":{\"288\":2}}],[\"删除操作尚未提交或\",{\"1\":{\"288\":1}}],[\"删除操作由其他事务执行但不是当前事务\",{\"1\":{\"288\":1}}],[\"删除和事务管理等操作\",{\"1\":{\"279\":1}}],[\"删除等操作\",{\"1\":{\"226\":1}}],[\"删除临时文件\",{\"1\":{\"189\":1}}],[\"删除可能存在的临时文件\",{\"1\":{\"189\":3}}],[\"删除\",{\"1\":{\"65\":1}}],[\"删除用户数据\",{\"1\":{\"22\":1}}],[\"删除表\",{\"1\":{\"21\":1}}],[\"删\",{\"1\":{\"22\":1}}],[\"改\",{\"1\":{\"22\":1}}],[\"查找字段是否存在索引\",{\"1\":{\"156\":1}}],[\"查找是否存在索引id\",{\"0\":{\"156\":1}}],[\"查找对应的\",{\"1\":{\"145\":1}}],[\"查询一个事务的状态是否是已取消\",{\"1\":{\"238\":1}}],[\"查询一个事务的状态是否是已提交\",{\"1\":{\"238\":1}}],[\"查询一个事务的状态是否是正在进行的状态\",{\"1\":{\"238\":1}}],[\"查询一个事务的状态是否撤销或回滚\",{\"1\":{\"238\":1}}],[\"查询一个事务的状态是否已经提交\",{\"1\":{\"238\":1}}],[\"查询一个事务的状态是否正在运行\",{\"1\":{\"238\":1}}],[\"查询\",{\"1\":{\"207\":1,\"226\":1}}],[\"查询并返回结果\",{\"1\":{\"29\":1}}],[\"查询所有字段\",{\"1\":{\"22\":1}}],[\"查\",{\"1\":{\"22\":1}}],[\"查看表结构\",{\"1\":{\"21\":1}}],[\"查看数据库拥有哪些表\",{\"1\":{\"21\":1}}],[\"查看和删除表\",{\"1\":{\"21\":1}}],[\"介绍事务的基本概念及其在数据库中的应用\",{\"1\":{\"23\":1}}],[\"介绍增\",{\"1\":{\"22\":1}}],[\"介绍表的基本结构和数据类型\",{\"1\":{\"21\":1}}],[\"u2x\",{\"1\":{\"259\":1,\"260\":2,\"262\":1,\"268\":2}}],[\"u\",{\"1\":{\"85\":2,\"86\":3,\"147\":2,\"297\":1}}],[\"u1\",{\"1\":{\"69\":2}}],[\"u0\",{\"1\":{\"69\":2}}],[\"uids\",{\"1\":{\"145\":4,\"154\":13,\"157\":3}}],[\"uid\",{\"0\":{\"69\":1},\"1\":{\"65\":1,\"69\":16,\"70\":9,\"72\":4,\"89\":1,\"143\":2,\"145\":5,\"146\":1,\"157\":3,\"186\":1,\"187\":1,\"216\":2,\"217\":1,\"221\":2,\"226\":1,\"227\":4,\"228\":1,\"260\":8,\"262\":3,\"267\":3,\"268\":7,\"301\":4,\"309\":4,\"314\":2,\"316\":3}}],[\"unexpected\",{\"1\":{\"196\":1}}],[\"unchecked\",{\"1\":{\"159\":1}}],[\"uncommitted\",{\"1\":{\"23\":1,\"283\":1,\"284\":1,\"290\":1,\"292\":1}}],[\"unsupported\",{\"1\":{\"158\":1,\"159\":1,\"196\":1}}],[\"undotranscations\",{\"1\":{\"91\":1}}],[\"undo\",{\"1\":{\"84\":1,\"86\":1,\"91\":2,\"92\":1,\"147\":1}}],[\"unbefore\",{\"1\":{\"66\":2}}],[\"unlock\",{\"1\":{\"57\":6,\"58\":1,\"59\":1,\"66\":2,\"72\":1,\"83\":2,\"100\":1,\"104\":1,\"114\":1,\"115\":1,\"146\":2,\"228\":1,\"245\":1,\"260\":1,\"266\":1,\"267\":1,\"268\":2,\"311\":2,\"312\":3,\"313\":3,\"314\":1,\"315\":1,\"316\":2}}],[\"unknown\",{\"1\":{\"45\":1,\"292\":1}}],[\"unknownhostexception\",{\"1\":{\"37\":1}}],[\"uniquevalues\",{\"1\":{\"221\":1}}],[\"uniquefields\",{\"1\":{\"219\":2}}],[\"unique\",{\"1\":{\"21\":1,\"202\":5,\"219\":1}}],[\"updatexid\",{\"0\":{\"246\":1},\"1\":{\"245\":1,\"246\":4,\"251\":2}}],[\"updatexchecksum\",{\"1\":{\"83\":2}}],[\"updatefirsttableuid\",{\"1\":{\"228\":1}}],[\"updateuniquevalues\",{\"1\":{\"221\":2}}],[\"updatestmt\",{\"1\":{\"200\":6}}],[\"updateobj\",{\"1\":{\"200\":9}}],[\"updaterootuid\",{\"1\":{\"146\":1}}],[\"updateloginfo\",{\"1\":{\"90\":1,\"91\":1,\"92\":2}}],[\"updatelog\",{\"1\":{\"89\":1}}],[\"updatelastaccessedtime\",{\"1\":{\"43\":1,\"46\":1}}],[\"update\",{\"1\":{\"22\":2,\"85\":1,\"89\":1,\"187\":2,\"191\":2,\"196\":2,\"200\":2,\"210\":1,\"226\":3}}],[\"userid\",{\"1\":{\"46\":19}}],[\"usercount\",{\"1\":{\"46\":5}}],[\"usermanager\",{\"1\":{\"43\":3,\"44\":2,\"46\":2}}],[\"user\",{\"1\":{\"21\":1,\"43\":1}}],[\"username\",{\"1\":{\"21\":1,\"22\":3}}],[\"usersession>\",{\"1\":{\"46\":1}}],[\"usersession\",{\"1\":{\"43\":6,\"44\":10,\"46\":10}}],[\"users\",{\"1\":{\"21\":2,\"22\":6,\"46\":2}}],[\"示例\",{\"1\":{\"21\":1,\"22\":1,\"23\":1}}],[\"适合初学者和希望快速掌握数据库基本功能的用户\",{\"1\":{\"19\":1}}],[\"文档内容主要围绕常见的\",{\"1\":{\"19\":1}}],[\"文件头长度\",{\"1\":{\"251\":1}}],[\"文件存在问题\",{\"1\":{\"242\":1}}],[\"文件进行校验\",{\"1\":{\"242\":1}}],[\"文件管理的事务的个数\",{\"1\":{\"237\":1}}],[\"文件的合法性\",{\"1\":{\"251\":1}}],[\"文件的后缀\",{\"1\":{\"251\":1}}],[\"文件的头部保存一个\",{\"1\":{\"237\":1}}],[\"文件的结构和管理\",{\"0\":{\"237\":1}}],[\"文件的更新操作的原子性\",{\"1\":{\"187\":1}}],[\"文件比喻成一个任务清单\",{\"1\":{\"234\":1}}],[\"文件来维护事务的状态的\",{\"1\":{\"234\":1}}],[\"文件来跟踪每个事务的状态\",{\"1\":{\"9\":1,\"176\":1}}],[\"文件不存在\",{\"1\":{\"189\":1}}],[\"文件不可读写\",{\"1\":{\"189\":2}}],[\"文件已存在\",{\"1\":{\"189\":1}}],[\"文件\",{\"1\":{\"187\":1,\"226\":1,\"234\":1,\"251\":2}}],[\"文件中分配一个字节的空间\",{\"1\":{\"237\":1}}],[\"文件中的启动信息\",{\"1\":{\"190\":1,\"191\":1}}],[\"文件中\",{\"1\":{\"186\":1,\"187\":1}}],[\"文件中配置数据库路径\",{\"1\":{\"13\":1,\"180\":1}}],[\"文件初始化与校验\",{\"1\":{\"68\":1}}],[\"文件抽象为\",{\"1\":{\"9\":1,\"176\":1}}],[\"文件并对其进行分页缓存\",{\"1\":{\"9\":1,\"176\":1}}],[\"文件和日志文件\",{\"1\":{\"9\":1,\"129\":1,\"176\":1}}],[\"44\",{\"1\":{\"136\":1,\"137\":2}}],[\"404\",{\"1\":{\"320\":1}}],[\"40\",{\"1\":{\"113\":1}}],[\"4\",{\"0\":{\"251\":1},\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"67\":1,\"68\":1,\"69\":1,\"74\":1,\"81\":1,\"83\":4,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"136\":1,\"137\":2,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"nwas\",{\"1\":{\"196\":1}}],[\"nyadb2\",{\"1\":{\"84\":1}}],[\"nextuid\",{\"1\":{\"216\":1,\"219\":2,\"227\":1}}],[\"nexttable\",{\"1\":{\"216\":2}}],[\"next\",{\"1\":{\"83\":2,\"90\":1,\"91\":1,\"266\":1}}],[\"newentry\",{\"1\":{\"301\":1}}],[\"newtransaction\",{\"1\":{\"290\":1,\"311\":1}}],[\"newnilrootraw\",{\"1\":{\"144\":1}}],[\"newrootuid\",{\"1\":{\"146\":2}}],[\"newrootraw\",{\"1\":{\"144\":1,\"146\":1}}],[\"newraw\",{\"1\":{\"89\":1,\"92\":1}}],[\"newb\",{\"1\":{\"86\":3}}],[\"newx\",{\"1\":{\"85\":2,\"86\":3}}],[\"newpage\",{\"1\":{\"72\":1,\"98\":1,\"101\":1}}],[\"newpgno\",{\"1\":{\"72\":2}}],[\"newkeyset\",{\"1\":{\"46\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"43\":1}}],[\"new\",{\"1\":{\"32\":6,\"33\":4,\"36\":5,\"37\":7,\"43\":3,\"44\":5,\"46\":5,\"66\":1,\"72\":1,\"73\":2,\"91\":3,\"101\":1,\"104\":2,\"113\":1,\"115\":1,\"136\":3,\"144\":4,\"145\":3,\"154\":8,\"157\":1,\"158\":1,\"159\":1,\"161\":1,\"189\":5,\"191\":4,\"196\":3,\"198\":9,\"199\":7,\"200\":1,\"201\":1,\"202\":13,\"203\":4,\"216\":1,\"219\":5,\"220\":1,\"226\":3,\"228\":1,\"246\":1,\"249\":1,\"260\":1,\"262\":2,\"265\":2,\"290\":2,\"292\":1,\"303\":1,\"304\":1}}],[\"newdomain\",{\"1\":{\"22\":1}}],[\"nokeys\",{\"1\":{\"145\":6}}],[\"node\",{\"1\":{\"143\":3,\"144\":4,\"145\":1,\"146\":1}}],[\"no\",{\"1\":{\"72\":2,\"113\":3,\"114\":2}}],[\"notnullfields\",{\"1\":{\"219\":2}}],[\"notnull\",{\"1\":{\"202\":4,\"219\":1}}],[\"not\",{\"1\":{\"21\":1,\"199\":1,\"202\":1,\"286\":3,\"288\":6,\"320\":1}}],[\"number++\",{\"1\":{\"72\":2,\"114\":2}}],[\"number\",{\"1\":{\"72\":5,\"114\":5,\"115\":2}}],[\"nullpointerexception\",{\"1\":{\"312\":1}}],[\"nullentryexception\",{\"1\":{\"309\":1,\"314\":1,\"316\":1}}],[\"null\",{\"1\":{\"21\":1,\"32\":4,\"33\":1,\"36\":4,\"37\":2,\"43\":2,\"44\":3,\"45\":1,\"46\":4,\"57\":1,\"72\":9,\"82\":2,\"83\":8,\"90\":1,\"91\":1,\"92\":2,\"101\":1,\"114\":2,\"116\":1,\"154\":8,\"155\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":2,\"160\":3,\"190\":1,\"196\":2,\"198\":2,\"199\":1,\"200\":1,\"201\":1,\"202\":2,\"219\":1,\"260\":2,\"262\":4,\"267\":3,\"268\":2,\"286\":5,\"288\":5,\"309\":1,\"311\":1,\"312\":1,\"314\":3,\"315\":1,\"316\":4}}],[\"n\",{\"1\":{\"33\":1,\"312\":2}}],[\"nc\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"name\",{\"1\":{\"16\":1,\"22\":1,\"183\":1,\"216\":1,\"227\":1}}],[\"均采用\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"本篇文章主要介绍了\",{\"1\":{\"165\":1}}],[\"本节不深入探讨\",{\"1\":{\"142\":1}}],[\"本文为读者提供了有关数据库系统中索引优化与查询策略的重要知识\",{\"1\":{\"167\":1}}],[\"本文展示了如何判断是否需要进行全表扫描\",{\"1\":{\"167\":1}}],[\"本文讨论了在以下两种情况下触发全表扫描\",{\"1\":{\"167\":1}}],[\"本文详细介绍了\",{\"1\":{\"166\":1}}],[\"本文将详细介绍如何通过\",{\"1\":{\"257\":1}}],[\"本文将深入探讨\",{\"1\":{\"231\":1}}],[\"本文将深入探讨easydb中页面管理的具体实现\",{\"1\":{\"121\":1}}],[\"本文将通过解析\",{\"1\":{\"194\":1}}],[\"本文将通过具体代码示例\",{\"1\":{\"165\":1}}],[\"本文将介绍如何在我们的数据库系统中定义\",{\"1\":{\"214\":1}}],[\"本文将介绍tbm模块中涉及的关键内容和核心功能\",{\"1\":{\"207\":1}}],[\"本文将介绍\",{\"1\":{\"29\":1}}],[\"本文作者\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"本章涉及代码\",{\"1\":{\"29\":1,\"40\":1,\"49\":1,\"63\":1,\"77\":1,\"95\":1,\"110\":1,\"120\":1,\"132\":1,\"141\":1,\"151\":1,\"186\":1,\"213\":1,\"225\":1,\"233\":1,\"254\":1,\"282\":1,\"295\":1,\"308\":1}}],[\"本使用文档旨在帮助用户快速上手使用本数据库系统\",{\"1\":{\"19\":1}}],[\"本博客所有文章除特别声明外\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"注解定期检查用户会话\",{\"1\":{\"46\":1}}],[\"注\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"客户端的启动入口如下\",{\"1\":{\"37\":1}}],[\"客户端的实现\",{\"1\":{\"26\":1}}],[\"客户端通过\",{\"1\":{\"37\":1}}],[\"客户端实现\",{\"0\":{\"37\":1}}],[\"客户端启动后\",{\"1\":{\"17\":1,\"184\":1}}],[\"客户端来访问数据库服务\",{\"1\":{\"13\":1,\"180\":1}}],[\"步骤二\",{\"0\":{\"17\":1,\"184\":1}}],[\"步骤一\",{\"0\":{\"16\":1,\"183\":1}}],[\"首先会检查该资源是否已被其他事务持有\",{\"1\":{\"260\":1}}],[\"首先对\",{\"1\":{\"251\":1}}],[\"首先需要对\",{\"1\":{\"242\":1}}],[\"首先根据所需的空间大小向上取整\",{\"1\":{\"112\":1}}],[\"首先检查其他线程是否正在获取该资源\",{\"1\":{\"53\":1}}],[\"首先运行创建数据库的启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"首先执行一下命令编译源码\",{\"1\":{\"14\":1,\"181\":1}}],[\"运行\",{\"1\":{\"17\":1,\"184\":1}}],[\"运行客户端\",{\"1\":{\"17\":1,\"184\":1}}],[\"运行启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"运行示例\",{\"0\":{\"12\":1,\"179\":1}}],[\"创建该记录的事务编号\",{\"1\":{\"300\":1}}],[\"创建该版本的事务编号\",{\"1\":{\"275\":1}}],[\"创建了一个新的版本\",{\"1\":{\"298\":1}}],[\"创建了新节点\",{\"1\":{\"147\":1}}],[\"创建且\",{\"1\":{\"288\":1}}],[\"创建的\",{\"1\":{\"286\":1,\"288\":1}}],[\"创建新的表对象\",{\"1\":{\"228\":1}}],[\"创建新的临时文件\",{\"1\":{\"191\":1}}],[\"创建隐藏字段\",{\"1\":{\"219\":1}}],[\"创建字段的\",{\"1\":{\"220\":1}}],[\"创建字段\",{\"1\":{\"219\":1}}],[\"创建表对象\",{\"1\":{\"219\":1}}],[\"创建表的\",{\"1\":{\"219\":1}}],[\"创建表的语句\",{\"1\":{\"21\":1}}],[\"创建表\",{\"0\":{\"219\":1}}],[\"创建一张表并不仅仅是指定表名和字段那么简单\",{\"1\":{\"218\":1}}],[\"创建一个长度为xid\",{\"1\":{\"246\":1}}],[\"创建一个新的字节缓冲区\",{\"1\":{\"249\":1}}],[\"创建一个新的booter对象\",{\"1\":{\"189\":1}}],[\"创建一个新的页面\",{\"1\":{\"72\":1}}],[\"创建一个1到10的数组\",{\"1\":{\"136\":1}}],[\"创建一个用于存储日志的映射\",{\"1\":{\"91\":1}}],[\"创建一个大小为\",{\"1\":{\"83\":2}}],[\"创建一个表示日志类型的字节数组\",{\"1\":{\"72\":1}}],[\"创建和管理表结构和字段\",{\"1\":{\"214\":1}}],[\"创建临时文件过程中出现异常\",{\"1\":{\"191\":1}}],[\"创建文件过程中出现异常\",{\"1\":{\"189\":1}}],[\"创建与打开启动信息文件\",{\"0\":{\"189\":1}}],[\"创建两个\",{\"1\":{\"136\":1}}],[\"创建另一个启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"创建启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"为当前事务\",{\"1\":{\"305\":1}}],[\"为事务提供了一个结构\",{\"1\":{\"290\":1}}],[\"为每个数据记录维护了多个版本\",{\"1\":{\"274\":1}}],[\"为实现这些功能\",{\"1\":{\"251\":1}}],[\"为确保启动信息的一致性和正确性\",{\"1\":{\"186\":1}}],[\"为此\",{\"1\":{\"129\":1,\"146\":1}}],[\"为上层模块\",{\"1\":{\"85\":1}}],[\"为上层模块提供了安全\",{\"1\":{\"74\":1}}],[\"为了实现串行化隔离级别\",{\"1\":{\"311\":1}}],[\"为了增强数据库体验\",{\"1\":{\"298\":1}}],[\"为了保证数据的正确性\",{\"1\":{\"298\":1}}],[\"为了保证数据的一致性\",{\"1\":{\"78\":1}}],[\"为了减少因\",{\"1\":{\"298\":1}}],[\"为了减少这种阻塞\",{\"1\":{\"273\":1}}],[\"为了解决这个问题\",{\"1\":{\"297\":1}}],[\"为了解决这一问题\",{\"1\":{\"277\":1}}],[\"为了防止死锁\",{\"1\":{\"278\":1}}],[\"为了避免版本跳跃\",{\"1\":{\"292\":1}}],[\"为了避免长时间等待导致系统资源被锁住\",{\"1\":{\"264\":1}}],[\"为了避免死锁\",{\"1\":{\"261\":1}}],[\"为了避免特殊字符的问题\",{\"1\":{\"33\":1}}],[\"为了处理一些特殊情况\",{\"1\":{\"209\":1}}],[\"为了确保启动信息的一致性\",{\"1\":{\"208\":1}}],[\"为了确保启动信息的修改是原子的\",{\"1\":{\"187\":1}}],[\"为了确保数据库操作的正确性和数据的一致性\",{\"1\":{\"214\":1}}],[\"为了确保数据库操作的正确性和高效性\",{\"1\":{\"207\":1}}],[\"为了确保数据的一致性\",{\"1\":{\"87\":1}}],[\"为了更好地理解\",{\"1\":{\"135\":1}}],[\"为了更好地控制资源管理和回源操作\",{\"1\":{\"52\":1}}],[\"为了克服这个限制\",{\"1\":{\"133\":1}}],[\"为了在插入数据时快速找到合适的存储空间\",{\"1\":{\"129\":1}}],[\"为了提高插入操作的效率\",{\"1\":{\"111\":1}}],[\"为了从\",{\"1\":{\"69\":1}}],[\"为了管理资源的引用计数\",{\"1\":{\"56\":1}}],[\"为\",{\"1\":{\"31\":1,\"81\":2,\"146\":1}}],[\"为传输的实际数据\",{\"1\":{\"31\":1}}],[\"为项目的根目录\",{\"1\":{\"16\":1,\"183\":1}}],[\"为前后端提供更强大的支持和灵活性\",{\"1\":{\"7\":1,\"174\":1}}],[\"输入以下内容以创建数据库\",{\"1\":{\"16\":1,\"183\":1}}],[\"作为参数\",{\"1\":{\"249\":1}}],[\"作为主类\",{\"1\":{\"16\":1,\"183\":1}}],[\"作为一名热衷于数据库技术的开发者\",{\"1\":{\"4\":1,\"171\":1}}],[\"选择\",{\"1\":{\"16\":2,\"183\":2}}],[\"点击左上角的\",{\"1\":{\"16\":1,\"183\":1}}],[\"类实现锁管理\",{\"1\":{\"257\":1}}],[\"类实现了单次的收发动作\",{\"1\":{\"37\":1}}],[\"类实现了\",{\"1\":{\"36\":1}}],[\"类确保线程安全\",{\"1\":{\"251\":1}}],[\"类还处理事务控制语句\",{\"1\":{\"203\":1}}],[\"类中的主要方法\",{\"1\":{\"195\":1}}],[\"类是一个用于解析\",{\"1\":{\"195\":1}}],[\"类提供了加载\",{\"1\":{\"187\":1}}],[\"类提供了两个主要方法\",{\"1\":{\"145\":1}}],[\"类持有其所属的\",{\"1\":{\"143\":1}}],[\"类来管理的\",{\"1\":{\"299\":1}}],[\"类来实现类似\",{\"1\":{\"137\":1}}],[\"类来松散地规定数组的可使用范围\",{\"1\":{\"133\":1}}],[\"类创建了两个子数组\",{\"1\":{\"136\":1}}],[\"类的概述\",{\"0\":{\"258\":1}}],[\"类的主要字段和定义如下\",{\"1\":{\"188\":1}}],[\"类的用途\",{\"1\":{\"135\":1}}],[\"类的简单实现\",{\"1\":{\"134\":1}}],[\"类的实现\",{\"0\":{\"113\":1,\"134\":1}}],[\"类以及相关方法\",{\"1\":{\"117\":1}}],[\"类型的\",{\"1\":{\"251\":2}}],[\"类型\",{\"1\":{\"83\":1}}],[\"类用于表示单个用户的会话信息\",{\"1\":{\"46\":1}}],[\"类将\",{\"1\":{\"34\":1}}],[\"类负责将编码后的数据通过输出流发送出去\",{\"1\":{\"33\":1}}],[\"类编码为字节数组\",{\"1\":{\"31\":1}}],[\"类\",{\"0\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1},\"1\":{\"30\":1,\"129\":1,\"138\":1,\"187\":1,\"194\":1,\"279\":1}}],[\"类似于数据库表中的一行数据\",{\"1\":{\"298\":1}}],[\"类似于\",{\"1\":{\"29\":1,\"246\":2,\"295\":1}}],[\"类即可进行交互\",{\"1\":{\"15\":1,\"182\":1}}],[\"类时\",{\"1\":{\"15\":1,\"182\":1}}],[\"随后只需启动\",{\"1\":{\"15\":1,\"182\":1}}],[\"随后返回执行结果\",{\"1\":{\"14\":1,\"181\":1}}],[\"配置数据库打开\",{\"1\":{\"16\":1,\"183\":1}}],[\"配置数据库创建\",{\"1\":{\"16\":1,\"183\":1}}],[\"配置数据库路径\",{\"1\":{\"13\":1,\"180\":1}}],[\"配置\",{\"0\":{\"16\":1,\"183\":1}}],[\"配置和启动\",{\"0\":{\"15\":1,\"182\":1}}],[\"执行回滚操作\",{\"1\":{\"266\":1}}],[\"执行过程\",{\"0\":{\"256\":1}}],[\"执行比较操作\",{\"1\":{\"159\":1}}],[\"执行全表查询\",{\"0\":{\"157\":1}}],[\"执行全表扫描\",{\"1\":{\"154\":2,\"157\":1}}],[\"执行缓存和日志的关闭流程\",{\"1\":{\"72\":1}}],[\"执行数据库操作\",{\"1\":{\"43\":1}}],[\"执行\",{\"1\":{\"26\":1,\"29\":1,\"41\":1,\"298\":1}}],[\"执行示例\",{\"1\":{\"14\":1,\"181\":1}}],[\"执行以下命令启动数据库客户端\",{\"1\":{\"14\":1,\"181\":1}}],[\"这时\",{\"1\":{\"297\":1}}],[\"这两个操作是由不同的事务执行的\",{\"1\":{\"297\":1}}],[\"这两个子数组分别引用了原始数组的不同部分\",{\"1\":{\"136\":1}}],[\"这可能导致逻辑上的错误\",{\"1\":{\"291\":1}}],[\"这就可能导致冲突\",{\"1\":{\"297\":1}}],[\"这就像是你在任务清单中更新任务的状态\",{\"1\":{\"246\":1}}],[\"这就像是在项目管理中为每个新任务建立一个详细的记录\",{\"1\":{\"245\":1}}],[\"这就无法实现同一片内存的共享\",{\"1\":{\"133\":1}}],[\"这类似于一本书的目录\",{\"1\":{\"216\":1}}],[\"这会导致无法直接通过父节点找到\",{\"1\":{\"147\":1}}],[\"这意味着\",{\"1\":{\"298\":1}}],[\"这意味着tj在时间上晚于ti开始\",{\"1\":{\"292\":1}}],[\"这意味着ti并不真正了解x的最新状态\",{\"1\":{\"291\":1}}],[\"这意味着删除操作对当前事务不可见\",{\"1\":{\"286\":1}}],[\"这意味着可能会读取到未提交的数据变化\",{\"1\":{\"284\":1}}],[\"这意味着新创建的表会成为表链表的第一个元素\",{\"1\":{\"226\":1}}],[\"这意味着索引数据直接存储在数据库文件中\",{\"1\":{\"142\":1}}],[\"这意味着只有在上层模块明确表示不再需要某个资源时\",{\"1\":{\"52\":1}}],[\"这说明我们可以通过\",{\"1\":{\"137\":1}}],[\"这些信息会被存储在\",{\"1\":{\"299\":1}}],[\"这些信息对数据库的正常启动至关重要\",{\"1\":{\"208\":1}}],[\"这些信息对于数据库的正常启动至关重要\",{\"1\":{\"186\":1}}],[\"这些标识符用于快速定位字段信息\",{\"1\":{\"216\":1}}],[\"这些方法会解析\",{\"1\":{\"203\":1}}],[\"这些内容将帮助读者理解如何在数据库系统中实现高效的索引管理\",{\"1\":{\"166\":1}}],[\"这些语言中的数组是通过指针实现的\",{\"1\":{\"133\":1}}],[\"这些功能确保了高并发环境下的数据一致性与系统性能\",{\"1\":{\"2\":1}}],[\"这与\",{\"1\":{\"133\":1}}],[\"这一部分是说\",{\"1\":{\"286\":1}}],[\"这一模块是数据库系统的关键组成部分之一\",{\"1\":{\"272\":1}}],[\"这一功能使得系统能够灵活处理不同类型的sql语句\",{\"1\":{\"210\":1}}],[\"这一修改在\",{\"1\":{\"137\":1}}],[\"这一实现虽然不如指针方式灵活\",{\"1\":{\"129\":1}}],[\"这一选择是因为引用计数策略能够更好地控制资源的释放\",{\"1\":{\"129\":1}}],[\"这一设计大大提升了系统在处理大量数据时的性能\",{\"1\":{\"129\":1}}],[\"这一过程确保了从磁盘读取数据的正确性和线程安全性\",{\"1\":{\"104\":1}}],[\"这是版本控制中的一个关键步骤\",{\"1\":{\"305\":1}}],[\"这是表中所有字段的唯一标识符的列表\",{\"1\":{\"216\":1}}],[\"这是数据库系统的核心组件之一\",{\"1\":{\"129\":1}}],[\"这是通过位操作实现的\",{\"1\":{\"70\":1}}],[\"这串字节会被复制到第一页的\",{\"1\":{\"123\":1}}],[\"这样不仅提高了查询效率\",{\"1\":{\"161\":1}}],[\"这样可以避免同一个页面的并发写入\",{\"1\":{\"112\":1}}],[\"这样可以使用\",{\"1\":{\"33\":1}}],[\"这样的设计保证了即使在数据操作还未完成的情况下发生崩溃\",{\"1\":{\"85\":1}}],[\"这里就以唯一约束为例\",{\"1\":{\"221\":1}}],[\"这里参考大部分数据库的设计\",{\"1\":{\"96\":1}}],[\"这里使用了位移和按位或运算\",{\"1\":{\"69\":1}}],[\"这里以pgno\",{\"1\":{\"69\":1}}],[\"这个层次主要负责事务的管理\",{\"1\":{\"309\":1}}],[\"这个问题的根源在于事务的执行顺序导致了冲突\",{\"1\":{\"297\":1}}],[\"这个版本对当前事务\",{\"1\":{\"286\":1,\"288\":1}}],[\"这个条件表示\",{\"1\":{\"286\":1,\"288\":1}}],[\"这个过程确保每个新任务都有一个独一无二的标识符\",{\"1\":{\"245\":1}}],[\"这个文件就像是一张任务清单\",{\"1\":{\"231\":1}}],[\"这个隐藏字段不会展示给用户\",{\"1\":{\"222\":1}}],[\"这个字段的名字\",{\"1\":{\"217\":1}}],[\"这个字段保存下一个表的唯一标识符\",{\"1\":{\"216\":1}}],[\"这个结构包含了表名\",{\"1\":{\"216\":1}}],[\"这个方法用于返回记录中的实际数据部分\",{\"1\":{\"304\":1}}],[\"这个方法用于生成日志格式的数据\",{\"1\":{\"303\":1}}],[\"这个方法负责返回所有数据的uid\",{\"1\":{\"154\":1}}],[\"这个方法生成的根节点包含两个初始子节点\",{\"1\":{\"144\":1}}],[\"这个操作通过\",{\"1\":{\"100\":1}}],[\"这个策略涉及对数据库操作的日志记录\",{\"1\":{\"84\":1}}],[\"这个\",{\"1\":{\"53\":1,\"69\":1}}],[\"这通过\",{\"1\":{\"53\":1}}],[\"这避免了缓存抖动问题\",{\"1\":{\"52\":1}}],[\"这减少了不必要的回源操作\",{\"1\":{\"52\":1}}],[\"这种情况被称为\",{\"1\":{\"284\":1}}],[\"这种情况通常在可重复读隔离级别下是不被允许的\",{\"1\":{\"277\":1}}],[\"这种情况下ti直接修改x\",{\"1\":{\"291\":1}}],[\"这种情况下\",{\"1\":{\"222\":1,\"255\":1,\"297\":1}}],[\"这种机制确保了事务的顺序执行\",{\"1\":{\"297\":1}}],[\"这种机制极大地提高了数据库的并发性能\",{\"1\":{\"274\":1}}],[\"这种机制避免了\",{\"1\":{\"52\":1}}],[\"这种方式利用了操作系统重命名文件的原子性\",{\"1\":{\"187\":1}}],[\"这种方法在需要频繁处理大型数组或在多线程环境下操作共享数据时特别有用\",{\"1\":{\"138\":1}}],[\"这种策略确保了在系统资源被频繁访问时\",{\"1\":{\"129\":1}}],[\"这种设计允许快速定位和访问数据\",{\"1\":{\"68\":1}}],[\"这种操作通常会带来较大的性能开销\",{\"1\":{\"51\":1}}],[\"这在后续操作中用于标识用户和管理会话\",{\"1\":{\"45\":1}}],[\"这套系统允许客户端通过\",{\"1\":{\"41\":1}}],[\"这使得客户端能够通过\",{\"1\":{\"26\":1}}],[\"这将启动一个交互式命令行界面\",{\"1\":{\"14\":1,\"181\":1}}],[\"端口运行\",{\"1\":{\"14\":1,\"181\":1}}],[\"该事务不在当前事务\",{\"1\":{\"288\":1}}],[\"该事务在当前事务\",{\"1\":{\"288\":1}}],[\"该模块的主要任务包括表的创建\",{\"1\":{\"207\":1}}],[\"该文件主要记录了数据库的头表uid\",{\"1\":{\"208\":1}}],[\"该文件主要记录了数据库的头表\",{\"1\":{\"186\":1}}],[\"该节点中键的数量\",{\"1\":{\"143\":1}}],[\"该规则避免了在多线程环境中多个事务相互干扰\",{\"1\":{\"87\":1}}],[\"该规则避免了级联回滚的问题\",{\"1\":{\"87\":1}}],[\"该方法将创建新的数据库文件\",{\"1\":{\"44\":1}}],[\"该服务会在本地机器的\",{\"1\":{\"14\":1,\"181\":1}}],[\"该项目凭借其独特的设计理念和简洁的实现方式\",{\"1\":{\"4\":1,\"171\":1}}],[\"lt\",{\"1\":{\"312\":1,\"313\":1,\"316\":1}}],[\"l\",{\"1\":{\"260\":4,\"267\":4,\"268\":10,\"316\":5}}],[\"l1\",{\"1\":{\"161\":1}}],[\"l0\",{\"1\":{\"154\":3,\"161\":2}}],[\"lg\",{\"1\":{\"73\":5,\"90\":3,\"91\":3}}],[\"like\",{\"1\":{\"159\":1}}],[\"list\",{\"1\":{\"113\":1}}],[\"list<table>>\",{\"1\":{\"226\":1}}],[\"list<field>\",{\"1\":{\"216\":1}}],[\"list<boolean>\",{\"1\":{\"198\":1}}],[\"list<byte\",{\"1\":{\"91\":3}}],[\"list<string>\",{\"1\":{\"198\":2,\"199\":2,\"202\":6}}],[\"list<long>>\",{\"1\":{\"259\":2}}],[\"list<long>\",{\"1\":{\"145\":1,\"154\":5,\"155\":1,\"157\":2,\"267\":1,\"268\":2}}],[\"list<pageinfo>\",{\"1\":{\"113\":1}}],[\"lists\",{\"1\":{\"72\":2,\"113\":1,\"114\":2,\"115\":1}}],[\"li\",{\"1\":{\"90\":2,\"91\":2,\"92\":5}}],[\"line\",{\"1\":{\"33\":3}}],[\"lru\",{\"1\":{\"50\":1,\"52\":3,\"60\":1,\"129\":1}}],[\"lastaccessedtime\",{\"1\":{\"46\":3}}],[\"launcherstart\",{\"1\":{\"16\":1,\"183\":1}}],[\"launcher\",{\"1\":{\"14\":3,\"15\":2,\"16\":1,\"17\":1,\"29\":1,\"37\":1,\"181\":3,\"182\":2,\"183\":1,\"184\":1}}],[\"leafsearchrangeres\",{\"1\":{\"145\":3}}],[\"leafsearchrange方法\",{\"1\":{\"145\":1}}],[\"leafsearchrange\",{\"1\":{\"145\":2}}],[\"leafflag\",{\"1\":{\"143\":2}}],[\"leftkey\",{\"1\":{\"145\":3}}],[\"left\",{\"1\":{\"144\":3,\"146\":2,\"161\":1}}],[\"len\",{\"1\":{\"123\":7,\"240\":1,\"242\":2,\"243\":1,\"251\":1}}],[\"length\",{\"1\":{\"32\":3,\"66\":2,\"72\":5,\"81\":1,\"83\":4,\"106\":6,\"126\":2,\"136\":1,\"203\":1,\"219\":1,\"240\":1,\"242\":3,\"243\":1,\"251\":1,\"304\":1}}],[\"level>\",{\"1\":{\"23\":1}}],[\"level\",{\"1\":{\"23\":2,\"290\":1,\"292\":5,\"309\":1}}],[\"lo\",{\"1\":{\"268\":2}}],[\"locking\",{\"1\":{\"297\":1}}],[\"lock>\",{\"1\":{\"259\":1}}],[\"locktable\",{\"0\":{\"257\":1,\"258\":1},\"1\":{\"254\":1,\"255\":1,\"256\":2,\"257\":1,\"258\":1,\"259\":2,\"260\":1,\"261\":1,\"264\":1,\"268\":1,\"269\":4,\"279\":1}}],[\"lock\",{\"1\":{\"57\":12,\"58\":3,\"59\":3,\"66\":1,\"72\":3,\"83\":6,\"97\":3,\"100\":1,\"104\":2,\"113\":2,\"114\":3,\"115\":3,\"146\":2,\"226\":3,\"228\":3,\"245\":1,\"251\":1,\"259\":2,\"260\":6,\"266\":3,\"267\":1,\"268\":4,\"311\":4,\"312\":6,\"313\":3,\"314\":3,\"315\":3,\"316\":5}}],[\"localhost\",{\"1\":{\"13\":1,\"180\":1}}],[\"loadentry\",{\"1\":{\"301\":1,\"309\":1}}],[\"loadtable\",{\"1\":{\"227\":1}}],[\"loadtables\",{\"1\":{\"226\":1,\"227\":1}}],[\"loadcheckpageone\",{\"1\":{\"73\":1}}],[\"load\",{\"1\":{\"44\":1,\"187\":1,\"190\":2,\"220\":1,\"227\":1}}],[\"logical\",{\"1\":{\"158\":1}}],[\"logicop\",{\"1\":{\"154\":3,\"158\":2}}],[\"logs\",{\"1\":{\"91\":3}}],[\"logcache\",{\"1\":{\"91\":8}}],[\"logtype\",{\"1\":{\"89\":2}}],[\"logtyperaw\",{\"1\":{\"72\":2}}],[\"logn\",{\"1\":{\"79\":2,\"82\":2}}],[\"log3\",{\"1\":{\"79\":1}}],[\"log2\",{\"1\":{\"79\":1,\"82\":2}}],[\"log1\",{\"1\":{\"79\":2,\"82\":2}}],[\"logger\",{\"1\":{\"72\":2,\"73\":5,\"77\":1,\"90\":1,\"91\":1}}],[\"logdataitem\",{\"1\":{\"66\":1}}],[\"log\",{\"1\":{\"43\":1,\"72\":4,\"80\":2,\"82\":3,\"83\":16,\"89\":2,\"90\":7,\"91\":11,\"92\":5}}],[\"long>>\",{\"1\":{\"266\":1}}],[\"long>\",{\"1\":{\"259\":3,\"266\":1}}],[\"long2byte\",{\"1\":{\"72\":1,\"146\":1,\"247\":1,\"303\":1,\"305\":1}}],[\"long\",{\"1\":{\"21\":1,\"46\":4,\"55\":1,\"57\":2,\"58\":2,\"59\":1,\"65\":1,\"66\":1,\"69\":5,\"70\":1,\"72\":4,\"73\":2,\"90\":2,\"91\":2,\"100\":1,\"104\":2,\"143\":1,\"144\":4,\"145\":7,\"146\":5,\"154\":1,\"157\":2,\"161\":1,\"216\":2,\"217\":3,\"219\":2,\"220\":2,\"221\":2,\"226\":8,\"227\":2,\"228\":1,\"238\":11,\"240\":1,\"242\":2,\"243\":2,\"245\":2,\"246\":2,\"249\":2,\"260\":2,\"262\":4,\"266\":4,\"267\":3,\"268\":4,\"284\":1,\"286\":3,\"288\":3,\"289\":3,\"290\":5,\"292\":1,\"301\":2,\"303\":1,\"305\":1,\"309\":10,\"311\":2,\"312\":1,\"313\":2,\"314\":2,\"315\":2,\"316\":2}}],[\"使得你可以随时跟踪和管理任务的进展\",{\"1\":{\"245\":1}}],[\"使得数据的修改能够在出现问题时被回滚\",{\"1\":{\"129\":1}}],[\"使得开发者可以轻松构建和管理自己的数据库系统\",{\"1\":{\"26\":1}}],[\"使其在启动\",{\"1\":{\"15\":1,\"182\":1}}],[\"使其可以轻松集成到现有项目中\",{\"1\":{\"2\":1}}],[\"使用字节数组创建一个bytebuffer\",{\"1\":{\"246\":1}}],[\"使用jsqlparser进行sql解析\",{\"0\":{\"194\":1}}],[\"使用了一种保证原子性的更新策略\",{\"1\":{\"186\":1}}],[\"使用了一种自定义的二进制格式用于客户端和服务端之间的通信\",{\"1\":{\"30\":1}}],[\"使用第一个条件字段进行初步查询\",{\"1\":{\"154\":1}}],[\"使用的事务\",{\"1\":{\"146\":1}}],[\"使用读取到的数据\",{\"1\":{\"104\":1}}],[\"使用迭代器模式读取日志\",{\"1\":{\"83\":1}}],[\"使用页面缓存\",{\"1\":{\"70\":1}}],[\"使用完\",{\"1\":{\"66\":1}}],[\"使用\",{\"1\":{\"64\":1,\"70\":1,\"83\":3,\"159\":1}}],[\"使用指南\",{\"2\":{\"18\":1}}],[\"使用以下命令启动数据库服务\",{\"1\":{\"14\":1,\"181\":1}}],[\"使用以下命令创建数据库\",{\"1\":{\"14\":1,\"181\":1}}],[\"使用maven编译项目\",{\"0\":{\"14\":1,\"181\":1}}],[\"默认为\",{\"1\":{\"13\":1,\"180\":1}}],[\"访问数据库服务\",{\"1\":{\"13\":1,\"180\":1}}],[\"r2\",{\"1\":{\"255\":3,\"256\":10}}],[\"r\",{\"1\":{\"161\":3,\"297\":1}}],[\"r1\",{\"1\":{\"161\":1,\"255\":5,\"256\":15}}],[\"r0\",{\"1\":{\"154\":3,\"161\":2}}],[\"rolled\",{\"1\":{\"267\":1}}],[\"rollbacktimeouttransaction\",{\"1\":{\"266\":1,\"267\":1}}],[\"rootraw\",{\"1\":{\"146\":2}}],[\"rootuid\",{\"1\":{\"146\":1}}],[\"roundtripper\",{\"1\":{\"37\":1}}],[\"roundtrip\",{\"1\":{\"37\":2}}],[\"rlock\",{\"1\":{\"145\":2,\"304\":1}}],[\"rightkey\",{\"1\":{\"145\":4,\"146\":2}}],[\"right\",{\"1\":{\"144\":3,\"146\":2,\"161\":1}}],[\"randomaccessfile\",{\"1\":{\"251\":1}}],[\"randombytes\",{\"1\":{\"123\":1}}],[\"randomutil\",{\"1\":{\"123\":1}}],[\"rawfso\",{\"1\":{\"106\":2}}],[\"raw\",{\"1\":{\"33\":2,\"65\":1,\"66\":10,\"72\":15,\"81\":3,\"89\":1,\"92\":6,\"106\":10,\"123\":8,\"125\":4,\"126\":4,\"134\":5,\"136\":2,\"143\":1,\"144\":16,\"145\":9,\"146\":2,\"221\":2,\"227\":2,\"304\":1,\"305\":1,\"315\":2}}],[\"rt\",{\"1\":{\"37\":1}}],[\"replaceall\",{\"1\":{\"199\":1}}],[\"replace\",{\"1\":{\"191\":1,\"199\":1}}],[\"repeatableread\",{\"1\":{\"288\":1}}],[\"repeatable\",{\"1\":{\"23\":1,\"283\":1,\"287\":1,\"292\":1}}],[\"retainall\",{\"1\":{\"154\":3}}],[\"return\",{\"1\":{\"32\":4,\"33\":3,\"34\":1,\"36\":1,\"37\":2,\"44\":2,\"45\":2,\"46\":8,\"57\":2,\"66\":1,\"69\":1,\"70\":1,\"72\":10,\"73\":2,\"80\":1,\"83\":7,\"101\":1,\"104\":1,\"114\":2,\"123\":2,\"125\":3,\"126\":1,\"144\":2,\"145\":3,\"146\":1,\"154\":3,\"155\":1,\"156\":1,\"157\":1,\"158\":3,\"159\":9,\"160\":2,\"161\":1,\"189\":2,\"190\":2,\"196\":10,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":4,\"219\":1,\"220\":1,\"227\":2,\"228\":1,\"243\":1,\"245\":1,\"249\":1,\"260\":3,\"262\":7,\"268\":1,\"284\":1,\"286\":3,\"288\":3,\"289\":3,\"290\":3,\"292\":2,\"301\":1,\"303\":1,\"304\":1,\"309\":1,\"311\":1,\"313\":1,\"314\":3,\"315\":1,\"316\":4}}],[\"reentrantlock\",{\"1\":{\"104\":1,\"226\":1,\"260\":1,\"267\":1}}],[\"redotranscations\",{\"1\":{\"90\":1}}],[\"redo\",{\"1\":{\"84\":1,\"86\":1,\"90\":2,\"92\":1}}],[\"rewind\",{\"1\":{\"82\":2,\"90\":1,\"91\":1}}],[\"record\",{\"1\":{\"157\":2,\"158\":3,\"159\":2}}],[\"recoverupdate\",{\"1\":{\"92\":1,\"106\":3,\"107\":1}}],[\"recoverinsert\",{\"1\":{\"92\":1,\"106\":3,\"107\":1}}],[\"recover\",{\"1\":{\"72\":1,\"73\":2,\"77\":1,\"89\":1}}],[\"receive\",{\"1\":{\"33\":1,\"34\":3,\"36\":1,\"37\":1}}],[\"ref\",{\"1\":{\"58\":3}}],[\"references\",{\"1\":{\"56\":2,\"57\":3,\"58\":3,\"59\":1}}],[\"releasedataitem\",{\"1\":{\"66\":1}}],[\"releaseforcache\",{\"1\":{\"55\":1,\"58\":2,\"59\":1,\"71\":1,\"99\":2,\"100\":1,\"105\":2,\"309\":1}}],[\"release\",{\"1\":{\"53\":1,\"58\":2,\"64\":1,\"66\":3,\"71\":2,\"72\":3,\"92\":2,\"98\":1,\"116\":1,\"301\":1,\"314\":1,\"316\":1}}],[\"removefromlist\",{\"1\":{\"260\":1,\"267\":1}}],[\"removebadtmp\",{\"1\":{\"189\":3}}],[\"removesession\",{\"1\":{\"46\":1}}],[\"removeexecutor\",{\"1\":{\"46\":1}}],[\"remove\",{\"1\":{\"46\":3,\"57\":2,\"58\":2,\"59\":2,\"72\":1,\"114\":1,\"260\":1,\"266\":1,\"267\":3,\"268\":10,\"301\":1,\"309\":1,\"312\":2,\"313\":2}}],[\"removeusersession\",{\"1\":{\"46\":2}}],[\"request\",{\"1\":{\"45\":7}}],[\"resource\",{\"1\":{\"267\":2}}],[\"resources\",{\"1\":{\"267\":3}}],[\"res2\",{\"1\":{\"154\":3}}],[\"res\",{\"1\":{\"145\":11,\"154\":6,\"161\":5}}],[\"response\",{\"1\":{\"45\":2}}],[\"respkg\",{\"1\":{\"37\":4}}],[\"result2\",{\"1\":{\"158\":3}}],[\"result1\",{\"1\":{\"158\":4}}],[\"result\",{\"1\":{\"36\":3,\"196\":4}}],[\"rest\",{\"1\":{\"13\":1,\"180\":1}}],[\"readcommitted\",{\"1\":{\"286\":1}}],[\"readuncommitted\",{\"1\":{\"284\":1}}],[\"readallbytes\",{\"1\":{\"190\":1}}],[\"readline\",{\"1\":{\"33\":1}}],[\"reader\",{\"1\":{\"33\":4}}],[\"read\",{\"1\":{\"23\":3,\"72\":2,\"81\":1,\"83\":2,\"104\":1,\"157\":1,\"198\":8,\"203\":1,\"226\":1,\"242\":1,\"249\":1,\"283\":3,\"284\":1,\"285\":1,\"287\":1,\"290\":2,\"292\":3,\"301\":1,\"309\":1,\"311\":1,\"314\":2}}],[\"react\",{\"1\":{\"3\":2,\"6\":1,\"7\":1,\"170\":2,\"173\":1,\"174\":1}}],[\"runlock\",{\"1\":{\"145\":2,\"304\":1}}],[\"runnable\",{\"1\":{\"36\":1}}],[\"runtimeexception\",{\"1\":{\"32\":1,\"196\":2,\"265\":1}}],[\"run\",{\"1\":{\"13\":1,\"16\":1,\"37\":1,\"180\":1,\"183\":1}}],[\"assert\",{\"1\":{\"268\":1}}],[\"aslist\",{\"1\":{\"219\":3}}],[\"activetransaction\",{\"1\":{\"311\":2,\"312\":3,\"313\":2,\"314\":1,\"315\":1,\"316\":1}}],[\"active\",{\"1\":{\"234\":1,\"236\":1,\"240\":1,\"245\":1,\"251\":1,\"290\":2}}],[\"activeusers\",{\"1\":{\"46\":7}}],[\"acid\",{\"1\":{\"231\":1}}],[\"accept\",{\"1\":{\"198\":1,\"199\":1}}],[\"a\",{\"1\":{\"85\":4,\"86\":12}}],[\"after\",{\"1\":{\"66\":2,\"146\":1,\"305\":1}}],[\"afterhandshake\",{\"1\":{\"45\":1}}],[\"abstract\",{\"1\":{\"55\":2}}],[\"abstractcache<entry>\",{\"1\":{\"309\":1}}],[\"abstractcache<t>\",{\"1\":{\"55\":1}}],[\"abstractcache\",{\"1\":{\"49\":1,\"56\":1,\"279\":1}}],[\"aborted\",{\"1\":{\"234\":1,\"236\":1,\"240\":1,\"251\":1}}],[\"abort\",{\"1\":{\"23\":1,\"91\":1,\"196\":2,\"203\":3,\"226\":1,\"238\":2,\"246\":2,\"251\":1,\"268\":1,\"309\":1,\"313\":3}}],[\"addall\",{\"1\":{\"154\":3}}],[\"additionaluids\",{\"1\":{\"154\":9}}],[\"addresstouid\",{\"1\":{\"69\":1,\"72\":1}}],[\"add\",{\"1\":{\"46\":1,\"72\":3,\"91\":2,\"115\":3,\"116\":1,\"145\":1,\"157\":1,\"198\":3,\"199\":2,\"202\":6,\"219\":3,\"221\":1,\"222\":2,\"228\":1,\"260\":1,\"316\":1}}],[\"addsession\",{\"1\":{\"46\":1}}],[\"addusersession\",{\"1\":{\"44\":1,\"46\":1}}],[\"attrs\",{\"1\":{\"46\":1}}],[\"attributes\",{\"1\":{\"45\":2}}],[\"atomicinteger\",{\"1\":{\"46\":2}}],[\"and\",{\"1\":{\"44\":1,\"154\":3,\"158\":1,\"267\":1,\"286\":7,\"288\":9}}],[\"allocate\",{\"1\":{\"81\":1,\"83\":2,\"104\":1,\"242\":1}}],[\"already\",{\"1\":{\"44\":1}}],[\"alice\",{\"1\":{\"22\":7}}],[\"array2\",{\"1\":{\"133\":2}}],[\"array1\",{\"1\":{\"133\":3}}],[\"arraylist<>\",{\"1\":{\"91\":2,\"145\":1,\"154\":3,\"157\":1,\"198\":3,\"199\":2,\"202\":6,\"216\":1,\"228\":1}}],[\"array\",{\"1\":{\"81\":1,\"83\":2,\"104\":1,\"136\":3,\"137\":1,\"242\":1,\"249\":1}}],[\"arraycopy\",{\"1\":{\"66\":2,\"72\":1,\"106\":2,\"123\":2,\"125\":1,\"126\":1,\"146\":1,\"304\":1,\"305\":1}}],[\"arrays\",{\"1\":{\"32\":2,\"83\":3,\"123\":3,\"125\":1,\"136\":1,\"146\":1,\"219\":3}}],[\"arguments\",{\"1\":{\"16\":2,\"183\":2}}],[\"args=\",{\"1\":{\"14\":2,\"181\":2}}],[\"args\",{\"1\":{\"13\":2,\"37\":1,\"180\":2}}],[\"autoaborted\",{\"1\":{\"290\":1,\"313\":3,\"316\":2}}],[\"autoincrementfields\",{\"1\":{\"219\":3,\"222\":1}}],[\"autoincrement\",{\"1\":{\"202\":4,\"219\":1}}],[\"autowired\",{\"1\":{\"43\":1}}],[\"auto\",{\"1\":{\"21\":1,\"202\":1}}],[\"application\",{\"1\":{\"13\":1,\"16\":1,\"180\":1,\"183\":1}}],[\"equals\",{\"1\":{\"45\":1,\"123\":1,\"154\":3,\"156\":1,\"160\":1,\"203\":1}}],[\"equalsignorecase\",{\"1\":{\"43\":2,\"45\":1,\"196\":4,\"202\":4,\"219\":2}}],[\"e1\",{\"1\":{\"36\":6,\"242\":1}}],[\"e\",{\"1\":{\"36\":9,\"37\":2,\"43\":2,\"46\":2,\"57\":4,\"81\":2,\"82\":4,\"83\":8,\"92\":4,\"100\":2,\"104\":2,\"116\":2,\"189\":2,\"190\":2,\"191\":6,\"196\":3,\"242\":2,\"246\":4,\"247\":4,\"249\":2,\"250\":2,\"265\":2,\"284\":2,\"286\":3,\"288\":3,\"289\":3,\"292\":2,\"314\":3,\"316\":4}}],[\"else\",{\"1\":{\"32\":3,\"43\":2,\"44\":1,\"45\":1,\"46\":1,\"58\":1,\"72\":2,\"90\":1,\"91\":2,\"92\":1,\"145\":1,\"154\":5,\"196\":9,\"202\":3,\"268\":1,\"292\":2,\"314\":2,\"316\":1}}],[\"encountered\",{\"1\":{\"196\":1}}],[\"encodehexstring\",{\"1\":{\"33\":1}}],[\"encode\",{\"1\":{\"32\":1,\"34\":1}}],[\"encoder\",{\"0\":{\"32\":1},\"1\":{\"31\":2,\"32\":1,\"34\":9,\"36\":2,\"37\":2}}],[\"entry2raw\",{\"1\":{\"221\":1}}],[\"entryset\",{\"1\":{\"91\":1,\"266\":1}}],[\"entry\",{\"0\":{\"300\":1,\"301\":1},\"1\":{\"91\":3,\"215\":1,\"221\":7,\"266\":3,\"275\":1,\"279\":1,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"292\":1,\"295\":1,\"299\":2,\"300\":1,\"301\":5,\"303\":1,\"309\":11,\"314\":6,\"315\":2,\"316\":8}}],[\"entry<long\",{\"1\":{\"91\":1,\"266\":2}}],[\"endswith\",{\"1\":{\"203\":1}}],[\"endindex\",{\"1\":{\"196\":3}}],[\"end\",{\"1\":{\"66\":1,\"134\":5,\"136\":1,\"242\":2,\"304\":1}}],[\"enablescheduling\",{\"1\":{\"13\":1,\"180\":1}}],[\"error\",{\"1\":{\"32\":3,\"43\":1,\"44\":1,\"57\":1,\"72\":2,\"82\":1,\"189\":4,\"191\":2,\"228\":1,\"242\":3,\"260\":1,\"309\":1,\"314\":1,\"316\":3}}],[\"err\",{\"1\":{\"31\":1,\"32\":3,\"290\":1,\"312\":2,\"314\":2,\"315\":2,\"316\":6}}],[\"existing\",{\"1\":{\"191\":1}}],[\"exists\",{\"1\":{\"44\":1,\"189\":1}}],[\"expression\",{\"1\":{\"199\":2}}],[\"expressionlist\",{\"1\":{\"199\":3}}],[\"expecting\",{\"1\":{\"196\":1}}],[\"exp\",{\"1\":{\"161\":2}}],[\"expiry\",{\"1\":{\"46\":2}}],[\"exc\",{\"1\":{\"46\":3}}],[\"exception\",{\"1\":{\"31\":2,\"32\":2,\"33\":2,\"34\":3,\"36\":4,\"37\":2,\"45\":3,\"55\":1,\"57\":2,\"70\":1,\"72\":2,\"82\":1,\"92\":2,\"98\":1,\"104\":1,\"116\":1,\"146\":1,\"154\":1,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"161\":1,\"189\":1,\"191\":1,\"196\":1,\"199\":2,\"203\":1,\"219\":1,\"220\":1,\"221\":1,\"226\":6,\"228\":1,\"260\":1,\"290\":1,\"301\":1,\"309\":5,\"312\":1,\"314\":2,\"315\":1,\"316\":3}}],[\"extends\",{\"1\":{\"43\":1}}],[\"exe\",{\"1\":{\"36\":2}}],[\"executed\",{\"1\":{\"43\":1}}],[\"execute\",{\"1\":{\"36\":1,\"37\":2}}],[\"executormap\",{\"1\":{\"46\":5}}],[\"executor>\",{\"1\":{\"46\":1}}],[\"executors\",{\"1\":{\"43\":1}}],[\"executorservice\",{\"1\":{\"43\":3}}],[\"executorservice>\",{\"1\":{\"43\":1}}],[\"executor\",{\"1\":{\"36\":2,\"46\":5}}],[\"exec\",{\"1\":{\"14\":3,\"181\":3}}],[\"example\",{\"1\":{\"22\":2}}],[\"email\",{\"1\":{\"21\":1,\"22\":3}}],[\"edit\",{\"1\":{\"16\":1,\"183\":1}}],[\"easydb能够有效地管理页面的空闲空间\",{\"1\":{\"126\":1}}],[\"easydb使用文档\",{\"0\":{\"19\":1}}],[\"easydb\",{\"0\":{\"1\":1,\"3\":1,\"8\":1,\"15\":1,\"25\":1,\"78\":1,\"84\":1,\"175\":1,\"182\":1},\"1\":{\"1\":1,\"2\":5,\"3\":2,\"4\":1,\"5\":1,\"6\":1,\"7\":1,\"8\":1,\"13\":3,\"15\":1,\"24\":1,\"26\":4,\"29\":2,\"30\":1,\"52\":1,\"53\":1,\"78\":1,\"80\":1,\"83\":1,\"84\":1,\"85\":1,\"87\":3,\"89\":1,\"92\":1,\"129\":3,\"142\":4,\"147\":1,\"148\":1,\"165\":2,\"166\":1,\"167\":1,\"170\":2,\"171\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"180\":3,\"182\":1,\"186\":2,\"187\":1,\"231\":2,\"272\":1,\"273\":1,\"280\":2,\"283\":1,\"284\":1,\"285\":1,\"287\":1,\"289\":1,\"290\":1,\"295\":2,\"298\":3,\"299\":1,\"301\":1}}],[\"应用启动后\",{\"1\":{\"13\":1,\"180\":1}}],[\"应用\",{\"1\":{\"13\":2,\"180\":2}}],[\"启动一个后台线程\",{\"1\":{\"265\":1}}],[\"启动信息的方法\",{\"1\":{\"187\":1}}],[\"启动信息存储\",{\"1\":{\"187\":1}}],[\"启动信息存储在\",{\"1\":{\"186\":1}}],[\"启动信息管理器\",{\"1\":{\"226\":1}}],[\"启动信息管理是数据库启动和运行的重要环节\",{\"1\":{\"208\":1}}],[\"启动信息管理是数据库初始化和运行时的重要组成部分\",{\"1\":{\"186\":1}}],[\"启动信息管理\",{\"0\":{\"187\":1,\"208\":1}}],[\"启动并监听端口\",{\"1\":{\"36\":1}}],[\"启动客户端\",{\"1\":{\"17\":1,\"184\":1}}],[\"启动配置\",{\"1\":{\"17\":1,\"184\":1}}],[\"启动数据库服务\",{\"1\":{\"16\":1,\"183\":1}}],[\"启动项\",{\"0\":{\"16\":1,\"183\":1}}],[\"启动\",{\"0\":{\"17\":1,\"184\":1},\"1\":{\"13\":1,\"15\":1,\"180\":1,\"182\":1}}],[\"phase\",{\"1\":{\"297\":1}}],[\"pop\",{\"1\":{\"203\":1}}],[\"position\",{\"1\":{\"81\":2,\"82\":2,\"83\":9,\"100\":1,\"104\":1,\"242\":1,\"246\":1,\"247\":1,\"249\":1}}],[\"postvisitdirectory\",{\"1\":{\"46\":1}}],[\"postgresql\",{\"1\":{\"1\":1}}],[\"persistself\",{\"1\":{\"219\":1,\"220\":1}}],[\"performfulltablescanwithcondition\",{\"1\":{\"154\":3,\"157\":1}}],[\"peek\",{\"1\":{\"203\":2}}],[\"plainselect\",{\"1\":{\"198\":8}}],[\"please\",{\"1\":{\"43\":1}}],[\"png\",{\"1\":{\"175\":1,\"181\":1,\"184\":1,\"242\":1}}],[\"pindex\",{\"1\":{\"72\":4,\"116\":1}}],[\"pi\",{\"1\":{\"72\":8}}],[\"pc\",{\"1\":{\"70\":2,\"72\":3,\"73\":6,\"90\":3,\"91\":3,\"92\":4,\"97\":1,\"104\":3,\"116\":2}}],[\"pgnoraw\",{\"1\":{\"72\":2}}],[\"pgno\",{\"1\":{\"69\":6,\"70\":5,\"72\":4,\"89\":1,\"92\":7,\"98\":1,\"100\":2,\"101\":3,\"104\":3,\"115\":2}}],[\"pg\",{\"1\":{\"65\":1,\"66\":1,\"70\":3,\"72\":15,\"92\":8,\"98\":1,\"100\":7,\"101\":2,\"105\":4,\"106\":8,\"116\":5,\"123\":8,\"125\":4,\"126\":5}}],[\"putintolist\",{\"1\":{\"260\":2}}],[\"put\",{\"1\":{\"45\":1,\"46\":3,\"57\":4,\"58\":1,\"91\":2,\"227\":1,\"228\":2,\"260\":4,\"262\":5,\"268\":1,\"290\":1,\"311\":1}}],[\"public\",{\"1\":{\"13\":2,\"31\":1,\"32\":3,\"33\":5,\"34\":5,\"37\":4,\"43\":2,\"45\":3,\"46\":19,\"65\":1,\"66\":5,\"69\":2,\"72\":7,\"73\":2,\"83\":2,\"89\":1,\"97\":1,\"98\":1,\"101\":1,\"104\":1,\"106\":2,\"113\":1,\"114\":1,\"115\":1,\"123\":3,\"125\":2,\"126\":1,\"134\":5,\"136\":1,\"143\":1,\"145\":2,\"146\":1,\"180\":2,\"188\":3,\"189\":2,\"190\":1,\"191\":1,\"196\":1,\"198\":1,\"199\":1,\"216\":1,\"217\":1,\"219\":1,\"220\":1,\"221\":1,\"226\":2,\"228\":1,\"238\":1,\"240\":2,\"245\":1,\"250\":1,\"260\":1,\"266\":1,\"268\":1,\"290\":9,\"292\":1,\"301\":3,\"303\":1,\"304\":1,\"305\":1,\"309\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1}}],[\"pkg\",{\"1\":{\"32\":4,\"34\":2,\"36\":5,\"37\":4}}],[\"panic方法处理\",{\"1\":{\"100\":1,\"104\":1,\"246\":2,\"247\":2,\"249\":1}}],[\"panic\",{\"1\":{\"81\":2,\"82\":10,\"83\":12,\"92\":4,\"100\":2,\"104\":2,\"116\":2,\"189\":10,\"190\":2,\"191\":10,\"242\":9,\"246\":4,\"247\":4,\"249\":2,\"250\":2,\"312\":2}}],[\"parseupdate\",{\"1\":{\"196\":1,\"200\":2}}],[\"parseupdatelog\",{\"1\":{\"90\":1,\"91\":1,\"92\":2}}],[\"parseshow\",{\"1\":{\"196\":1}}],[\"parseshort\",{\"1\":{\"125\":1}}],[\"parseselect\",{\"1\":{\"196\":1,\"198\":2}}],[\"parsecreate\",{\"1\":{\"196\":1,\"202\":2}}],[\"parsecommit\",{\"1\":{\"196\":1,\"203\":1}}],[\"parsedrop\",{\"1\":{\"196\":1}}],[\"parsedelete\",{\"1\":{\"196\":1,\"201\":2}}],[\"parsedstatement\",{\"1\":{\"196\":16}}],[\"parsedataitem\",{\"1\":{\"70\":2}}],[\"parseabort\",{\"1\":{\"196\":1,\"203\":1}}],[\"parsebegin\",{\"1\":{\"196\":1,\"203\":1}}],[\"parse\",{\"1\":{\"195\":1,\"196\":3}}],[\"parsevalue\",{\"1\":{\"160\":1}}],[\"parseentry\",{\"1\":{\"157\":1}}],[\"parsewhere\",{\"1\":{\"154\":2,\"167\":1,\"198\":1,\"200\":1,\"201\":1}}],[\"parselong\",{\"1\":{\"146\":1,\"227\":1,\"242\":1}}],[\"parseinsert\",{\"1\":{\"196\":1,\"199\":2}}],[\"parseinsertlog\",{\"1\":{\"90\":1,\"91\":1,\"92\":1}}],[\"parseint\",{\"1\":{\"81\":1,\"83\":3}}],[\"parser\",{\"1\":{\"72\":4,\"81\":2,\"83\":6,\"125\":2,\"146\":2,\"194\":1,\"195\":1,\"203\":1,\"227\":1,\"242\":1,\"247\":1,\"303\":1,\"305\":1}}],[\"param\",{\"1\":{\"72\":2}}],[\"pageoffset\",{\"1\":{\"100\":1,\"104\":1}}],[\"pageone\",{\"1\":{\"72\":3,\"73\":3}}],[\"pageimpl\",{\"1\":{\"97\":1,\"101\":1,\"104\":2}}],[\"pageinfo\",{\"1\":{\"72\":10,\"114\":1,\"115\":1}}],[\"pageindex\",{\"1\":{\"72\":1,\"73\":1,\"110\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":2,\"117\":1},\"2\":{\"119\":1}}],[\"pagenumbers\",{\"1\":{\"101\":1}}],[\"pagenumber\",{\"1\":{\"97\":2,\"104\":3,\"116\":2}}],[\"pagex\",{\"1\":{\"72\":6,\"92\":2,\"116\":1}}],[\"pagecacheimpl\",{\"1\":{\"104\":1}}],[\"pagecache\",{\"1\":{\"70\":1,\"73\":5,\"90\":1,\"91\":1,\"92\":2,\"95\":1,\"97\":2,\"98\":1,\"104\":1,\"113\":1,\"125\":1}}],[\"page\",{\"1\":{\"65\":1,\"70\":4,\"71\":1,\"72\":3,\"92\":2,\"97\":2,\"98\":4,\"99\":1,\"100\":2,\"101\":1,\"104\":3,\"105\":1,\"106\":2,\"113\":1,\"116\":1,\"120\":1,\"121\":1,\"123\":3,\"125\":3,\"126\":1}}],[\"payload\",{\"1\":{\"43\":2}}],[\"packager\",{\"0\":{\"34\":1},\"1\":{\"34\":3,\"36\":7,\"37\":6}}],[\"package\",{\"0\":{\"31\":1},\"1\":{\"30\":1,\"31\":2,\"32\":4,\"34\":2,\"36\":2,\"37\":5}}],[\"pathcache\",{\"1\":{\"259\":1,\"262\":7,\"263\":1}}],[\"paths\",{\"1\":{\"46\":1}}],[\"path\",{\"1\":{\"13\":1,\"43\":1,\"46\":5,\"73\":6,\"180\":1,\"188\":1,\"189\":10,\"191\":3}}],[\"print\",{\"1\":{\"136\":1}}],[\"printsubarray\",{\"1\":{\"136\":3}}],[\"printstacktrace\",{\"1\":{\"36\":4,\"43\":1,\"46\":1,\"57\":1}}],[\"printarray\",{\"1\":{\"136\":2}}],[\"println\",{\"1\":{\"136\":5,\"267\":1,\"312\":2}}],[\"private\",{\"1\":{\"33\":5,\"34\":2,\"43\":3,\"44\":1,\"45\":1,\"46\":15,\"56\":3,\"65\":5,\"80\":1,\"82\":1,\"83\":3,\"89\":2,\"90\":1,\"91\":1,\"92\":2,\"97\":5,\"100\":1,\"113\":4,\"123\":3,\"125\":2,\"136\":2,\"146\":2,\"154\":1,\"155\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"161\":1,\"189\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":3,\"217\":3,\"221\":1,\"226\":4,\"227\":2,\"240\":4,\"242\":1,\"243\":1,\"246\":1,\"247\":1,\"249\":1,\"262\":2,\"265\":1,\"267\":1,\"268\":1,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"301\":6,\"313\":1}}],[\"primarykey\",{\"1\":{\"202\":1,\"219\":4}}],[\"primary\",{\"1\":{\"21\":1,\"202\":1}}],[\"protected\",{\"1\":{\"55\":2,\"57\":1,\"58\":1,\"59\":1,\"70\":1,\"71\":1,\"100\":1,\"104\":1,\"105\":1,\"309\":2}}],[\"projects\",{\"1\":{\"17\":1,\"37\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"program\",{\"1\":{\"16\":2,\"183\":2}}],[\"例如错误信息或执行结果\",{\"1\":{\"226\":1}}],[\"例如字段是否必须唯一\",{\"1\":{\"218\":1}}],[\"例如整数或字符串\",{\"1\":{\"217\":1}}],[\"例如自增\",{\"1\":{\"209\":1,\"214\":1}}],[\"例如\",{\"1\":{\"13\":1,\"16\":1,\"133\":1,\"180\":1,\"183\":1,\"216\":1,\"217\":1,\"221\":1,\"297\":1}}],[\"yml中切换配置文件\",{\"1\":{\"13\":1,\"180\":1}}],[\"yml\",{\"1\":{\"13\":1,\"180\":1}}],[\"克隆项目并进入项目目录\",{\"1\":{\"13\":1,\"180\":1}}],[\"5\",{\"1\":{\"11\":1,\"72\":1,\"133\":1,\"178\":1}}],[\"30s\",{\"1\":{\"264\":1}}],[\"32\",{\"1\":{\"69\":5,\"70\":2}}],[\"3\",{\"1\":{\"11\":1,\"136\":1,\"137\":1,\"178\":1}}],[\"8k\",{\"1\":{\"96\":1}}],[\"8081\",{\"1\":{\"13\":2,\"180\":2}}],[\"8\",{\"1\":{\"11\":1,\"67\":1,\"68\":1,\"69\":2,\"72\":1,\"137\":3,\"146\":1,\"178\":1,\"237\":2,\"240\":1,\"242\":1,\"301\":2,\"303\":3,\"305\":1}}],[\"13331\",{\"1\":{\"80\":1}}],[\"1为非法\",{\"1\":{\"72\":1}}],[\"1字节\",{\"1\":{\"72\":1}}],[\"1l\",{\"1\":{\"69\":2,\"70\":2}}],[\"16\",{\"1\":{\"69\":3,\"70\":1,\"304\":2}}],[\"127\",{\"1\":{\"37\":1,\"45\":1}}],[\"108~115\",{\"1\":{\"123\":1}}],[\"100~107\",{\"1\":{\"123\":1}}],[\"1000\",{\"1\":{\"46\":2}}],[\"10\",{\"1\":{\"22\":1,\"46\":1,\"133\":1,\"136\":2,\"137\":2}}],[\"1\",{\"1\":{\"11\":1,\"31\":1,\"32\":5,\"37\":1,\"45\":2,\"57\":3,\"58\":1,\"65\":1,\"69\":2,\"70\":2,\"72\":2,\"87\":5,\"89\":1,\"91\":1,\"113\":1,\"136\":2,\"137\":1,\"144\":2,\"178\":1,\"196\":2,\"202\":1,\"203\":1,\"235\":1,\"237\":1,\"240\":2,\"242\":1,\"243\":1,\"245\":1,\"262\":1,\"297\":6}}],[\"jsqlparse\",{\"2\":{\"205\":1}}],[\"jsqlparserexception\",{\"1\":{\"196\":1}}],[\"jsqlparser\",{\"1\":{\"194\":2,\"195\":1},\"2\":{\"212\":1}}],[\"jsonobject\",{\"1\":{\"43\":4}}],[\"jdk\",{\"1\":{\"11\":1,\"178\":1}}],[\"javacount\",{\"1\":{\"13\":1,\"14\":2,\"16\":2,\"180\":1,\"181\":2,\"183\":2}}],[\"javabetter\",{\"1\":{\"3\":1,\"170\":1}}],[\"java\",{\"0\":{\"133\":1},\"1\":{\"1\":1,\"14\":3,\"29\":1,\"49\":1,\"77\":1,\"129\":2,\"132\":1,\"133\":3,\"138\":2,\"151\":1,\"181\":3,\"186\":1,\"194\":2,\"195\":1,\"213\":1,\"216\":1,\"217\":1,\"219\":1,\"220\":1,\"222\":1,\"254\":1,\"282\":1,\"295\":1}}],[\"目前支持int\",{\"1\":{\"217\":1}}],[\"目前\",{\"1\":{\"9\":1,\"176\":1}}],[\"提交之前\",{\"1\":{\"298\":1}}],[\"提交一个事务\",{\"1\":{\"238\":1}}],[\"提交\",{\"1\":{\"231\":1,\"251\":1,\"297\":2,\"298\":1,\"309\":1}}],[\"提交事务\",{\"1\":{\"23\":1,\"238\":1}}],[\"提示\",{\"1\":{\"184\":1}}],[\"提取表名\",{\"1\":{\"202\":1}}],[\"提取删除操作的表名和\",{\"1\":{\"201\":1}}],[\"提取更新的表名\",{\"1\":{\"200\":1}}],[\"提取插入的数据表名\",{\"1\":{\"199\":1}}],[\"提取查询的字段\",{\"1\":{\"198\":1}}],[\"提取页面编号\",{\"1\":{\"69\":1}}],[\"提取页面编号则需要将\",{\"1\":{\"69\":1}}],[\"提取偏移量\",{\"1\":{\"69\":1}}],[\"提高系统的整体性能\",{\"1\":{\"279\":1}}],[\"提高数据插入的效率和性能\",{\"1\":{\"68\":1}}],[\"提高了数据访问效率\",{\"1\":{\"64\":1}}],[\"提高了系统的整体效率和稳定性\",{\"1\":{\"60\":1}}],[\"提升数据检索的效率\",{\"1\":{\"9\":1,\"176\":1}}],[\"提供高效的数据访问\",{\"1\":{\"68\":1}}],[\"提供了数据的多版本存储与管理功能\",{\"1\":{\"275\":1}}],[\"提供了数据的存储和访问接口\",{\"1\":{\"74\":1}}],[\"提供了\",{\"1\":{\"148\":1}}],[\"提供了基于\",{\"1\":{\"142\":1}}],[\"提供了两种基本的操作\",{\"1\":{\"85\":1}}],[\"提供了崩溃后的数据恢复功能\",{\"1\":{\"78\":1}}],[\"提供了读取\",{\"1\":{\"68\":1}}],[\"提供了更高级别的\",{\"1\":{\"34\":1}}],[\"提供了一个直观的命令行界面\",{\"1\":{\"6\":1,\"173\":1}}],[\"提供轻量级\",{\"1\":{\"7\":1,\"174\":1}}],[\"提供快速的数据检索与管理能力\",{\"1\":{\"2\":1}}],[\"树在插入和删除操作时会动态调整\",{\"1\":{\"146\":1}}],[\"树执行插入和搜索操作\",{\"1\":{\"145\":1}}],[\"树中\",{\"1\":{\"144\":1}}],[\"树由多个节点\",{\"1\":{\"143\":1}}],[\"树的节点结构\",{\"1\":{\"166\":1}}],[\"树的操作过程中\",{\"1\":{\"147\":1}}],[\"树的引用\",{\"1\":{\"143\":1}}],[\"树的算法实现\",{\"1\":{\"142\":1}}],[\"树的聚簇索引功能\",{\"1\":{\"142\":1}}],[\"树的数据索引\",{\"1\":{\"9\":1,\"176\":1}}],[\"树索引\",{\"1\":{\"165\":1}}],[\"树索引的模块\",{\"1\":{\"142\":1,\"166\":1}}],[\"树索引结构\",{\"1\":{\"2\":1}}],[\"确保全局锁释放是在末尾\",{\"1\":{\"313\":1}}],[\"确保事务像是按顺序一个接一个执行的\",{\"1\":{\"289\":1}}],[\"确保事务只能读取到事务开始时已经提交的数据版本\",{\"1\":{\"287\":1}}],[\"确保资源的正确释放\",{\"1\":{\"251\":1}}],[\"确保资源只有在引用次数为零时才会被驱逐\",{\"1\":{\"52\":1}}],[\"确保文件的正确性\",{\"1\":{\"251\":1}}],[\"确保文件的正确性和完整性\",{\"1\":{\"68\":1}}],[\"确保任务的最终状态被准确记录\",{\"1\":{\"246\":1}}],[\"确保任务按计划进行\",{\"1\":{\"245\":1}}],[\"确保任务按计划进行或及时处理任何异常情况\",{\"1\":{\"233\":1}}],[\"确保整个数据库系统能够在高并发操作下正常运行\",{\"1\":{\"231\":1}}],[\"确保拥有一个索引字段\",{\"1\":{\"155\":1}}],[\"确保了数据的一致性和安全性\",{\"1\":{\"298\":1}}],[\"确保了数据的一致性和操作的高效性\",{\"1\":{\"209\":1}}],[\"确保了数据库系统的并发控制和数据一致性\",{\"1\":{\"280\":1}}],[\"确保了数据操作的高效性\",{\"1\":{\"129\":1}}],[\"确保了对\",{\"1\":{\"187\":1}}],[\"确保了系统在发生故障时能够根据日志进行数据恢复\",{\"1\":{\"129\":1}}],[\"确保日志已经写入磁盘后才开始实际的数据操作\",{\"1\":{\"85\":1}}],[\"确保线程安全\",{\"1\":{\"72\":1,\"100\":1,\"104\":1,\"114\":1,\"115\":1}}],[\"确保数据对当前事务是可见的\",{\"1\":{\"314\":1}}],[\"确保数据访问的安全性\",{\"1\":{\"304\":1}}],[\"确保数据操作能够顺利完成或在异常情况下能够安全回滚\",{\"1\":{\"231\":1}}],[\"确保数据操作的原子性\",{\"1\":{\"68\":1}}],[\"确保数据库操作的完整性和一致性\",{\"1\":{\"210\":1}}],[\"确保数据库在单线程和多线程环境下的可靠性和一致性\",{\"1\":{\"92\":1}}],[\"确保数据写入文件\",{\"1\":{\"191\":1}}],[\"确保数据的完整性和可靠性\",{\"1\":{\"129\":1}}],[\"确保数据的完整性\",{\"1\":{\"107\":1}}],[\"确保数据的原子性和线程安全性\",{\"1\":{\"100\":1}}],[\"确保数据的安全性和一致性\",{\"1\":{\"74\":1}}],[\"确保数据的一致性和完整性\",{\"1\":{\"53\":1}}],[\"确保数据的正确性和结构的一致性\",{\"1\":{\"9\":1,\"176\":1}}],[\"确保内存资源的有效利用\",{\"1\":{\"53\":1}}],[\"确保在资源被主动释放前不会被驱逐\",{\"1\":{\"53\":1}}],[\"确保在发生错误时\",{\"1\":{\"9\":1,\"176\":1}}],[\"确保系统在高并发情况下的稳定性\",{\"1\":{\"52\":1}}],[\"确保系统的稳定性\",{\"1\":{\"46\":1}}],[\"确保正确关闭数据库连接和释放资源\",{\"1\":{\"46\":1}}],[\"确保所有路径都能正确解析\",{\"1\":{\"16\":1,\"183\":1}}],[\"确保调度序列的可串行化\",{\"1\":{\"9\":1,\"176\":1}}],[\"供上层模块使用\",{\"1\":{\"9\":1,\"129\":1,\"176\":1}}],[\"供其他模块查询特定事务的状态\",{\"1\":{\"9\":1,\"176\":1}}],[\"将该事务从等待队列和锁表中移除\",{\"1\":{\"267\":1}}],[\"将会被阻塞在等待\",{\"1\":{\"255\":1}}],[\"将新的事务总数转换为字节数组\",{\"1\":{\"247\":1}}],[\"将新创建的表添加到当前事务的表列表中\",{\"1\":{\"228\":1}}],[\"将新创建的表放入缓存\",{\"1\":{\"228\":1}}],[\"将xid加一\",{\"1\":{\"247\":1}}],[\"将bytebuffer中的数据写入到文件通道\",{\"1\":{\"246\":1,\"247\":1}}],[\"将文件通道的位置设置为0\",{\"1\":{\"247\":1}}],[\"将文件通道的位置设置为offset\",{\"1\":{\"246\":1,\"249\":1}}],[\"将文件通道的位置设置为当前位置\",{\"1\":{\"83\":2}}],[\"将事务\",{\"1\":{\"303\":1}}],[\"将事务状态设置为status\",{\"1\":{\"246\":1}}],[\"将事务id对应的log添加到集合中\",{\"1\":{\"91\":1}}],[\"将事务id转换为字节数组\",{\"1\":{\"72\":1}}],[\"将表对象加入缓存\",{\"1\":{\"227\":1}}],[\"将表达式转换为字符串并去掉单引号\",{\"1\":{\"199\":1}}],[\"将临时文件移动并替换原文件\",{\"1\":{\"191\":1}}],[\"将字符串值转换为字段的实际类型\",{\"1\":{\"160\":1}}],[\"将条件的字符串值转换为适当的对象类型\",{\"1\":{\"159\":1}}],[\"将启动时的校验字节复制到关闭时的存储位置\",{\"1\":{\"123\":1}}],[\"将每个页面的空闲空间信息填充到\",{\"1\":{\"116\":1}}],[\"将每个页面的空闲空间信息分配到相应的区间中\",{\"1\":{\"112\":1}}],[\"将每一页划分为40个区间\",{\"1\":{\"113\":1}}],[\"将key转换为页码\",{\"1\":{\"104\":1}}],[\"将pg的空闲空间偏移量设置为offset\",{\"1\":{\"106\":1}}],[\"将pg的dirty标志设置为true\",{\"1\":{\"72\":1,\"106\":2}}],[\"将page的数据包装成bytebuffer\",{\"1\":{\"100\":1}}],[\"将默认数据页大小定为\",{\"1\":{\"96\":1}}],[\"将日志记录添加到对应的日志列表中\",{\"1\":{\"91\":2}}],[\"将日志文件的读取位置重置到开始\",{\"1\":{\"91\":1}}],[\"将日志写入日志文件\",{\"1\":{\"72\":1}}],[\"将其从\",{\"1\":{\"86\":1}}],[\"将其写入到文件\",{\"1\":{\"81\":1}}],[\"将位置\",{\"1\":{\"85\":1,\"86\":4}}],[\"将数据写入临时文件\",{\"1\":{\"191\":1}}],[\"将数据写入页面\",{\"1\":{\"126\":1}}],[\"将数据写入到文件中\",{\"1\":{\"100\":1}}],[\"将数据插入页面\",{\"1\":{\"126\":1}}],[\"将数据插入到指定的偏移位置\",{\"1\":{\"106\":1}}],[\"将数据的长度转换为字节数组\",{\"1\":{\"83\":1}}],[\"将数据解析成完整log\",{\"1\":{\"83\":1}}],[\"将当前位置重置为文件的开始位置\",{\"1\":{\"82\":2}}],[\"将raw的数据复制到pg的数据中的offset位置\",{\"1\":{\"72\":1,\"106\":2}}],[\"将raw插入pg中的offset位置\",{\"1\":{\"106\":2}}],[\"将raw插入pg中\",{\"1\":{\"72\":1}}],[\"将所有字节数组连接在一起\",{\"1\":{\"72\":1}}],[\"将页面编号和空闲空间大小添加到\",{\"1\":{\"116\":1}}],[\"将页面编号转换为字节数组\",{\"1\":{\"72\":1}}],[\"将页面信息添加到对应的区间列表中\",{\"1\":{\"115\":1}}],[\"将页面重新插入\",{\"1\":{\"115\":1}}],[\"将页面重新添加到页面索引中\",{\"1\":{\"72\":1}}],[\"将输入的数据包装成dataitem的原始格式\",{\"1\":{\"72\":1}}],[\"将高32位对齐到低位\",{\"1\":{\"69\":1}}],[\"将缓存中的资源计数减一\",{\"1\":{\"58\":1}}],[\"将获取到的资源添加到缓存中\",{\"1\":{\"57\":1}}],[\"将进入交互式命令行\",{\"1\":{\"17\":1,\"184\":1}}],[\"将\",{\"1\":{\"9\":1,\"16\":1,\"70\":1,\"83\":1,\"86\":3,\"87\":2,\"159\":1,\"176\":1,\"183\":1,\"256\":2}}],[\"系统需要在ti修改x之前检查是否存在版本跳跃的风险\",{\"1\":{\"292\":1}}],[\"系统必须进行检查并在必要时强制事务回滚\",{\"1\":{\"291\":1}}],[\"系统必须执行回源操作\",{\"1\":{\"51\":1}}],[\"系统将回滚当前事务\",{\"1\":{\"277\":1}}],[\"系统将回滚这个事务\",{\"1\":{\"264\":1}}],[\"系统将读取\",{\"1\":{\"81\":1}}],[\"系统采用了头插法\",{\"1\":{\"226\":1}}],[\"系统还会自动生成隐藏字段\",{\"1\":{\"209\":1}}],[\"系统仍然可以通过兄弟节点恢复大部分操作\",{\"1\":{\"148\":1}}],[\"系统仍可以通过日志恢复数据\",{\"1\":{\"85\":1}}],[\"系统设置了一个\",{\"1\":{\"146\":1}}],[\"系统可以检测到是否存在循环依赖\",{\"1\":{\"261\":1}}],[\"系统可以在发生崩溃后有效地恢复数据\",{\"1\":{\"107\":1}}],[\"系统可以减少不必要的磁盘\",{\"1\":{\"107\":1}}],[\"系统可以根据这些日志内容恢复数据文件\",{\"1\":{\"78\":1}}],[\"系统崩溃\",{\"1\":{\"87\":2}}],[\"系统首先根据当前的fso确定插入位置\",{\"1\":{\"126\":1}}],[\"系统首先将数据封装成日志格式\",{\"1\":{\"83\":1}}],[\"系统首先校验\",{\"1\":{\"82\":1}}],[\"系统能够确保资源的有效使用和及时释放\",{\"1\":{\"60\":1}}],[\"系统能够根据日志恢复数据\",{\"1\":{\"9\":1,\"176\":1}}],[\"系统会立即中断其中一个事务\",{\"1\":{\"278\":1}}],[\"系统会立即触发\",{\"1\":{\"242\":1}}],[\"系统会生成该记录的一个新版本\",{\"1\":{\"275\":1}}],[\"系统会生成一串随机字节并存储在第一页的\",{\"1\":{\"123\":1}}],[\"系统会为该数据生成一个新的版本\",{\"1\":{\"274\":1}}],[\"系统会直接停机\",{\"1\":{\"242\":1}}],[\"系统会直接抛出异常而不是自动驱逐资源\",{\"1\":{\"52\":1}}],[\"系统会自动加载并初始化表的信息\",{\"1\":{\"226\":1}}],[\"系统会自动生成一个隐藏字段来作为表的主键或索引字段\",{\"1\":{\"222\":1}}],[\"系统会根据用户的输入自动处理每个字段的约束条件\",{\"1\":{\"219\":1}}],[\"系统会比较这两处的字节\",{\"1\":{\"123\":1}}],[\"系统会初始化\",{\"1\":{\"81\":1}}],[\"系统会从磁盘中回源获取数据\",{\"1\":{\"53\":1}}],[\"系统中\",{\"1\":{\"52\":1}}],[\"系统根据客户端\",{\"1\":{\"44\":1}}],[\"系统内置了丰富的条件约束与主键索引功能\",{\"1\":{\"2\":1}}],[\"日志\",{\"2\":{\"94\":1}}],[\"日志格式操作\",{\"0\":{\"302\":1}}],[\"日志格式\",{\"0\":{\"89\":1}}],[\"日志格式与结构\",{\"0\":{\"79\":1}}],[\"日志不会相互交错\",{\"1\":{\"86\":1}}],[\"日志记录为\",{\"1\":{\"86\":2}}],[\"日志记录格式\",{\"1\":{\"85\":1}}],[\"日志记录与恢复\",{\"1\":{\"68\":1}}],[\"日志写入时\",{\"1\":{\"83\":1}}],[\"日志迭代与写入\",{\"0\":{\"83\":1}}],[\"日志文件按特定的格式存储\",{\"1\":{\"129\":1}}],[\"日志文件打开时\",{\"1\":{\"81\":1}}],[\"日志文件创建时\",{\"1\":{\"81\":1}}],[\"日志文件的创建与初始化\",{\"0\":{\"81\":1}}],[\"日志文件的校验和\",{\"0\":{\"80\":1}}],[\"日志以二进制文件的形式存储\",{\"1\":{\"79\":1}}],[\"日志管理和数据恢复\",{\"1\":{\"129\":1}}],[\"日志管理\",{\"0\":{\"77\":1},\"1\":{\"9\":1,\"176\":1}}],[\"日志与恢复机制\",{\"1\":{\"2\":1}}],[\"以实现对数据条目的缓存管理\",{\"1\":{\"309\":1}}],[\"以供其他事务读取\",{\"1\":{\"298\":1}}],[\"以保障数据在高并发环境下的正确性与可靠性\",{\"1\":{\"231\":1}}],[\"以记录最新的表链表头部的\",{\"1\":{\"226\":1}}],[\"以支持数据查询和唯一性保证\",{\"1\":{\"209\":1}}],[\"以支持事务回滚\",{\"1\":{\"66\":1}}],[\"以及数据的插入\",{\"1\":{\"309\":1}}],[\"以及它自己创建或修改的版本\",{\"1\":{\"289\":1}}],[\"以及如何通过路径缓存优化死锁检测\",{\"1\":{\"257\":1}}],[\"以及如何在全表扫描过程中结合条件进行数据过滤\",{\"1\":{\"167\":1}}],[\"以及是否自动增长\",{\"1\":{\"220\":1}}],[\"以及是否需要自动增长\",{\"1\":{\"218\":1}}],[\"以及一个可能的索引\",{\"1\":{\"217\":1}}],[\"以及一个初始键值\",{\"1\":{\"144\":1}}],[\"以及对字段约束\",{\"1\":{\"207\":1}}],[\"以及在节点操作中的错误处理与恢复机制\",{\"1\":{\"166\":1}}],[\"以及相关的元数据信息如数据大小和有效标志等\",{\"1\":{\"64\":1}}],[\"以确保在同一时间内只有一个事务可以执行\",{\"1\":{\"311\":1}}],[\"以确保整体系统的安全性和稳定性\",{\"1\":{\"242\":1}}],[\"以确保其合法性\",{\"1\":{\"242\":1}}],[\"以确保找到足够大的空间\",{\"1\":{\"114\":1}}],[\"以确保数据库在上次关闭时是正常的\",{\"1\":{\"122\":1}}],[\"以确保数据的一致性\",{\"1\":{\"277\":1}}],[\"以确保数据的持久性\",{\"1\":{\"101\":1}}],[\"以确保数据的安全性和可靠性\",{\"1\":{\"68\":1}}],[\"以确保数据修改的原子性和一致性\",{\"1\":{\"64\":1}}],[\"以上的代码实现了\",{\"1\":{\"92\":1}}],[\"以下是缓存管理方法的实现\",{\"1\":{\"309\":1}}],[\"以下是一个具体的例子\",{\"1\":{\"298\":1}}],[\"以下是\",{\"1\":{\"129\":1,\"134\":1,\"272\":1,\"309\":1}}],[\"以下是插入操作的代码示例\",{\"1\":{\"126\":1}}],[\"以下是fso管理的代码示例\",{\"1\":{\"125\":1}}],[\"以下是实现代码\",{\"1\":{\"123\":1}}],[\"以下是计算校验和的核心逻辑\",{\"1\":{\"80\":1}}],[\"以下步骤将指导你如何配置\",{\"1\":{\"15\":1,\"182\":1}}],[\"以便支持回滚\",{\"1\":{\"305\":1}}],[\"以便于查找\",{\"1\":{\"143\":1}}],[\"以便在需要时将其写回磁盘\",{\"1\":{\"126\":1}}],[\"以便后续可以调用\",{\"1\":{\"159\":1}}],[\"以便后续插入操作可以准确地找到空闲位置\",{\"1\":{\"125\":1}}],[\"以便后续插入操作可以继续使用该页面\",{\"1\":{\"115\":1}}],[\"以便后续处理使用\",{\"1\":{\"45\":1}}],[\"以便其他插入操作可以继续使用\",{\"1\":{\"112\":1}}],[\"以便接下来提取出页面编号\",{\"1\":{\"70\":1}}],[\"以便将高\",{\"1\":{\"69\":1}}],[\"以便回收内存资源\",{\"1\":{\"64\":1}}],[\"以避免并发情况下重复获取相同的资源\",{\"1\":{\"56\":1}}],[\"以创建一个新的启动配置\",{\"1\":{\"16\":1,\"183\":1}}],[\"以满足插入需求\",{\"1\":{\"112\":1}}],[\"以满足不同的并发需求\",{\"1\":{\"9\":1,\"176\":1}}],[\"以满足更多应用场景的需求\",{\"1\":{\"4\":1,\"171\":1}}],[\"以提高数据访问的效率\",{\"1\":{\"9\":1,\"176\":1}}],[\"管理事务\",{\"1\":{\"251\":1}}],[\"管理每个用户的数据库连接和事务\",{\"1\":{\"46\":1}}],[\"管理日志文件\",{\"1\":{\"9\":1,\"176\":1}}],[\"管理\",{\"1\":{\"9\":1,\"176\":1}}],[\"它必须先获得这个数据项的锁\",{\"1\":{\"297\":1}}],[\"它们可能会相互等待\",{\"1\":{\"297\":1}}],[\"它们同时对变量\",{\"1\":{\"297\":1}}],[\"它们针对的是同一个数据项\",{\"1\":{\"297\":1}}],[\"它们分别要访问两个资源\",{\"1\":{\"255\":1}}],[\"它可以避免读取未提交的数据\",{\"1\":{\"285\":1}}],[\"它可以随时知道哪些任务正在进行\",{\"1\":{\"234\":1}}],[\"它通过维护每个数据项的多个版本\",{\"1\":{\"274\":1}}],[\"它通过维护一系列数据结构来管理事务对资源的请求\",{\"1\":{\"258\":1}}],[\"它先为事务分配一个新的\",{\"1\":{\"245\":1}}],[\"它就像是你的任务调度器\",{\"1\":{\"233\":1}}],[\"它还提供了接口供其他模块查询事务状态\",{\"1\":{\"231\":1}}],[\"它还负责定期检查并清理过期的会话及其相关的数据库文件\",{\"1\":{\"46\":1}}],[\"它还负责解析\",{\"1\":{\"9\":1,\"176\":1}}],[\"它负责确保数据库操作的原子性\",{\"1\":{\"231\":1}}],[\"它负责解析客户端发送的\",{\"1\":{\"43\":1}}],[\"它首先将\",{\"1\":{\"196\":1}}],[\"它基于\",{\"1\":{\"195\":1}}],[\"它为\",{\"1\":{\"142\":1}}],[\"它为我们提供了一种在内存中高效操作数组的解决方案\",{\"1\":{\"129\":1}}],[\"它仅用于执行启动检查\",{\"1\":{\"122\":1}}],[\"它遍历所有页面\",{\"1\":{\"116\":1}}],[\"它的值为\",{\"1\":{\"217\":1}}],[\"它的主要作用是缓存每个页面的空闲空间信息\",{\"1\":{\"111\":1}}],[\"它的设计和实现类似于\",{\"1\":{\"26\":1}}],[\"它不会包含在日志文件的校验和中\",{\"1\":{\"82\":1}}],[\"它是\",{\"1\":{\"67\":1}}],[\"它主要提供以下功能\",{\"1\":{\"64\":1}}],[\"它允许服务器和客户端之间进行实时\",{\"1\":{\"42\":1}}],[\"它封装了传输的数据和可能发生的异常\",{\"1\":{\"30\":1}}],[\"它支持启动服务器并允许多个客户端通过\",{\"1\":{\"29\":1}}],[\"它提供接口\",{\"1\":{\"9\":1,\"176\":1}}],[\"它旨在为开发者提供一个便捷且功能丰富的数据库解决方案\",{\"1\":{\"1\":1}}],[\"负责创建新表\",{\"1\":{\"228\":1}}],[\"负责数据的存储和读取操作\",{\"1\":{\"226\":1}}],[\"负责存储和管理具体的数据内容\",{\"1\":{\"64\":1}}],[\"负责管理数据记录\",{\"1\":{\"279\":1}}],[\"负责管理数据库中的所有表及其结构\",{\"1\":{\"207\":1}}],[\"负责管理数据库中的表和字段信息\",{\"1\":{\"9\":1,\"176\":1}}],[\"负责管理数据库的事务和数据版本\",{\"1\":{\"272\":1}}],[\"负责管理数据库的\",{\"1\":{\"129\":1}}],[\"负责管理\",{\"1\":{\"165\":1}}],[\"负责管理底层数据的访问\",{\"1\":{\"67\":1,\"74\":1}}],[\"负责管理所有活跃用户的会话\",{\"1\":{\"46\":1}}],[\"负责管理事务的状态\",{\"1\":{\"9\":1,\"176\":1}}],[\"负责实现基于\",{\"1\":{\"9\":1,\"176\":1}}],[\"负责解析并执行用户提交的\",{\"1\":{\"7\":1,\"174\":1}}],[\"职责\",{\"1\":{\"9\":5,\"176\":5}}],[\"iterator\",{\"1\":{\"266\":5}}],[\"iterator<map\",{\"1\":{\"266\":1}}],[\"itemslistvisitoradapter\",{\"1\":{\"199\":1}}],[\"illegalargumentexception\",{\"1\":{\"158\":1,\"159\":1,\"219\":1,\"292\":1}}],[\"ik\",{\"1\":{\"145\":6}}],[\"io\",{\"1\":{\"82\":1,\"83\":2}}],[\"ioexception\",{\"1\":{\"33\":2,\"36\":2,\"37\":1,\"43\":2,\"44\":1,\"46\":5,\"81\":1,\"82\":1,\"83\":4,\"100\":1,\"104\":1,\"190\":1,\"191\":2,\"242\":2,\"246\":2,\"247\":2,\"249\":1,\"250\":1}}],[\"i++\",{\"1\":{\"72\":1,\"116\":1,\"136\":2,\"219\":1}}],[\"i\",{\"1\":{\"51\":1,\"52\":1,\"72\":2,\"85\":2,\"86\":3,\"91\":4,\"96\":1,\"107\":1,\"116\":3,\"136\":7,\"145\":5,\"219\":4}}],[\"isvisible\",{\"1\":{\"314\":1,\"316\":1}}],[\"isversionskip\",{\"1\":{\"292\":1,\"316\":1}}],[\"isvalid\",{\"1\":{\"72\":1}}],[\"isheldbycurrentthread\",{\"1\":{\"267\":1}}],[\"iscommitted\",{\"1\":{\"238\":2,\"249\":1,\"251\":1,\"286\":2,\"288\":2,\"289\":2,\"292\":1}}],[\"isunique\",{\"1\":{\"219\":2,\"220\":2,\"221\":1}}],[\"isnotnull\",{\"1\":{\"219\":3,\"220\":2}}],[\"isprimarykey\",{\"1\":{\"219\":4}}],[\"isaborted\",{\"1\":{\"238\":2,\"249\":1,\"251\":1}}],[\"isautoincrement\",{\"1\":{\"219\":3,\"220\":2}}],[\"isasc\",{\"1\":{\"198\":1}}],[\"isactive\",{\"1\":{\"90\":2,\"91\":2,\"238\":2,\"249\":1,\"251\":1}}],[\"isinsnapshot\",{\"1\":{\"288\":2,\"289\":2,\"290\":1,\"292\":1}}],[\"isinsertlog\",{\"1\":{\"90\":1,\"91\":2}}],[\"isinlist\",{\"1\":{\"260\":1}}],[\"isindexed\",{\"1\":{\"155\":1,\"156\":1,\"219\":4,\"221\":1,\"222\":1}}],[\"isdirty\",{\"1\":{\"100\":1,\"105\":1}}],[\"isempty\",{\"1\":{\"45\":1,\"46\":1,\"199\":2}}],[\"is\",{\"1\":{\"44\":1,\"286\":6,\"288\":12}}],[\"isolationlevel\",{\"1\":{\"203\":2,\"282\":1,\"290\":8,\"292\":5,\"311\":7,\"312\":2,\"313\":4}}],[\"isolation\",{\"1\":{\"23\":2,\"203\":2,\"292\":1},\"2\":{\"294\":1}}],[\"ipdirectory\",{\"1\":{\"44\":3}}],[\"ip\",{\"1\":{\"43\":1,\"44\":1,\"45\":4}}],[\"if\",{\"1\":{\"32\":5,\"33\":1,\"37\":1,\"43\":2,\"44\":4,\"45\":3,\"46\":6,\"57\":3,\"58\":1,\"72\":7,\"73\":1,\"82\":2,\"83\":4,\"90\":4,\"91\":7,\"92\":2,\"100\":1,\"105\":1,\"106\":1,\"114\":2,\"145\":4,\"154\":8,\"155\":1,\"157\":2,\"158\":1,\"159\":2,\"160\":1,\"189\":4,\"191\":2,\"196\":11,\"198\":2,\"199\":2,\"200\":1,\"201\":1,\"202\":7,\"203\":2,\"219\":3,\"220\":1,\"221\":2,\"222\":1,\"228\":2,\"242\":2,\"260\":3,\"262\":6,\"266\":1,\"267\":3,\"268\":4,\"286\":3,\"288\":3,\"289\":3,\"290\":2,\"292\":2,\"309\":1,\"311\":1,\"312\":2,\"313\":4,\"314\":3,\"315\":1,\"316\":6}}],[\"id\",{\"1\":{\"21\":1,\"43\":1,\"146\":1,\"246\":1,\"251\":1,\"303\":2,\"305\":2}}],[\"idea\",{\"0\":{\"15\":1,\"182\":1},\"1\":{\"15\":2,\"16\":1,\"182\":2,\"183\":1}}],[\"ide\",{\"1\":{\"13\":1,\"180\":1}}],[\"incrxidcounter\",{\"0\":{\"247\":1},\"1\":{\"245\":1,\"247\":1,\"251\":1}}],[\"incrementandget\",{\"1\":{\"46\":2,\"101\":1}}],[\"increment\",{\"1\":{\"21\":1,\"202\":1}}],[\"invalid\",{\"1\":{\"196\":1}}],[\"invalidpkgdataexception\",{\"1\":{\"32\":2}}],[\"instanceof\",{\"1\":{\"45\":1,\"196\":7,\"198\":1}}],[\"insertstmt\",{\"1\":{\"199\":6}}],[\"insertobj\",{\"1\":{\"199\":8,\"221\":3}}],[\"insertloginfo\",{\"1\":{\"90\":1,\"91\":1,\"92\":1}}],[\"insertlog\",{\"1\":{\"72\":2,\"89\":1}}],[\"insert\",{\"1\":{\"22\":3,\"72\":6,\"85\":1,\"89\":1,\"126\":1,\"146\":1,\"196\":2,\"199\":2,\"210\":1,\"221\":3,\"226\":3,\"309\":1,\"315\":3}}],[\"in\",{\"1\":{\"44\":1,\"288\":6}}],[\"initdata\",{\"1\":{\"98\":1,\"101\":2}}],[\"initpageone\",{\"1\":{\"73\":1}}],[\"initraw\",{\"1\":{\"72\":1}}],[\"initializedatabase\",{\"1\":{\"44\":2}}],[\"initialized\",{\"1\":{\"44\":1}}],[\"init\",{\"1\":{\"43\":3,\"44\":2,\"81\":1}}],[\"info\",{\"1\":{\"43\":1}}],[\"inputstreamreader\",{\"1\":{\"33\":1}}],[\"int64\",{\"1\":{\"133\":1}}],[\"int2byte\",{\"1\":{\"72\":1,\"81\":1,\"83\":3}}],[\"integer\",{\"1\":{\"155\":1,\"262\":1}}],[\"integer>\",{\"1\":{\"56\":1,\"259\":1}}],[\"interface\",{\"1\":{\"98\":1,\"226\":1,\"238\":1,\"309\":1}}],[\"internabort\",{\"1\":{\"313\":2,\"316\":2}}],[\"internal\",{\"1\":{\"32\":1}}],[\"internnext\",{\"1\":{\"82\":1,\"83\":3}}],[\"interruptedexception\",{\"1\":{\"57\":1,\"265\":1}}],[\"intervals\",{\"1\":{\"72\":2,\"113\":3,\"114\":2}}],[\"interval\",{\"1\":{\"46\":2,\"265\":1}}],[\"intellij\",{\"0\":{\"15\":1,\"182\":1},\"1\":{\"15\":2,\"16\":1,\"182\":2,\"183\":1}}],[\"into\",{\"1\":{\"22\":2}}],[\"int\",{\"1\":{\"21\":2,\"46\":3,\"58\":1,\"69\":3,\"70\":3,\"72\":5,\"80\":2,\"82\":1,\"83\":4,\"91\":1,\"92\":3,\"97\":1,\"98\":4,\"100\":1,\"101\":2,\"104\":3,\"113\":2,\"114\":2,\"115\":3,\"116\":2,\"125\":2,\"134\":4,\"136\":2,\"145\":4,\"196\":2,\"219\":3,\"222\":1,\"240\":2,\"290\":1,\"301\":3,\"309\":1}}],[\"indexuid\",{\"1\":{\"217\":2}}],[\"indexed\",{\"1\":{\"219\":3,\"220\":2}}],[\"indexedfield2\",{\"1\":{\"154\":7}}],[\"indexedfield1\",{\"1\":{\"154\":5}}],[\"indexes\",{\"1\":{\"202\":3}}],[\"indexof\",{\"1\":{\"196\":2}}],[\"index\",{\"1\":{\"8\":1,\"9\":1,\"13\":1,\"142\":1,\"165\":1,\"175\":1,\"176\":1,\"180\":1,\"202\":5,\"217\":1,\"219\":2,\"220\":4,\"222\":2},\"2\":{\"150\":1,\"169\":1}}],[\"image\",{\"1\":{\"175\":1,\"184\":1}}],[\"implements\",{\"1\":{\"45\":1,\"65\":1,\"97\":1,\"226\":1,\"240\":1}}],[\"im\",{\"0\":{\"166\":1},\"1\":{\"8\":1,\"9\":2,\"141\":1,\"142\":2,\"146\":1,\"147\":1,\"148\":1,\"165\":1,\"166\":2,\"175\":1,\"176\":2},\"2\":{\"149\":1,\"162\":1}}],[\"visibility\",{\"1\":{\"282\":1,\"314\":1,\"316\":2}}],[\"visit\",{\"1\":{\"198\":1,\"199\":1}}],[\"visitfile\",{\"1\":{\"46\":1}}],[\"v\",{\"1\":{\"147\":4}}],[\"vc\",{\"1\":{\"123\":14}}],[\"var\",{\"1\":{\"133\":1}}],[\"varchar\",{\"1\":{\"21\":3,\"217\":1}}],[\"valid\",{\"1\":{\"72\":2}}],[\"validflag\",{\"1\":{\"65\":2,\"72\":2}}],[\"valueinrecord\",{\"1\":{\"159\":5}}],[\"value\",{\"1\":{\"43\":1,\"46\":1,\"143\":1,\"144\":1,\"155\":1,\"159\":1,\"160\":2,\"199\":5,\"200\":1}}],[\"values\",{\"1\":{\"22\":2,\"199\":5}}],[\"void\",{\"1\":{\"13\":1,\"33\":2,\"34\":2,\"37\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":10,\"55\":1,\"58\":1,\"59\":1,\"66\":4,\"71\":1,\"72\":1,\"81\":1,\"82\":1,\"83\":2,\"90\":1,\"91\":1,\"92\":2,\"98\":4,\"100\":2,\"105\":1,\"106\":2,\"115\":1,\"116\":1,\"123\":4,\"125\":1,\"136\":3,\"146\":1,\"180\":1,\"189\":1,\"191\":1,\"198\":1,\"199\":1,\"221\":2,\"227\":1,\"238\":3,\"242\":1,\"246\":1,\"247\":1,\"250\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":2,\"301\":1,\"305\":1,\"309\":3,\"312\":1,\"313\":2}}],[\"vm\",{\"0\":{\"279\":1,\"308\":1,\"309\":1},\"1\":{\"8\":1,\"9\":3,\"142\":1,\"157\":1,\"175\":1,\"176\":3,\"221\":1,\"226\":5,\"254\":1,\"272\":3,\"273\":3,\"274\":2,\"275\":3,\"276\":2,\"277\":1,\"278\":2,\"279\":4,\"280\":2,\"282\":1,\"295\":4,\"297\":1,\"298\":2,\"301\":5,\"308\":1,\"309\":2,\"317\":1},\"2\":{\"270\":1,\"281\":1,\"293\":1,\"306\":1,\"318\":1,\"319\":1}}],[\"versionmanagerimpl\",{\"1\":{\"301\":1}}],[\"versionmanager\",{\"1\":{\"226\":2,\"279\":1,\"301\":2,\"309\":3}}],[\"version\",{\"0\":{\"309\":1},\"1\":{\"8\":1,\"9\":1,\"142\":1,\"175\":1,\"176\":1,\"272\":1,\"295\":1,\"298\":1,\"309\":1},\"2\":{\"307\":1}}],[\"dfs\",{\"1\":{\"261\":1,\"262\":3,\"263\":2,\"269\":1,\"278\":1}}],[\"duplicatedtableexception\",{\"1\":{\"228\":1}}],[\"duration\",{\"1\":{\"46\":2}}],[\"does\",{\"1\":{\"199\":1}}],[\"doupdatelog\",{\"1\":{\"90\":1,\"91\":1,\"92\":1}}],[\"double\",{\"1\":{\"21\":1,\"217\":1}}],[\"doinsertlog\",{\"1\":{\"90\":1,\"91\":1,\"92\":1}}],[\"di\",{\"1\":{\"71\":2,\"72\":4,\"301\":2}}],[\"diraw\",{\"1\":{\"146\":3}}],[\"dirty\",{\"1\":{\"97\":2}}],[\"dir\",{\"1\":{\"46\":2}}],[\"directorypath\",{\"1\":{\"44\":4,\"46\":2}}],[\"directory\",{\"1\":{\"16\":1,\"44\":1,\"46\":4,\"183\":1}}],[\"drop\",{\"1\":{\"21\":1,\"196\":2}}],[\"datetime\",{\"1\":{\"21\":1,\"217\":1}}],[\"datatoolargeexception\",{\"1\":{\"72\":1}}],[\"datasize\",{\"1\":{\"65\":2,\"72\":2}}],[\"datamanagerimpl\",{\"1\":{\"65\":1,\"70\":2,\"73\":4}}],[\"datamanager\",{\"0\":{\"67\":1,\"68\":1,\"69\":1,\"72\":1,\"73\":1},\"1\":{\"46\":4,\"64\":1,\"67\":1,\"68\":6,\"69\":1,\"72\":1,\"73\":2,\"74\":2,\"116\":1,\"226\":2}}],[\"databasebusyexception\",{\"1\":{\"72\":1}}],[\"databaseexists\",{\"1\":{\"44\":2}}],[\"database\",{\"1\":{\"43\":1,\"44\":3}}],[\"dataitemimpl\",{\"1\":{\"65\":1,\"72\":2}}],[\"dataitem\",{\"0\":{\"64\":1,\"65\":1,\"66\":1},\"1\":{\"9\":1,\"63\":1,\"64\":7,\"65\":4,\"66\":2,\"67\":2,\"68\":2,\"69\":1,\"70\":5,\"71\":4,\"72\":6,\"74\":2,\"92\":1,\"129\":3,\"143\":4,\"145\":4,\"146\":1,\"176\":1,\"301\":6,\"304\":3,\"305\":3},\"2\":{\"131\":1}}],[\"data\",{\"1\":{\"8\":1,\"9\":1,\"31\":4,\"32\":8,\"33\":2,\"34\":4,\"65\":2,\"66\":3,\"72\":3,\"79\":2,\"83\":17,\"97\":2,\"104\":3,\"125\":1,\"129\":1,\"142\":1,\"146\":2,\"157\":3,\"175\":1,\"176\":1,\"191\":2,\"295\":1,\"300\":2,\"301\":2,\"303\":2,\"304\":8,\"305\":1,\"309\":1,\"314\":1,\"315\":2}}],[\"dyx\",{\"1\":{\"14\":3,\"15\":2,\"16\":1,\"17\":1,\"29\":2,\"40\":1,\"49\":1,\"63\":2,\"77\":2,\"95\":1,\"110\":1,\"120\":1,\"132\":1,\"141\":1,\"151\":1,\"181\":3,\"182\":2,\"183\":1,\"184\":1,\"186\":1,\"213\":1,\"225\":1,\"233\":1,\"254\":1,\"282\":1,\"295\":1,\"308\":1}}],[\"deadlock\",{\"2\":{\"271\":1}}],[\"deadlockexception\",{\"1\":{\"260\":1}}],[\"default\",{\"1\":{\"158\":1,\"159\":1}}],[\"destroydatabase\",{\"1\":{\"46\":2}}],[\"decrementandget\",{\"1\":{\"46\":1}}],[\"decodehex\",{\"1\":{\"33\":1}}],[\"decoderexception\",{\"1\":{\"33\":1}}],[\"decode\",{\"1\":{\"32\":1,\"34\":1}}],[\"delete等\",{\"1\":{\"210\":1}}],[\"deletestmt\",{\"1\":{\"201\":4}}],[\"deleteobj\",{\"1\":{\"201\":7}}],[\"deletedirectory\",{\"1\":{\"46\":2}}],[\"delete\",{\"1\":{\"22\":2,\"46\":2,\"189\":1,\"196\":2,\"201\":2,\"226\":3,\"309\":1,\"316\":2}}],[\"dexec\",{\"1\":{\"14\":5,\"181\":5}}],[\"dev\",{\"1\":{\"13\":1,\"180\":1}}],[\"d\",{\"1\":{\"13\":1,\"14\":2,\"16\":2,\"180\":1,\"181\":2,\"183\":2}}],[\"dbfilepath\",{\"1\":{\"44\":4}}],[\"dbpath\",{\"1\":{\"43\":1,\"44\":1,\"46\":2}}],[\"db\",{\"1\":{\"9\":3,\"13\":1,\"24\":1,\"43\":1,\"46\":1,\"129\":1,\"176\":3,\"180\":1}}],[\"dm\",{\"0\":{\"63\":1},\"1\":{\"8\":1,\"9\":2,\"63\":2,\"65\":1,\"66\":2,\"67\":1,\"70\":1,\"73\":10,\"77\":2,\"78\":1,\"85\":1,\"95\":1,\"110\":1,\"120\":1,\"129\":11,\"142\":1,\"143\":1,\"146\":2,\"147\":1,\"166\":1,\"175\":1,\"176\":2,\"220\":2,\"226\":5,\"298\":1,\"301\":1,\"315\":1},\"2\":{\"61\":1,\"75\":1,\"76\":1,\"93\":1,\"108\":1,\"118\":1,\"127\":1,\"139\":1}}],[\">>\",{\"1\":{\"91\":2}}],[\">>>=\",{\"1\":{\"69\":1,\"70\":1}}],[\">=\",{\"1\":{\"11\":2,\"46\":3,\"83\":1,\"91\":1,\"145\":1,\"159\":2,\"178\":2,\"266\":1}}],[\">\",{\"1\":{\"8\":4,\"16\":1,\"43\":2,\"46\":1,\"57\":1,\"72\":1,\"82\":1,\"83\":1,\"91\":1,\"156\":1,\"159\":2,\"160\":2,\"175\":4,\"183\":1,\"198\":2,\"199\":2,\"262\":1,\"265\":1,\"268\":3,\"288\":4,\"289\":1,\"292\":1}}],[\"模块作为\",{\"1\":{\"280\":1}}],[\"模块还继承了\",{\"1\":{\"279\":1}}],[\"模块还需要解决可能发生的死锁问题\",{\"1\":{\"278\":1}}],[\"模块内部通过一个事务管理器来管理事务的生命周期\",{\"1\":{\"279\":1}}],[\"模块在每次出现资源等待时\",{\"1\":{\"278\":1}}],[\"模块在修改数据之前\",{\"1\":{\"277\":1}}],[\"模块在数据一致性和系统性能之间取得了平衡\",{\"1\":{\"276\":1}}],[\"模块支持四种事务隔离级别\",{\"1\":{\"276\":1}}],[\"模块进一步实现了\",{\"1\":{\"273\":1}}],[\"模块能够避免不同事务之间的冲突操作\",{\"1\":{\"273\":1}}],[\"模块能够有效地识别并移除未完成的日志\",{\"1\":{\"129\":1}}],[\"模块通过两段锁协议\",{\"1\":{\"273\":1}}],[\"模块通过\",{\"1\":{\"251\":1,\"279\":1}}],[\"模块通过详细记录每次数据操作的日志\",{\"1\":{\"129\":1}}],[\"模块就像是一个无形的保护者\",{\"1\":{\"231\":1}}],[\"模块是核心组成部分\",{\"1\":{\"207\":1}}],[\"模块将文件系统中的数据抽象为\",{\"1\":{\"129\":1}}],[\"模块设计了页面索引系统\",{\"1\":{\"129\":1}}],[\"模块中定义了一系列关键常量\",{\"1\":{\"251\":1}}],[\"模块中的一项关键技术\",{\"1\":{\"274\":1}}],[\"模块中的\",{\"1\":{\"167\":1}}],[\"模块中\",{\"1\":{\"129\":1,\"275\":1}}],[\"模块提供了缓存机制\",{\"1\":{\"129\":1}}],[\"模块的设计确保了数据库的并发控制和数据一致性\",{\"1\":{\"272\":1}}],[\"模块的设计不仅确保了数据库的高效运行\",{\"1\":{\"129\":1}}],[\"模块的主要功能是\",{\"1\":{\"251\":1}}],[\"模块的实现细节\",{\"1\":{\"231\":1}}],[\"模块的实现顺序为\",{\"1\":{\"8\":1,\"175\":1}}],[\"模块的各项功能\",{\"1\":{\"129\":1,\"280\":1}}],[\"模块的几个关键功能\",{\"1\":{\"129\":1,\"272\":1}}],[\"模块\",{\"1\":{\"129\":1,\"272\":1}}],[\"模块职责\",{\"0\":{\"9\":1,\"176\":1}}],[\"模块依赖与职责概述\",{\"0\":{\"8\":1,\"175\":1}}],[\"框架实现一个基于\",{\"1\":{\"41\":1}}],[\"框架\",{\"1\":{\"7\":1,\"174\":1}}],[\"框架构建\",{\"1\":{\"2\":1}}],[\"waitstarttime\",{\"1\":{\"259\":1,\"260\":1,\"266\":1}}],[\"waitu\",{\"1\":{\"259\":1,\"260\":2,\"262\":1,\"267\":1,\"268\":2}}],[\"waitlock\",{\"1\":{\"259\":1,\"260\":1,\"267\":1,\"268\":3}}],[\"wait\",{\"1\":{\"259\":1,\"260\":2,\"267\":1,\"268\":2}}],[\"walkfiletree\",{\"1\":{\"46\":1}}],[\"wrapentryraw\",{\"1\":{\"303\":1,\"315\":1}}],[\"wraplog\",{\"1\":{\"83\":2}}],[\"wrap\",{\"1\":{\"81\":1,\"83\":2,\"100\":1,\"246\":1,\"247\":1,\"249\":1}}],[\"wrapdataitemraw\",{\"1\":{\"72\":2}}],[\"write\",{\"1\":{\"33\":1,\"81\":1,\"83\":2,\"100\":1,\"191\":1,\"246\":1,\"247\":1}}],[\"writer\",{\"1\":{\"33\":6}}],[\"wlock\",{\"1\":{\"66\":3}}],[\"wshandler\",{\"1\":{\"45\":2}}],[\"will\",{\"1\":{\"267\":1}}],[\"with\",{\"1\":{\"43\":1}}],[\"windows\",{\"1\":{\"13\":1,\"14\":2,\"16\":2,\"180\":1,\"181\":2,\"183\":2}}],[\"while\",{\"1\":{\"36\":1,\"57\":1,\"72\":1,\"82\":1,\"90\":1,\"91\":1,\"114\":1,\"145\":2,\"227\":1,\"265\":1,\"266\":1,\"268\":2}}],[\"where条件为空\",{\"1\":{\"153\":1}}],[\"where\",{\"1\":{\"9\":1,\"22\":2,\"154\":18,\"157\":3,\"158\":7,\"167\":1,\"176\":1,\"198\":3,\"200\":2,\"201\":2}}],[\"working\",{\"1\":{\"16\":1,\"183\":1}}],[\"websockethandler\",{\"1\":{\"45\":2}}],[\"websocketsession\",{\"1\":{\"43\":1,\"44\":1}}],[\"websocket\",{\"0\":{\"41\":1,\"42\":1,\"43\":1,\"45\":1},\"1\":{\"26\":3,\"40\":1,\"41\":3,\"42\":2,\"43\":3,\"45\":3,\"46\":1},\"2\":{\"28\":1,\"48\":1}}],[\"web\",{\"1\":{\"7\":1,\"174\":1}}],[\"www\",{\"1\":{\"3\":1,\"170\":1}}],[\"集成了现代\",{\"1\":{\"7\":1,\"174\":1}}],[\"++\",{\"1\":{\"145\":3}}],[\"+=\",{\"1\":{\"83\":1}}],[\"+\",{\"1\":{\"7\":1,\"16\":1,\"33\":1,\"44\":4,\"46\":2,\"57\":1,\"66\":1,\"72\":1,\"80\":1,\"83\":6,\"106\":4,\"113\":1,\"123\":4,\"126\":1,\"136\":2,\"158\":1,\"159\":1,\"174\":1,\"183\":1,\"189\":3,\"191\":3,\"196\":2,\"228\":1,\"237\":1,\"242\":1,\"243\":1,\"245\":1,\"267\":2,\"292\":1,\"301\":2,\"304\":1,\"305\":1}}],[\"低延迟的网络交互\",{\"1\":{\"7\":1,\"174\":1}}],[\"中事务和版本管理的复杂性及其解决方案\",{\"1\":{\"280\":1}}],[\"中已经检测到某个事务的路径不形成死锁\",{\"1\":{\"263\":1}}],[\"中实现和运作的\",{\"1\":{\"231\":1}}],[\"中两个关键模块的实现\",{\"1\":{\"165\":1}}],[\"中用于管理\",{\"1\":{\"142\":1,\"166\":1}}],[\"中模拟\",{\"1\":{\"138\":1}}],[\"中得到了反映\",{\"1\":{\"137\":1}}],[\"中落地实施的\",{\"1\":{\"129\":1}}],[\"中获取一个合适的页面\",{\"1\":{\"114\":1}}],[\"中获取到页面\",{\"1\":{\"70\":1}}],[\"中止当前事务\",{\"1\":{\"91\":1}}],[\"中选择一个合适的页面进行插入操作\",{\"1\":{\"72\":1}}],[\"中解析出页号\",{\"1\":{\"70\":1}}],[\"中提取出页面编号\",{\"1\":{\"70\":1}}],[\"中提取出偏移量\",{\"1\":{\"69\":1,\"70\":1}}],[\"中提取页面编号\",{\"1\":{\"69\":1}}],[\"中提取偏移量\",{\"1\":{\"69\":1}}],[\"中的重要组件之一\",{\"1\":{\"280\":1}}],[\"中的具体实现\",{\"1\":{\"142\":1}}],[\"中的内容也反映了相应的部分\",{\"1\":{\"137\":1}}],[\"中的恢复策略\",{\"1\":{\"92\":1}}],[\"中的日志分为两种类型\",{\"1\":{\"89\":1}}],[\"中的\",{\"1\":{\"86\":1,\"129\":1,\"143\":1,\"272\":1}}],[\"中的数据转换为字节数组\",{\"1\":{\"83\":1}}],[\"中的数据部分\",{\"1\":{\"66\":1}}],[\"中的存储和管理是通过一个唯一标识符\",{\"1\":{\"69\":1}}],[\"中保存的数据结构如下\",{\"1\":{\"65\":1}}],[\"中重新加载数据到内存的过程\",{\"1\":{\"51\":1}}],[\"中运行\",{\"1\":{\"13\":1,\"180\":1}}],[\"中\",{\"1\":{\"7\":1,\"16\":1,\"83\":2,\"84\":1,\"116\":1,\"133\":2,\"136\":1,\"143\":1,\"174\":1,\"183\":1,\"186\":1,\"231\":1,\"273\":1,\"284\":1,\"285\":1,\"289\":1,\"291\":1,\"292\":1,\"298\":1,\"299\":1,\"301\":2}}],[\"语言中的数组内存共享功能\",{\"1\":{\"138\":1}}],[\"语言中的代码\",{\"1\":{\"133\":1}}],[\"语言中共享数组的效果\",{\"1\":{\"137\":1}}],[\"语言有所不同\",{\"1\":{\"133\":1}}],[\"语法\",{\"1\":{\"14\":1,\"181\":1}}],[\"语法错误\",{\"1\":{\"7\":1,\"174\":1}}],[\"语句解析异常\",{\"1\":{\"196\":1}}],[\"语句转换为字符串\",{\"1\":{\"196\":1}}],[\"语句类型\",{\"1\":{\"195\":1}}],[\"语句的入口\",{\"1\":{\"196\":1}}],[\"语句的入口点\",{\"1\":{\"195\":1}}],[\"语句的核心组件\",{\"1\":{\"195\":1}}],[\"语句并将其转换为\",{\"1\":{\"195\":1}}],[\"语句并将其转换为易于处理的\",{\"1\":{\"194\":1}}],[\"语句并实时获取结果\",{\"1\":{\"26\":1}}],[\"语句和数据库操作\",{\"1\":{\"19\":1}}],[\"语句合法\",{\"1\":{\"7\":1,\"174\":1}}],[\"语句\",{\"0\":{\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1},\"1\":{\"7\":1,\"9\":1,\"13\":1,\"17\":1,\"22\":1,\"37\":1,\"43\":1,\"174\":1,\"176\":1,\"180\":1,\"184\":1,\"194\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"如create\",{\"1\":{\"210\":1}}],[\"如\",{\"1\":{\"129\":1,\"203\":1,\"251\":1}}],[\"如磁盘\",{\"1\":{\"51\":1}}],[\"如数据库初始化或执行具体的\",{\"1\":{\"43\":1}}],[\"如果成功获取到锁\",{\"1\":{\"316\":1}}],[\"如果出现并发更新的错误\",{\"1\":{\"316\":1}}],[\"如果出现其他错误\",{\"1\":{\"316\":1}}],[\"如果出现异常\",{\"1\":{\"246\":2,\"247\":2,\"249\":1}}],[\"如果事务已经出错\",{\"1\":{\"316\":1}}],[\"如果事务缓存中没有此事务id的条目\",{\"1\":{\"228\":1}}],[\"如果可见\",{\"1\":{\"314\":1}}],[\"如果另一个事务已经持有了这个锁\",{\"1\":{\"297\":1}}],[\"如果tj在ti的快照集合\",{\"1\":{\"292\":1}}],[\"如果tj的事务id\",{\"1\":{\"292\":1}}],[\"如果ti在试图修改数据项x时\",{\"1\":{\"291\":1}}],[\"如果允许ti继续修改x\",{\"1\":{\"291\":1}}],[\"如果记录未被删除\",{\"1\":{\"286\":1,\"288\":1,\"289\":1}}],[\"如果这个版本被其他事务删除了\",{\"1\":{\"286\":1}}],[\"如果这个字段被建立了索引\",{\"1\":{\"217\":1}}],[\"如果未删除则可见\",{\"1\":{\"284\":1}}],[\"如果未找到\",{\"1\":{\"145\":1}}],[\"如果检测到环\",{\"1\":{\"278\":1}}],[\"如果超时\",{\"1\":{\"265\":1}}],[\"如果超过了\",{\"1\":{\"83\":2}}],[\"如果路径缓存中已经有结果\",{\"1\":{\"262\":1}}],[\"如果等于\",{\"1\":{\"249\":1}}],[\"如果文件长度小于xid头部长度\",{\"1\":{\"242\":1}}],[\"如果两者不一致\",{\"1\":{\"242\":1}}],[\"如果两个条件字段都没有索引\",{\"1\":{\"154\":1}}],[\"如果任务顺利完成\",{\"1\":{\"233\":1}}],[\"如果没有被持有\",{\"1\":{\"260\":1}}],[\"如果没有显式索引字段\",{\"1\":{\"219\":1}}],[\"如果没有找到合适的\",{\"1\":{\"72\":2}}],[\"如果没有找到合适的页面\",{\"1\":{\"72\":1}}],[\"如果我们希望创建一个包含用户信息的表\",{\"1\":{\"219\":1}}],[\"如果转换后的值为空\",{\"1\":{\"159\":1}}],[\"如果第一个条件字段没有索引但第二个条件字段有索引\",{\"1\":{\"154\":1}}],[\"如果第一个条件字段有索引\",{\"1\":{\"154\":1}}],[\"如果第二个条件字段没有索引\",{\"1\":{\"154\":1}}],[\"如果第二个条件字段也有索引\",{\"1\":{\"154\":1}}],[\"如果存在第二个条件字段\",{\"1\":{\"154\":1}}],[\"如果某个节点发生故障\",{\"1\":{\"148\":1}}],[\"如果相同\",{\"1\":{\"123\":1}}],[\"如果页面被标记为脏页面\",{\"1\":{\"105\":1}}],[\"如果该页面是脏页面\",{\"1\":{\"100\":1}}],[\"如果想要提升向数据库写入大量数据情况下的性能\",{\"1\":{\"96\":1}}],[\"如果当前的空闲空间偏移量小于offset\",{\"1\":{\"106\":1}}],[\"如果当前事务仍然活跃\",{\"1\":{\"91\":2}}],[\"如果当前事务已经提交\",{\"1\":{\"90\":2}}],[\"如果当前区间有\",{\"1\":{\"72\":1}}],[\"如果当前区间没有\",{\"1\":{\"72\":1}}],[\"如果读取到的日志记录为空\",{\"1\":{\"90\":1,\"91\":1}}],[\"如果读取到的日志为\",{\"1\":{\"82\":1}}],[\"如果先撤销\",{\"1\":{\"87\":1}}],[\"如果\",{\"1\":{\"86\":1,\"145\":1,\"298\":1}}],[\"如果日志是更新操作\",{\"1\":{\"86\":2}}],[\"如果日志是插入操作\",{\"1\":{\"86\":2}}],[\"如果发生\",{\"1\":{\"82\":1,\"83\":2}}],[\"如果发生异常\",{\"1\":{\"82\":1,\"100\":1,\"104\":1}}],[\"如果计算出的区间编号小于总的区间数\",{\"1\":{\"72\":1}}],[\"如果还是没有找到合适的页面\",{\"1\":{\"72\":1}}],[\"如果找到了合适的页面\",{\"1\":{\"72\":1}}],[\"如果数据项的版本被跳过\",{\"1\":{\"316\":1}}],[\"如果数据项的大小超过了页面的最大空闲空间\",{\"1\":{\"72\":1}}],[\"如果数据项已经被当前事务删除\",{\"1\":{\"316\":1}}],[\"如果数据项对当前事务不可见\",{\"1\":{\"316\":1}}],[\"如果数据项不存在\",{\"1\":{\"316\":1}}],[\"如果数据库中有多个表\",{\"1\":{\"216\":1}}],[\"如果数据库文件尚未存在\",{\"1\":{\"44\":1}}],[\"如果引用计数不为0\",{\"1\":{\"58\":1}}],[\"如果引用计数为0\",{\"1\":{\"58\":1}}],[\"如果引用计数归零\",{\"1\":{\"58\":1}}],[\"如果引用次数归零\",{\"1\":{\"53\":1}}],[\"如果资源被其他事务占用\",{\"1\":{\"264\":1}}],[\"如果资源已被占用\",{\"1\":{\"260\":1}}],[\"如果资源已经在缓存中\",{\"1\":{\"57\":1}}],[\"如果资源不在缓存中\",{\"1\":{\"57\":1}}],[\"如果其他线程正在获取这个资源\",{\"1\":{\"57\":1}}],[\"如果不可见\",{\"1\":{\"277\":1}}],[\"如果不同\",{\"1\":{\"123\":1}}],[\"如果不相等\",{\"1\":{\"82\":1,\"83\":1}}],[\"如果不在\",{\"1\":{\"57\":1}}],[\"如果不合法\",{\"1\":{\"7\":1,\"174\":1}}],[\"如果在\",{\"1\":{\"57\":1,\"263\":1}}],[\"如果缓存已满\",{\"1\":{\"57\":1}}],[\"如果缓存已满且没有可释放的资源\",{\"1\":{\"52\":1}}],[\"如果缓存未命中且没有其他线程在获取该资源\",{\"1\":{\"53\":1}}],[\"如果是更新日志\",{\"1\":{\"90\":1,\"91\":2}}],[\"如果是插入日志\",{\"1\":{\"90\":1,\"91\":2}}],[\"如果是\",{\"1\":{\"53\":1}}],[\"如果你希望在\",{\"1\":{\"13\":1,\"180\":1}}],[\"如果输入的\",{\"1\":{\"7\":1,\"174\":1}}],[\"如读未提交\",{\"1\":{\"2\":1}}],[\"主要包括读\",{\"1\":{\"279\":1}}],[\"主要使用了以下数据结构\",{\"1\":{\"259\":1}}],[\"主要记录数据库的头表\",{\"1\":{\"187\":1}}],[\"主要任务是读取用户的输入\",{\"1\":{\"6\":1,\"173\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"前端会将其发送到后端\",{\"1\":{\"13\":1,\"180\":1}}],[\"前端接收并显示执行结果\",{\"1\":{\"6\":1,\"173\":1}}],[\"前端的职责相对简单\",{\"1\":{\"6\":1,\"173\":1}}],[\"前端\",{\"0\":{\"6\":1,\"173\":1}}],[\"前言\",{\"0\":{\"4\":1,\"26\":1,\"142\":1,\"165\":1,\"170\":1,\"171\":1,\"207\":1},\"1\":{\"231\":1},\"2\":{\"185\":1}}],[\"各自承担不同的职责\",{\"1\":{\"5\":1,\"172\":1}}],[\"的基本定义与实现优化\",{\"0\":{\"309\":1}}],[\"的基本思想是\",{\"1\":{\"297\":1}}],[\"的偏移量\",{\"1\":{\"301\":3}}],[\"的格式如下\",{\"1\":{\"300\":1}}],[\"的执行结果相当于先于\",{\"1\":{\"298\":1}}],[\"的情况下\",{\"1\":{\"298\":1}}],[\"的事务和数据版本管理核心\",{\"1\":{\"295\":1}}],[\"的快照中\",{\"1\":{\"288\":1}}],[\"的缓存\",{\"1\":{\"279\":1}}],[\"的旧版本\",{\"1\":{\"274\":1,\"298\":1}}],[\"的帮助下\",{\"1\":{\"274\":1,\"298\":1}}],[\"的工作原理是\",{\"1\":{\"273\":1}}],[\"的死锁检测机制\",{\"1\":{\"261\":1}}],[\"的线程安全\",{\"1\":{\"259\":1}}],[\"的循环等待\",{\"1\":{\"256\":1}}],[\"的等待队列中\",{\"1\":{\"256\":3}}],[\"的状态\",{\"1\":{\"246\":1,\"249\":1}}],[\"的接口定义\",{\"0\":{\"238\":1}}],[\"的职责\",{\"1\":{\"237\":1}}],[\"的定义\",{\"0\":{\"235\":1}}],[\"的文件\",{\"1\":{\"231\":1}}],[\"的方法实现主要依赖于底层的版本管理器\",{\"1\":{\"226\":1}}],[\"的方式\",{\"1\":{\"26\":1}}],[\"的索引管理功能\",{\"1\":{\"148\":1}}],[\"的兄弟节点指向\",{\"1\":{\"147\":1}}],[\"的引用\",{\"1\":{\"143\":1,\"301\":1}}],[\"的引用和\",{\"1\":{\"143\":1}}],[\"的引用计数缓存框架中\",{\"1\":{\"53\":1}}],[\"的依赖关系图中可以看到\",{\"1\":{\"142\":1}}],[\"的内容\",{\"1\":{\"136\":2}}],[\"的第五个元素到最后一个元素共享同一片内存\",{\"1\":{\"133\":1}}],[\"的数组\",{\"1\":{\"136\":1}}],[\"的数组存储\",{\"0\":{\"133\":1}}],[\"的数据管理核心\",{\"1\":{\"295\":1}}],[\"的数据恢复为\",{\"1\":{\"86\":1}}],[\"的数据更新为\",{\"1\":{\"86\":1}}],[\"的数据\",{\"1\":{\"86\":1}}],[\"的数据标记为无效\",{\"1\":{\"86\":1}}],[\"的数据从\",{\"1\":{\"85\":1}}],[\"的数据结构中\",{\"1\":{\"215\":1}}],[\"的数据结构\",{\"0\":{\"65\":1}}],[\"的数据内容通过\",{\"1\":{\"64\":1}}],[\"的数据库管理系统\",{\"1\":{\"41\":1}}],[\"的数据库系统\",{\"1\":{\"29\":1}}],[\"的设计确保了数据操作的原子性\",{\"1\":{\"129\":1}}],[\"的抽象\",{\"1\":{\"129\":1}}],[\"的管理\",{\"0\":{\"125\":1}}],[\"的更新不会基于\",{\"1\":{\"87\":1}}],[\"的更新操作\",{\"1\":{\"86\":1}}],[\"的最终值可能为\",{\"1\":{\"87\":1}}],[\"的最终值为\",{\"1\":{\"87\":1}}],[\"的未提交数据\",{\"1\":{\"87\":3}}],[\"的操作被撤销\",{\"1\":{\"87\":1}}],[\"的插入操作\",{\"1\":{\"86\":1}}],[\"的值是\",{\"1\":{\"297\":1}}],[\"的值恢复为\",{\"1\":{\"86\":1}}],[\"的值更新为\",{\"1\":{\"86\":1}}],[\"的所有日志\",{\"1\":{\"86\":2}}],[\"的存在性\",{\"1\":{\"81\":1}}],[\"的初始化\",{\"0\":{\"73\":1}}],[\"的高32位\",{\"1\":{\"69\":1,\"70\":1}}],[\"的低16位\",{\"1\":{\"69\":1,\"70\":1}}],[\"的低\",{\"1\":{\"69\":1}}],[\"的详细过程\",{\"1\":{\"69\":1}}],[\"的生成与解析\",{\"0\":{\"69\":1}}],[\"的\",{\"0\":{\"69\":1},\"1\":{\"68\":1,\"70\":1,\"72\":1,\"83\":2}}],[\"的关键方法\",{\"0\":{\"66\":1}}],[\"的实现类还继承了\",{\"1\":{\"309\":1}}],[\"的实现与接口设计\",{\"0\":{\"279\":1}}],[\"的实现\",{\"0\":{\"63\":1,\"64\":1,\"67\":1,\"225\":1,\"308\":1},\"1\":{\"295\":1}}],[\"的通信机制\",{\"1\":{\"29\":1}}],[\"的核心作用是处理数据库表的管理\",{\"1\":{\"226\":1}}],[\"的核心模块之一\",{\"1\":{\"165\":1}}],[\"的核心方法\",{\"0\":{\"72\":1}}],[\"的核心通信机制和服务器\",{\"1\":{\"26\":1}}],[\"的核心功能\",{\"0\":{\"68\":1},\"1\":{\"4\":1,\"171\":1}}],[\"的模块设计遵循一定的依赖关系\",{\"1\":{\"8\":1,\"175\":1}}],[\"的启动信息存储在\",{\"1\":{\"187\":1}}],[\"的启动\",{\"1\":{\"7\":1,\"174\":1}}],[\"的前端采用了基于\",{\"1\":{\"6\":1,\"173\":1}}],[\"的架构分为前端和后端两个部分\",{\"1\":{\"5\":1,\"172\":1}}],[\"增加了读未提交隔离级别\",{\"1\":{\"298\":1}}],[\"增加事务计数\",{\"0\":{\"247\":1}}],[\"增加一些实用的新功能\",{\"1\":{\"4\":1,\"171\":1}}],[\"增强了系统的容错能力和数据的安全性\",{\"1\":{\"2\":1}}],[\"我选择在以下两种情况下触发全表扫描\",{\"1\":{\"153\":1}}],[\"我们引入了一个全局锁\",{\"1\":{\"311\":1}}],[\"我们先明确两个概念\",{\"1\":{\"298\":1}}],[\"我们暂时不讨论插入操作\",{\"1\":{\"297\":1}}],[\"我们为每个等待的事务设置一个超时时间\",{\"1\":{\"264\":1}}],[\"我们必须在插入新数据之前检查这个值是否已经存在于数据库中\",{\"1\":{\"221\":1}}],[\"我们需要确保字段的值满足所有设置的约束条件\",{\"1\":{\"221\":1}}],[\"我们需要为每个字段配置它的特定约束条件\",{\"1\":{\"220\":1}}],[\"我们通过以下代码来实现这些约束\",{\"1\":{\"220\":1}}],[\"我们可能会希望\",{\"1\":{\"219\":1}}],[\"我们可以把\",{\"1\":{\"234\":1}}],[\"我们可以有效地处理全表扫描\",{\"1\":{\"161\":1}}],[\"我们可以高效地管理和操作数组的不同部分\",{\"1\":{\"138\":1}}],[\"我们可以看到\",{\"1\":{\"136\":1}}],[\"我们可以在不复制数组的情况下\",{\"1\":{\"134\":1}}],[\"我们指定了表名和字段的详细信息\",{\"1\":{\"219\":1}}],[\"我们还需要考虑字段的约束条件\",{\"1\":{\"218\":1}}],[\"我们还将讨论隐藏字段和查询操作中涉及的约束验证\",{\"1\":{\"214\":1}}],[\"我们能够在\",{\"1\":{\"138\":1}}],[\"我们修改了原始数组中的某个元素\",{\"1\":{\"136\":1}}],[\"我们首先创建了一个包含\",{\"1\":{\"136\":1}}],[\"我们将从实际代码出发\",{\"1\":{\"231\":1}}],[\"我们将详细介绍\",{\"1\":{\"129\":1}}],[\"我们将详细介绍两种实现\",{\"1\":{\"26\":1}}],[\"我们将深入探讨\",{\"1\":{\"129\":1,\"272\":1,\"280\":1,\"295\":1}}],[\"我们将借助这个缓存框架来实现页面缓存\",{\"1\":{\"96\":1}}],[\"我们将讲解如何使用\",{\"1\":{\"41\":1}}],[\"我希望能够让\",{\"1\":{\"4\":1,\"171\":1}}],[\"我决定在保留其原有设计优势的基础上\",{\"1\":{\"4\":1,\"171\":1}}],[\"我发现了该项目的许多亮点\",{\"1\":{\"4\":1,\"171\":1}}],[\"我不仅深刻学习了\",{\"1\":{\"4\":1,\"171\":1}}],[\"在该方法的开始部分\",{\"1\":{\"311\":1}}],[\"在该级别下\",{\"1\":{\"287\":1}}],[\"在没有\",{\"1\":{\"298\":1}}],[\"在介绍\",{\"1\":{\"298\":1}}],[\"在读提交及以上的隔离级别\",{\"1\":{\"291\":1}}],[\"在读未提交隔离级别下\",{\"1\":{\"291\":1}}],[\"在串行化隔离级别下\",{\"1\":{\"289\":1}}],[\"在实现两段锁协议的同时\",{\"1\":{\"278\":1}}],[\"在实现上\",{\"1\":{\"251\":1}}],[\"在对某个数据项\",{\"1\":{\"274\":1}}],[\"在事务执行期间\",{\"1\":{\"273\":1}}],[\"在事务完成时\",{\"1\":{\"269\":1}}],[\"在事务管理方面\",{\"1\":{\"251\":1}}],[\"在某些情况下\",{\"1\":{\"264\":1}}],[\"在死锁检测过程中\",{\"1\":{\"263\":1}}],[\"在多事务并发的数据库系统中\",{\"1\":{\"257\":1}}],[\"在多线程环境中\",{\"1\":{\"87\":1}}],[\"在等待\",{\"1\":{\"256\":1}}],[\"在学习如何使用\",{\"1\":{\"255\":1}}],[\"在一些关键基础模块中\",{\"1\":{\"242\":1}}],[\"在一次偶然的机会\",{\"1\":{\"4\":1,\"171\":1}}],[\"在文件中的状态存储在\",{\"1\":{\"237\":1}}],[\"在接下来的章节中\",{\"1\":{\"231\":1}}],[\"在背后默默地记录和监控着每一个事务的状态\",{\"1\":{\"231\":1}}],[\"在现代数据库管理系统中\",{\"1\":{\"231\":1}}],[\"在插入数据时\",{\"1\":{\"221\":1}}],[\"在后续操作中\",{\"1\":{\"148\":1}}],[\"在当前节点内进行范围查找\",{\"1\":{\"145\":1}}],[\"在这种隔离级别下\",{\"1\":{\"284\":1}}],[\"在这种情况下\",{\"1\":{\"133\":1}}],[\"在这里实现存在简化\",{\"1\":{\"155\":1}}],[\"在这个场景中\",{\"1\":{\"297\":1}}],[\"在这个级别下\",{\"1\":{\"289\":1}}],[\"在这个示例中\",{\"1\":{\"136\":1}}],[\"在这个类中\",{\"1\":{\"134\":1}}],[\"在这个设计中\",{\"1\":{\"112\":1}}],[\"在这些语言中\",{\"1\":{\"133\":1}}],[\"在这一节中\",{\"1\":{\"129\":1,\"280\":1}}],[\"在本节中\",{\"1\":{\"129\":1,\"272\":1}}],[\"在本教程中\",{\"1\":{\"8\":1,\"26\":1,\"41\":1,\"175\":1}}],[\"在普通页中插入数据时\",{\"1\":{\"126\":1}}],[\"在easydb中\",{\"1\":{\"121\":1,\"122\":1,\"124\":1}}],[\"在进行插入操作时\",{\"1\":{\"117\":1}}],[\"在进行任何数据操作之前\",{\"1\":{\"85\":1}}],[\"在上层模块使用完页面后\",{\"1\":{\"112\":1}}],[\"在指定的偏移位置直接更新数据\",{\"1\":{\"106\":1}}],[\"在恢复过程中\",{\"1\":{\"87\":2}}],[\"在崩溃前未完成\",{\"1\":{\"86\":1}}],[\"在系统恢复时\",{\"1\":{\"129\":1}}],[\"在系统崩溃后\",{\"1\":{\"86\":1}}],[\"在系统关闭时\",{\"1\":{\"53\":1,\"59\":1}}],[\"在单线程环境中\",{\"1\":{\"86\":1}}],[\"在位置\",{\"1\":{\"85\":1}}],[\"在创建\",{\"1\":{\"242\":1}}],[\"在创建新表时\",{\"1\":{\"226\":1}}],[\"在创建字段时\",{\"1\":{\"220\":1}}],[\"在创建日志文件时\",{\"1\":{\"81\":1}}],[\"在创建和打开数据库文件时\",{\"1\":{\"68\":1}}],[\"在页面中插入新的数据项\",{\"1\":{\"72\":1}}],[\"在页面中你可以输入\",{\"1\":{\"13\":1,\"180\":1}}],[\"在数据恢复方面\",{\"1\":{\"107\":1}}],[\"在数据库中\",{\"1\":{\"218\":1,\"297\":1}}],[\"在数据库管理系统中\",{\"1\":{\"207\":1,\"214\":1}}],[\"在数据库崩溃后\",{\"1\":{\"78\":1}}],[\"在数据库系统中\",{\"1\":{\"50\":1,\"96\":1,\"106\":1,\"111\":1,\"121\":1,\"283\":1}}],[\"在数据修改操作前后执行日志记录\",{\"1\":{\"68\":1}}],[\"在需要撤销修改时调用\",{\"1\":{\"66\":1}}],[\"在修改数据项之前调用\",{\"1\":{\"66\":1}}],[\"在提高系统性能的同时\",{\"1\":{\"60\":1}}],[\"在引用计数策略中\",{\"1\":{\"52\":2}}],[\"在我们的系统中\",{\"1\":{\"42\":1,\"216\":1}}],[\"在建立连接后初始化\",{\"1\":{\"36\":1}}],[\"在传输数据之前\",{\"1\":{\"31\":1}}],[\"在通过\",{\"1\":{\"15\":1,\"182\":1}}],[\"在\",{\"1\":{\"7\":1,\"13\":1,\"16\":4,\"45\":1,\"52\":2,\"53\":1,\"69\":1,\"72\":1,\"84\":1,\"129\":1,\"133\":1,\"142\":1,\"144\":1,\"147\":1,\"174\":1,\"180\":1,\"183\":4,\"186\":1,\"226\":1,\"228\":1,\"231\":1,\"273\":1,\"274\":1,\"275\":1,\"284\":1,\"285\":1,\"289\":1,\"298\":2,\"299\":1,\"301\":1}}],[\"在深入研究\",{\"1\":{\"4\":1,\"171\":1}}],[\"项目时\",{\"1\":{\"15\":1,\"182\":1}}],[\"项目二次开发的解决方案以及基于socket交互\",{\"1\":{\"6\":1,\"173\":1}}],[\"项目在更多场合下展现出其强大的功能性和灵活性\",{\"1\":{\"4\":1,\"171\":1}}],[\"项目的过程中\",{\"1\":{\"4\":1,\"171\":1}}],[\"项目\",{\"0\":{\"15\":1,\"182\":1},\"1\":{\"4\":1,\"171\":1}}],[\"项目地址\",{\"1\":{\"3\":1,\"24\":1,\"170\":1}}],[\"zhishixingqiu\",{\"1\":{\"3\":1,\"170\":1}}],[\"知识星球\",{\"1\":{\"3\":1,\"170\":1}}],[\"two\",{\"1\":{\"297\":1}}],[\"tj的修改对ti不可见\",{\"1\":{\"291\":1}}],[\"tj\",{\"1\":{\"291\":1}}],[\"t3\",{\"1\":{\"255\":3,\"256\":3}}],[\"tb\",{\"1\":{\"217\":1,\"219\":6,\"220\":4,\"222\":2,\"227\":4}}],[\"tbm模块还支持事务管理\",{\"1\":{\"210\":1}}],[\"tbm模块中的sql解析功能使用了jsqlparser库\",{\"1\":{\"210\":1}}],[\"tbm模块中的启动信息存储在\",{\"1\":{\"208\":1}}],[\"tbm模块通过对表和字段的细致管理\",{\"1\":{\"209\":1}}],[\"tbm模块通过多种策略和技术来处理复杂的数据库管理任务\",{\"1\":{\"207\":1}}],[\"tbm模块使用了原子性更新策略\",{\"1\":{\"208\":1}}],[\"tbm\",{\"0\":{\"225\":1},\"1\":{\"8\":1,\"9\":2,\"36\":1,\"151\":1,\"157\":1,\"175\":1,\"176\":2,\"186\":1,\"207\":1,\"213\":1,\"216\":1,\"219\":2,\"220\":2,\"221\":1,\"225\":1,\"301\":1},\"2\":{\"192\":1,\"204\":1,\"212\":1,\"223\":1,\"229\":1,\"230\":1}}],[\"toarray\",{\"1\":{\"198\":3,\"199\":2,\"202\":6}}],[\"tokenizer\",{\"1\":{\"203\":6}}],[\"token\",{\"1\":{\"196\":1}}],[\"touppercase\",{\"1\":{\"196\":1}}],[\"topath\",{\"1\":{\"190\":1,\"191\":2}}],[\"tolowercase\",{\"1\":{\"159\":1}}],[\"tostring\",{\"1\":{\"136\":1,\"198\":5,\"199\":1,\"200\":2,\"201\":1,\"202\":1}}],[\"tomotoes\",{\"1\":{\"3\":1,\"170\":1}}],[\"t2\",{\"1\":{\"87\":10,\"255\":3,\"256\":10,\"274\":1,\"297\":7,\"298\":5}}],[\"t1\",{\"1\":{\"86\":7,\"87\":10,\"255\":3,\"256\":11,\"274\":2,\"297\":8,\"298\":6}}],[\"ti看不到tj的修改\",{\"1\":{\"291\":1}}],[\"time\",{\"2\":{\"271\":1}}],[\"timed\",{\"1\":{\"267\":1}}],[\"timeout\",{\"1\":{\"265\":2,\"266\":2}}],[\"ti\",{\"1\":{\"85\":4,\"86\":4,\"147\":2,\"286\":7,\"288\":30,\"291\":1,\"292\":1}}],[\"tail\",{\"1\":{\"82\":2}}],[\"tablecache\",{\"1\":{\"226\":2,\"227\":1,\"228\":2}}],[\"table>\",{\"1\":{\"226\":1}}],[\"tablename\",{\"1\":{\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"216\":2,\"219\":1,\"228\":3}}],[\"tablemanagerimpl\",{\"1\":{\"157\":1,\"220\":2,\"221\":1,\"226\":2}}],[\"tablemanager\",{\"1\":{\"46\":2,\"216\":1,\"219\":1,\"226\":5,\"228\":1}}],[\"tables\",{\"1\":{\"21\":1}}],[\"table\",{\"1\":{\"8\":1,\"9\":1,\"21\":2,\"151\":1,\"167\":1,\"175\":1,\"176\":1,\"202\":1,\"207\":1,\"213\":1,\"216\":1,\"217\":1,\"219\":3,\"220\":1,\"227\":2,\"228\":6},\"2\":{\"212\":1,\"224\":1}}],[\"typecheck\",{\"1\":{\"220\":1}}],[\"typename\",{\"1\":{\"217\":2}}],[\"type\",{\"1\":{\"72\":2,\"89\":2,\"160\":2}}],[\"types\",{\"1\":{\"69\":1,\"72\":1,\"160\":2}}],[\"t>\",{\"1\":{\"56\":1}}],[\"t\",{\"1\":{\"36\":2,\"37\":2,\"55\":2,\"57\":3,\"58\":1,\"59\":1,\"86\":2,\"136\":1,\"284\":1,\"286\":2,\"288\":4,\"289\":4,\"290\":7,\"292\":8,\"311\":2,\"312\":4,\"313\":4,\"314\":4,\"315\":3,\"316\":11}}],[\"tran\",{\"1\":{\"240\":3,\"245\":1,\"251\":3}}],[\"transporter\",{\"0\":{\"33\":1},\"1\":{\"33\":3,\"34\":10,\"36\":2,\"37\":2}}],[\"transaction>\",{\"1\":{\"290\":1}}],[\"transactionmanager的构造函数后\",{\"1\":{\"242\":1}}],[\"transactionmanagerimpl\",{\"1\":{\"146\":2,\"240\":1,\"290\":1}}],[\"transactionmanager\",{\"0\":{\"238\":1},\"1\":{\"46\":4,\"73\":2,\"90\":1,\"91\":1,\"233\":1,\"234\":1,\"237\":1,\"238\":1,\"240\":1,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"292\":1}}],[\"transaction\",{\"1\":{\"8\":1,\"9\":1,\"175\":1,\"176\":1,\"231\":1,\"235\":1,\"267\":1,\"282\":1,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"290\":4,\"292\":1,\"311\":2,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1},\"2\":{\"294\":1}}],[\"tree\",{\"1\":{\"143\":1}}],[\"truncatebybgno\",{\"1\":{\"98\":1}}],[\"truncate\",{\"1\":{\"82\":1}}],[\"true\",{\"1\":{\"33\":1,\"36\":1,\"45\":1,\"46\":1,\"57\":2,\"66\":1,\"72\":1,\"82\":1,\"90\":1,\"91\":1,\"106\":2,\"123\":2,\"126\":1,\"144\":1,\"161\":1,\"219\":5,\"222\":4,\"262\":3,\"265\":1,\"286\":2,\"288\":2,\"289\":2,\"290\":1,\"316\":5}}],[\"trim\",{\"1\":{\"43\":2,\"196\":1,\"203\":2}}],[\"trylock\",{\"1\":{\"312\":1}}],[\"try\",{\"1\":{\"36\":5,\"43\":1,\"46\":1,\"57\":2,\"58\":1,\"59\":1,\"72\":2,\"81\":1,\"82\":2,\"83\":5,\"92\":4,\"100\":1,\"104\":1,\"114\":1,\"115\":1,\"116\":1,\"145\":2,\"146\":2,\"189\":1,\"190\":1,\"191\":3,\"196\":1,\"228\":1,\"242\":2,\"245\":1,\"246\":2,\"247\":2,\"249\":1,\"250\":1,\"260\":1,\"265\":1,\"266\":1,\"268\":1,\"304\":1,\"305\":1,\"311\":1,\"312\":1,\"314\":2,\"316\":3}}],[\"threshold\",{\"1\":{\"72\":1,\"113\":1,\"114\":1,\"115\":1,\"265\":2}}],[\"thread\",{\"1\":{\"57\":1,\"265\":2}}],[\"throw\",{\"1\":{\"32\":2,\"37\":1,\"46\":1,\"57\":2,\"72\":2,\"158\":1,\"159\":1,\"196\":2,\"199\":1,\"219\":1,\"228\":1,\"260\":1,\"265\":1,\"292\":1,\"309\":1,\"312\":1,\"314\":2,\"315\":1,\"316\":4}}],[\"throws\",{\"1\":{\"32\":1,\"33\":5,\"34\":3,\"37\":3,\"43\":1,\"44\":1,\"45\":1,\"46\":3,\"55\":1,\"57\":1,\"70\":1,\"72\":2,\"98\":1,\"104\":1,\"146\":1,\"154\":1,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"161\":1,\"196\":1,\"199\":1,\"203\":1,\"219\":1,\"220\":1,\"221\":1,\"226\":6,\"228\":1,\"260\":1,\"301\":1,\"309\":5,\"312\":1,\"314\":1,\"315\":1,\"316\":1}}],[\"this\",{\"1\":{\"33\":3,\"34\":2,\"44\":1,\"46\":4,\"66\":2,\"70\":2,\"83\":2,\"104\":4,\"134\":3,\"226\":6,\"227\":1,\"228\":1,\"242\":2,\"309\":1}}],[\"textmessage\",{\"1\":{\"43\":2,\"44\":3}}],[\"textwebsockethandler\",{\"1\":{\"43\":1}}],[\"testsubarray\",{\"1\":{\"136\":1}}],[\"test\",{\"1\":{\"14\":2,\"136\":1,\"181\":2}}],[\"terminalwebsockethandler\",{\"1\":{\"43\":2}}],[\"terminal\",{\"1\":{\"3\":1,\"6\":1,\"170\":1,\"173\":1}}],[\"teriminal\",{\"1\":{\"3\":1,\"170\":1}}],[\"tm模块的实现\",{\"0\":{\"239\":1}}],[\"tmp\",{\"1\":{\"83\":3,\"187\":1,\"188\":2,\"189\":1,\"191\":7,\"246\":3}}],[\"tm\",{\"1\":{\"8\":1,\"9\":2,\"73\":5,\"90\":3,\"91\":4,\"175\":1,\"176\":2,\"231\":3,\"233\":1,\"234\":1,\"251\":2,\"284\":1,\"286\":3,\"288\":3,\"289\":3,\"292\":2,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"316\":2}}],[\"globallock\",{\"1\":{\"311\":3,\"312\":2,\"313\":2}}],[\"gen\",{\"1\":{\"219\":2,\"222\":2}}],[\"getxmin\",{\"1\":{\"286\":1,\"288\":1,\"289\":1}}],[\"getxmax\",{\"1\":{\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"292\":1,\"316\":1}}],[\"getxidposition\",{\"1\":{\"242\":1,\"243\":1,\"246\":1,\"249\":1}}],[\"getcoldatatype\",{\"1\":{\"202\":1}}],[\"getcolumndefinitions\",{\"1\":{\"202\":1}}],[\"getcolumnname\",{\"1\":{\"199\":1,\"200\":1,\"202\":5}}],[\"getcolumnsnames\",{\"1\":{\"202\":2}}],[\"getcolumnspecs\",{\"1\":{\"202\":2}}],[\"getcolumns\",{\"1\":{\"199\":3,\"200\":1}}],[\"getclientip\",{\"1\":{\"45\":2}}],[\"getname\",{\"1\":{\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"getwhere\",{\"1\":{\"198\":2,\"200\":2,\"201\":2}}],[\"getordefault\",{\"1\":{\"262\":1}}],[\"getorderbyelements\",{\"1\":{\"198\":2}}],[\"getoutputstream\",{\"1\":{\"33\":1}}],[\"getalluid\",{\"1\":{\"154\":1,\"155\":1,\"157\":1}}],[\"getattributes\",{\"1\":{\"43\":1}}],[\"getrawsibling\",{\"1\":{\"145\":2}}],[\"getrawkthson\",{\"1\":{\"145\":2}}],[\"getrawkthkey\",{\"1\":{\"145\":3}}],[\"getrawnokeys\",{\"1\":{\"145\":2}}],[\"getremoteaddr\",{\"1\":{\"45\":1}}],[\"getkey\",{\"1\":{\"91\":1,\"266\":1}}],[\"getvalue\",{\"1\":{\"91\":1,\"266\":1}}],[\"getfromitem\",{\"1\":{\"198\":1}}],[\"getfreespace\",{\"1\":{\"72\":1,\"116\":1,\"125\":1}}],[\"getfso\",{\"1\":{\"72\":2,\"106\":1,\"125\":4,\"126\":1}}],[\"getforcache\",{\"1\":{\"55\":1,\"57\":2,\"70\":1,\"72\":1,\"99\":2,\"104\":2,\"309\":1}}],[\"getpagenumber\",{\"1\":{\"72\":1,\"98\":1,\"100\":1,\"116\":2}}],[\"getpage\",{\"1\":{\"70\":2,\"72\":1,\"92\":2,\"98\":1,\"116\":1}}],[\"getpayload\",{\"1\":{\"43\":1}}],[\"gettable\",{\"1\":{\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"getting\",{\"1\":{\"53\":1,\"56\":2,\"57\":4}}],[\"getter\",{\"1\":{\"46\":1}}],[\"getlastaccessedtime\",{\"1\":{\"46\":1}}],[\"getheader\",{\"1\":{\"45\":1}}],[\"getselectitems\",{\"1\":{\"198\":1}}],[\"getselectbody\",{\"1\":{\"198\":1}}],[\"getservletrequest\",{\"1\":{\"45\":1}}],[\"getstarttime\",{\"1\":{\"46\":1}}],[\"getstr\",{\"1\":{\"43\":1}}],[\"getexpressions\",{\"1\":{\"199\":1,\"200\":1}}],[\"getexpression\",{\"1\":{\"198\":2}}],[\"getexecutor\",{\"1\":{\"43\":1,\"44\":1,\"46\":1}}],[\"geterr\",{\"1\":{\"32\":2,\"37\":2}}],[\"getusersession\",{\"1\":{\"43\":1,\"44\":1,\"46\":1}}],[\"getindexes\",{\"1\":{\"202\":2}}],[\"getinputstream\",{\"1\":{\"33\":1}}],[\"getitemslist\",{\"1\":{\"199\":1}}],[\"getid\",{\"1\":{\"43\":1}}],[\"get\",{\"1\":{\"43\":1,\"46\":5,\"57\":4,\"58\":2,\"59\":1,\"72\":1,\"91\":3,\"159\":1,\"200\":2,\"202\":1,\"221\":2,\"228\":1,\"262\":4,\"268\":2,\"312\":1,\"313\":1,\"314\":2,\"315\":1,\"316\":2}}],[\"getdata\",{\"1\":{\"32\":1,\"36\":1,\"37\":1,\"72\":3,\"100\":1,\"106\":4,\"123\":3,\"125\":2,\"126\":3}}],[\"getbytes\",{\"1\":{\"32\":1,\"203\":1,\"228\":1}}],[\"getmessage\",{\"1\":{\"31\":1,\"32\":2,\"196\":1}}],[\"go\",{\"1\":{\"129\":1,\"133\":2,\"137\":1,\"138\":1}}],[\"git\",{\"1\":{\"13\":2,\"180\":2}}],[\"github\",{\"1\":{\"3\":3,\"13\":1,\"24\":1,\"170\":3,\"180\":1}}],[\"guoziyang\",{\"1\":{\"3\":1,\"170\":1}}],[\"c++\",{\"1\":{\"129\":1,\"133\":1,\"138\":1}}],[\"checkfortimeouts\",{\"1\":{\"265\":1,\"266\":2}}],[\"checkxid\",{\"0\":{\"249\":1},\"1\":{\"249\":1,\"251\":1}}],[\"checkxidcounter\",{\"1\":{\"242\":1,\"251\":1}}],[\"checkxidcount\",{\"1\":{\"242\":1}}],[\"checkvc\",{\"1\":{\"123\":3}}],[\"checkandremovetail\",{\"1\":{\"81\":1,\"82\":1}}],[\"checksinglecondition\",{\"1\":{\"158\":2,\"159\":1}}],[\"checksum2\",{\"1\":{\"83\":2}}],[\"checksum1\",{\"1\":{\"83\":2}}],[\"checksum\",{\"1\":{\"79\":2,\"83\":5}}],[\"checksessions\",{\"1\":{\"46\":1}}],[\"check\",{\"1\":{\"46\":2,\"265\":1}}],[\"checkifdatabasefilesexist\",{\"1\":{\"44\":1}}],[\"case\",{\"1\":{\"158\":2,\"159\":7}}],[\"calexp\",{\"1\":{\"161\":1}}],[\"calwhere\",{\"1\":{\"154\":3,\"161\":1}}],[\"calwhereres\",{\"1\":{\"154\":3,\"161\":4}}],[\"calchecksum\",{\"1\":{\"80\":1,\"82\":1,\"83\":4}}],[\"cachefullexception\",{\"1\":{\"57\":1}}],[\"cache\",{\"1\":{\"56\":2,\"57\":3,\"58\":2,\"59\":3}}],[\"canwrite\",{\"1\":{\"189\":2,\"191\":2}}],[\"canread\",{\"1\":{\"189\":2,\"191\":2}}],[\"caninit\",{\"1\":{\"46\":1}}],[\"cannot\",{\"1\":{\"44\":1}}],[\"catch\",{\"1\":{\"36\":5,\"43\":1,\"46\":1,\"57\":2,\"81\":1,\"82\":2,\"83\":4,\"92\":2,\"100\":1,\"104\":1,\"116\":1,\"189\":1,\"190\":1,\"191\":3,\"196\":1,\"242\":2,\"246\":2,\"247\":2,\"249\":1,\"250\":1,\"265\":1,\"312\":1,\"314\":1,\"316\":2}}],[\"currenttime\",{\"1\":{\"46\":3,\"266\":2}}],[\"currenttimemillis\",{\"1\":{\"44\":1,\"46\":3,\"260\":1,\"266\":1,\"290\":1}}],[\"custom\",{\"1\":{\"13\":1,\"43\":1,\"46\":1,\"180\":1}}],[\"c\",{\"0\":{\"30\":1},\"1\":{\"26\":1,\"29\":1,\"129\":1,\"133\":1,\"138\":1}}],[\"ccjsqlparserutil\",{\"1\":{\"196\":1}}],[\"cc\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"columnspec\",{\"1\":{\"202\":5}}],[\"columndefinition\",{\"1\":{\"202\":10}}],[\"column\",{\"1\":{\"199\":3}}],[\"columnnames\",{\"1\":{\"199\":5}}],[\"counterlock\",{\"1\":{\"245\":2}}],[\"count++\",{\"1\":{\"57\":1}}],[\"count\",{\"1\":{\"57\":2,\"58\":1,\"199\":2}}],[\"copyofrange\",{\"1\":{\"32\":2,\"83\":3,\"123\":2,\"125\":1,\"146\":1}}],[\"conditionvalue\",{\"1\":{\"159\":9}}],[\"control\",{\"1\":{\"298\":1}}],[\"contains\",{\"1\":{\"159\":1,\"219\":3}}],[\"containskey\",{\"1\":{\"57\":2,\"91\":2,\"221\":1,\"228\":2,\"260\":1,\"262\":1,\"268\":1,\"290\":1}}],[\"continue\",{\"1\":{\"46\":2,\"57\":2,\"72\":1,\"114\":1,\"157\":1,\"262\":1,\"268\":1}}],[\"concurrentupdateexception\",{\"1\":{\"316\":2}}],[\"concurrenthashmap\",{\"1\":{\"46\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"46\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"43\":1,\"46\":1}}],[\"concurrency\",{\"1\":{\"298\":1}}],[\"concat\",{\"1\":{\"32\":2,\"72\":2,\"83\":2,\"303\":1}}],[\"configurations\",{\"1\":{\"16\":1,\"183\":1}}],[\"comparison\",{\"1\":{\"159\":1}}],[\"compareop\",{\"1\":{\"159\":2}}],[\"compareto\",{\"1\":{\"159\":7}}],[\"comparablevalueinrecord\",{\"1\":{\"159\":7}}],[\"comparable<object>\",{\"1\":{\"159\":3}}],[\"computeifabsent\",{\"1\":{\"43\":1,\"160\":1}}],[\"component\",{\"1\":{\"43\":1,\"45\":1,\"46\":1}}],[\"compile\",{\"1\":{\"14\":1,\"181\":1}}],[\"common\",{\"1\":{\"49\":1,\"132\":1}}],[\"command\",{\"1\":{\"43\":1}}],[\"communication\",{\"2\":{\"27\":1,\"38\":1,\"47\":1}}],[\"commited\",{\"1\":{\"286\":2}}],[\"commit和abort等事务控制语句的解析和处理\",{\"1\":{\"210\":1}}],[\"commit\",{\"1\":{\"23\":1,\"196\":2,\"203\":3,\"226\":1,\"238\":2,\"246\":2,\"251\":1,\"268\":1,\"309\":1,\"312\":3}}],[\"committed\",{\"1\":{\"23\":1,\"203\":1,\"234\":1,\"236\":1,\"240\":1,\"251\":1,\"283\":1,\"285\":1,\"286\":4,\"288\":6,\"290\":1,\"292\":1,\"311\":1}}],[\"com\",{\"1\":{\"3\":3,\"13\":1,\"14\":3,\"15\":2,\"16\":1,\"17\":1,\"22\":3,\"24\":1,\"29\":2,\"40\":1,\"49\":1,\"63\":2,\"77\":2,\"95\":1,\"110\":1,\"120\":1,\"132\":1,\"141\":1,\"151\":1,\"170\":3,\"180\":1,\"181\":3,\"182\":2,\"183\":1,\"184\":1,\"186\":1,\"213\":1,\"225\":1,\"233\":1,\"254\":1,\"282\":1,\"295\":1,\"308\":1}}],[\"createfield\",{\"1\":{\"219\":2,\"220\":1,\"222\":1}}],[\"createtable\",{\"1\":{\"196\":2,\"202\":6,\"219\":2,\"228\":1}}],[\"createnewfile\",{\"1\":{\"189\":1,\"191\":1}}],[\"createdatabase\",{\"1\":{\"44\":1}}],[\"createmessage\",{\"1\":{\"43\":1,\"44\":3}}],[\"create\",{\"1\":{\"14\":1,\"16\":1,\"21\":1,\"44\":1,\"73\":4,\"181\":1,\"183\":1,\"189\":2,\"202\":14,\"219\":10,\"220\":1,\"226\":3,\"228\":9}}],[\"clust\",{\"1\":{\"219\":2,\"222\":2}}],[\"close\",{\"1\":{\"33\":5,\"34\":2,\"36\":1,\"46\":4,\"59\":2,\"72\":5,\"98\":1,\"238\":2,\"250\":3,\"251\":1}}],[\"clone\",{\"1\":{\"13\":1,\"180\":1}}],[\"click\",{\"1\":{\"17\":1,\"37\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"clientip\",{\"1\":{\"43\":5,\"44\":7,\"45\":13}}],[\"client\",{\"1\":{\"14\":1,\"15\":1,\"17\":1,\"26\":1,\"29\":2,\"37\":5,\"181\":1,\"182\":1,\"184\":1}}],[\"class\",{\"1\":{\"13\":2,\"16\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"37\":1,\"43\":1,\"45\":1,\"46\":2,\"65\":1,\"69\":1,\"89\":1,\"97\":1,\"113\":1,\"134\":1,\"143\":1,\"146\":1,\"161\":1,\"180\":2,\"183\":1,\"188\":1,\"216\":1,\"217\":1,\"226\":1,\"240\":1,\"290\":1,\"301\":1}}],[\"cd\",{\"1\":{\"13\":1,\"180\":1}}],[\"cn\",{\"1\":{\"3\":2,\"24\":1,\"170\":2}}],[\"并抛出错误\",{\"1\":{\"316\":2}}],[\"并初始化事务的相关结构\",{\"1\":{\"311\":1}}],[\"并初始化第一页\",{\"1\":{\"73\":1}}],[\"并尝试更新它\",{\"1\":{\"297\":1}}],[\"并实现事务的隔离级别\",{\"1\":{\"275\":1}}],[\"并实现了\",{\"1\":{\"99\":1}}],[\"并实现了一个简单的\",{\"1\":{\"37\":1}}],[\"并决定是否将资源分配给请求事务或将其放入等待队列\",{\"1\":{\"269\":1}}],[\"并重新分配给等待队列中的其他事务\",{\"1\":{\"268\":1}}],[\"并触发回滚\",{\"1\":{\"266\":1}}],[\"并释放它占用的所有资源\",{\"1\":{\"264\":1}}],[\"并存储在相应的等待队列中\",{\"1\":{\"260\":1}}],[\"并调用\",{\"1\":{\"251\":1}}],[\"并使用\",{\"1\":{\"251\":1}}],[\"并用bytebuffer包装\",{\"1\":{\"247\":1}}],[\"并保存起来\",{\"1\":{\"245\":1}}],[\"并标记为\",{\"1\":{\"245\":1}}],[\"并最终完成\",{\"1\":{\"233\":1}}],[\"并对其进行进一步的处理\",{\"1\":{\"210\":1}}],[\"并对数据进行运算过滤\",{\"1\":{\"154\":1}}],[\"并确保系统的高效运行\",{\"1\":{\"269\":1}}],[\"并确保操作的原子性\",{\"1\":{\"191\":1}}],[\"并确保数据的一致性与完整性\",{\"1\":{\"126\":1}}],[\"并进行必要的校验\",{\"1\":{\"189\":1}}],[\"并取并集\",{\"1\":{\"154\":1}}],[\"并提供接口供其他模块来查询某个事务的状态\",{\"1\":{\"234\":1}}],[\"并提供了日志支持\",{\"1\":{\"129\":1}}],[\"并提交\",{\"1\":{\"87\":1}}],[\"并从\",{\"1\":{\"114\":1}}],[\"并从列表中移除\",{\"1\":{\"72\":1}}],[\"并更新xid\",{\"1\":{\"247\":1}}],[\"并更新空闲空间的偏移量\",{\"1\":{\"106\":1}}],[\"并更新总校验和\",{\"1\":{\"83\":1}}],[\"并根据条件进行过滤\",{\"1\":{\"157\":1}}],[\"并根据需要将页面的数据写回到磁盘\",{\"1\":{\"105\":1}}],[\"并根据解析结果执行相应的表操作\",{\"1\":{\"9\":1,\"176\":1}}],[\"并包裹成page\",{\"1\":{\"104\":1}}],[\"并发更新同一数据\",{\"1\":{\"87\":1}}],[\"并发与事务控制\",{\"1\":{\"2\":1}}],[\"并依赖于日志的重做\",{\"1\":{\"84\":1}}],[\"并解析其中的\",{\"1\":{\"83\":1}}],[\"并移除可能存在的\",{\"1\":{\"82\":1}}],[\"并检查\",{\"1\":{\"81\":1}}],[\"并写入文件\",{\"1\":{\"81\":1}}],[\"并填充\",{\"1\":{\"73\":1}}],[\"并设置第一页的字节校验\",{\"1\":{\"72\":1}}],[\"并设置其值为log\",{\"1\":{\"72\":1}}],[\"并设置引用计数为1\",{\"1\":{\"57\":1}}],[\"并获取其在页面中的偏移量\",{\"1\":{\"72\":1}}],[\"并校验其有效性\",{\"1\":{\"72\":1}}],[\"并返回这个日志\",{\"1\":{\"72\":1}}],[\"并返回这个对象\",{\"1\":{\"70\":1}}],[\"并返回插入位置的偏移\",{\"1\":{\"72\":1}}],[\"并返回执行结果\",{\"1\":{\"43\":1}}],[\"并支持系统崩溃后的数据恢复\",{\"1\":{\"68\":1}}],[\"并支持故障恢复\",{\"1\":{\"2\":1}}],[\"并减少了内存开销\",{\"1\":{\"64\":1}}],[\"并在超时后自动回滚事务\",{\"1\":{\"269\":1}}],[\"并在超时时执行回滚操作\",{\"1\":{\"264\":1}}],[\"并在必要时回滚事务\",{\"1\":{\"258\":1}}],[\"并在表链表中维护最新的表结构\",{\"1\":{\"228\":1}}],[\"并在条件合适的情况下进行索引查询和优化\",{\"1\":{\"161\":1}}],[\"并在数据库启动时遍历所有页面\",{\"1\":{\"112\":1}}],[\"并在写入文件系统后返回新建页面的页号\",{\"1\":{\"101\":1}}],[\"并在修改操作前后执行保存原始数据\",{\"1\":{\"64\":1}}],[\"并在后续操作中加载它\",{\"1\":{\"44\":1}}],[\"并为上层模块提供访问接口\",{\"1\":{\"64\":1}}],[\"并通过特定的方式管理和访问\",{\"1\":{\"299\":1}}],[\"并通过具体的代码示例展示其实现细节\",{\"1\":{\"280\":1}}],[\"并通过一个锁表\",{\"1\":{\"279\":1}}],[\"并通过深度优先搜索\",{\"1\":{\"278\":1}}],[\"并通过\",{\"1\":{\"58\":1,\"251\":1}}],[\"并通过多版本并发控制\",{\"1\":{\"9\":1,\"176\":1,\"295\":1}}],[\"并增加引用计数\",{\"1\":{\"57\":1}}],[\"并清理过期的会话及其数据库文件\",{\"1\":{\"46\":1}}],[\"并循环接收来自客户端的数据进行处理\",{\"1\":{\"36\":1}}],[\"并且尚未被删除\",{\"1\":{\"286\":1,\"288\":1}}],[\"并且其状态被准确记录下来\",{\"1\":{\"245\":1}}],[\"并且在创建表时会考虑到字段的各种约束条件\",{\"1\":{\"209\":1}}],[\"并且在内存中以对象的形式存储\",{\"1\":{\"133\":1}}],[\"并且在运行过程中有效管理页面的空闲空间\",{\"1\":{\"121\":1}}],[\"并且在application\",{\"1\":{\"13\":1,\"180\":1}}],[\"并且提供了一套完整的通信机制和核心类\",{\"1\":{\"26\":1}}],[\"并有效地进行数据管理和查询\",{\"1\":{\"24\":1}}],[\"并将资源分配给其他等待的事务\",{\"1\":{\"269\":1}}],[\"并将这些信息存储在数据库中\",{\"1\":{\"219\":1}}],[\"并将pg的offset设置为较大的offset\",{\"1\":{\"106\":1}}],[\"并将\",{\"1\":{\"86\":1}}],[\"并将需要持久化的数据写回数据源\",{\"1\":{\"59\":1}}],[\"并将必要的数据写回磁盘\",{\"1\":{\"53\":1}}],[\"并将其与旧版本一起存储\",{\"1\":{\"275\":1}}],[\"并将其与实际长度进行对比\",{\"1\":{\"242\":1}}],[\"并将其转换为可操作的java对象\",{\"1\":{\"210\":1}}],[\"并将其转换为字节数组\",{\"1\":{\"72\":1}}],[\"并将其包装成\",{\"1\":{\"99\":1,\"104\":1}}],[\"并将其添加到页面索引中\",{\"1\":{\"72\":1}}],[\"并将其加载到缓存中\",{\"1\":{\"53\":1}}],[\"并将其存储在\",{\"1\":{\"45\":1}}],[\"并将其发送到后端进行处理\",{\"1\":{\"6\":1,\"173\":1}}],[\"并将语句发送到数据库服务进行处理\",{\"1\":{\"14\":1,\"181\":1}}],[\"并显示执行结果\",{\"1\":{\"13\":1,\"180\":1}}],[\"内置的日志管理功能确保了所有数据库操作的可追溯性\",{\"1\":{\"2\":1}}],[\"multi\",{\"1\":{\"298\":1}}],[\"ms设置时间为30s\",{\"1\":{\"265\":1}}],[\"ms\",{\"1\":{\"265\":2}}],[\"msg\",{\"1\":{\"32\":3}}],[\"move\",{\"1\":{\"191\":1}}],[\"mergedset\",{\"1\":{\"154\":9}}],[\"mem\",{\"1\":{\"73\":4}}],[\"message\",{\"1\":{\"43\":2,\"196\":4}}],[\"mkdirs\",{\"1\":{\"44\":1}}],[\"mvn\",{\"1\":{\"14\":4,\"181\":4}}],[\"mvcc\",{\"0\":{\"274\":1,\"296\":1,\"298\":1},\"1\":{\"2\":1,\"9\":1,\"176\":1,\"272\":1,\"273\":1,\"274\":2,\"280\":1,\"291\":1,\"295\":1,\"298\":7,\"301\":1}}],[\"map\",{\"1\":{\"266\":1}}],[\"map<long\",{\"1\":{\"91\":1,\"226\":1,\"259\":8,\"290\":2}}],[\"map<string\",{\"1\":{\"43\":1,\"45\":1,\"46\":1,\"157\":1,\"158\":1,\"159\":1,\"221\":2,\"226\":1}}],[\"management\",{\"1\":{\"231\":1}}],[\"manager\",{\"0\":{\"309\":1},\"1\":{\"8\":5,\"9\":5,\"129\":1,\"142\":3,\"165\":1,\"175\":5,\"176\":5,\"207\":1,\"272\":1,\"295\":2,\"309\":1}}],[\"match\",{\"1\":{\"199\":1}}],[\"maxpgno\",{\"1\":{\"98\":1}}],[\"maxresource\",{\"1\":{\"57\":2}}],[\"max\",{\"1\":{\"46\":4,\"72\":2,\"143\":1,\"144\":1,\"155\":1}}],[\"mainclass=\",{\"1\":{\"14\":3,\"181\":3}}],[\"main\",{\"1\":{\"13\":1,\"16\":1,\"37\":1,\"180\":1,\"183\":1}}],[\"maven\",{\"1\":{\"11\":1,\"178\":1}}],[\"mydb6版权声明\",{\"1\":{\"292\":1,\"305\":1}}],[\"mydb7版权声明\",{\"1\":{\"269\":1,\"317\":1}}],[\"mydb1版权声明\",{\"1\":{\"251\":1}}],[\"mydb10版权声明\",{\"1\":{\"37\":1}}],[\"mydb9版权声明\",{\"1\":{\"191\":1,\"222\":1,\"228\":1}}],[\"mydb8版权声明\",{\"1\":{\"148\":1}}],[\"mydb3版权声明\",{\"1\":{\"107\":1,\"126\":1}}],[\"mydb4版权声明\",{\"1\":{\"92\":1}}],[\"mydb5版权声明\",{\"1\":{\"74\":1,\"117\":1}}],[\"mydb2版权声明\",{\"1\":{\"60\":1,\"138\":1}}],[\"mydb0版权声明\",{\"1\":{\"17\":1,\"184\":1}}],[\"mydb\",{\"1\":{\"3\":2,\"4\":3,\"13\":1,\"14\":2,\"16\":4,\"17\":1,\"37\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"170\":2,\"171\":3,\"180\":1,\"181\":2,\"183\":4,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"mysql\",{\"1\":{\"1\":1,\"26\":1,\"29\":1}}],[\"bt文件中\",{\"1\":{\"208\":1}}],[\"bt\",{\"1\":{\"186\":1,\"187\":4,\"188\":2,\"190\":1,\"191\":1,\"217\":1,\"220\":3}}],[\"bplustree\",{\"1\":{\"143\":1,\"146\":1,\"217\":1,\"220\":3}}],[\"b\",{\"1\":{\"80\":2,\"86\":4}}],[\"back\",{\"1\":{\"267\":1}}],[\"backend\",{\"1\":{\"14\":2,\"15\":1,\"16\":1,\"29\":1,\"49\":1,\"63\":2,\"77\":2,\"95\":1,\"110\":1,\"120\":1,\"132\":1,\"141\":1,\"151\":1,\"181\":2,\"182\":1,\"183\":1,\"186\":1,\"213\":1,\"225\":1,\"233\":1,\"254\":1,\"282\":1,\"295\":1,\"308\":1}}],[\"badxidfileexception\",{\"1\":{\"242\":3}}],[\"bad\",{\"1\":{\"82\":1}}],[\"badlogfileexception\",{\"1\":{\"82\":1}}],[\"badtail\",{\"1\":{\"79\":2,\"81\":1,\"82\":4}}],[\"basicfileattributes\",{\"1\":{\"46\":1}}],[\"be\",{\"1\":{\"267\":1}}],[\"before\",{\"1\":{\"66\":2,\"146\":1,\"305\":1}}],[\"beforehandshake\",{\"1\":{\"45\":1}}],[\"beginres\",{\"1\":{\"226\":1}}],[\"begin\",{\"0\":{\"245\":1},\"1\":{\"23\":2,\"196\":1,\"203\":8,\"226\":3,\"238\":2,\"245\":2,\"251\":1,\"309\":1,\"311\":3}}],[\"boolean>\",{\"1\":{\"56\":1,\"259\":1,\"290\":1}}],[\"boolean\",{\"1\":{\"44\":1,\"45\":1,\"46\":2,\"97\":1,\"123\":2,\"158\":3,\"159\":1,\"161\":1,\"198\":1,\"219\":6,\"220\":4,\"238\":3,\"249\":1,\"262\":3,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"290\":2,\"292\":1,\"309\":1,\"313\":1,\"316\":1}}],[\"booter\",{\"0\":{\"186\":1},\"1\":{\"186\":1,\"187\":2,\"188\":4,\"189\":7,\"191\":3,\"226\":7,\"227\":1},\"2\":{\"193\":1,\"212\":1}}],[\"bootlock\",{\"1\":{\"146\":4}}],[\"bootdataitem\",{\"1\":{\"146\":6}}],[\"boot\",{\"1\":{\"2\":1,\"13\":5,\"180\":5}}],[\"break\",{\"1\":{\"36\":2,\"57\":1,\"72\":1,\"82\":1,\"90\":1,\"91\":1,\"145\":2,\"155\":1,\"268\":1}}],[\"buf\",{\"1\":{\"33\":4,\"81\":2,\"83\":5,\"100\":2,\"104\":3,\"242\":3,\"246\":2,\"247\":2,\"249\":3}}],[\"bufferedwriter\",{\"1\":{\"33\":2}}],[\"bufferedreader\",{\"1\":{\"33\":3}}],[\"bytebuffer\",{\"1\":{\"81\":4,\"83\":12,\"100\":2,\"104\":2,\"242\":2,\"246\":2,\"247\":2,\"249\":3}}],[\"bytes\",{\"1\":{\"32\":2,\"72\":2,\"83\":2,\"303\":1}}],[\"byte\",{\"1\":{\"31\":1,\"32\":4,\"33\":4,\"34\":2,\"36\":2,\"37\":2,\"65\":1,\"72\":15,\"80\":2,\"82\":1,\"83\":11,\"89\":2,\"90\":1,\"91\":2,\"92\":3,\"97\":1,\"98\":1,\"101\":1,\"104\":1,\"106\":2,\"123\":3,\"125\":2,\"126\":1,\"134\":2,\"136\":5,\"144\":4,\"146\":1,\"157\":1,\"190\":1,\"191\":1,\"196\":1,\"216\":1,\"221\":1,\"226\":8,\"227\":1,\"228\":1,\"240\":3,\"246\":3,\"249\":2,\"303\":5,\"304\":3,\"309\":2,\"314\":1,\"315\":2}}],[\"by\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"198\":4,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"blockcloth版权声明\",{\"1\":{\"46\":1,\"161\":1,\"203\":1}}],[\"blockcloth本文内容转载自\",{\"1\":{\"37\":1}}],[\"blockcloth部分内容转载自\",{\"1\":{\"17\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"blockcloth\",{\"1\":{\"3\":1,\"13\":1,\"17\":1,\"24\":2,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"161\":1,\"170\":1,\"180\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"b+树\",{\"1\":{\"217\":1}}],[\"b+\",{\"1\":{\"2\":1,\"9\":1,\"142\":3,\"143\":2,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"165\":1,\"166\":2,\"176\":1}}],[\"支持手动和自动回滚\",{\"1\":{\"313\":1}}],[\"支持数据修改和事务管理\",{\"1\":{\"74\":1}}],[\"支持数据的修改操作\",{\"1\":{\"64\":1}}],[\"支持事务管理\",{\"1\":{\"68\":1}}],[\"支持多版本控制\",{\"1\":{\"301\":1}}],[\"支持多个\",{\"1\":{\"46\":1}}],[\"支持多重代理的情况下正确识别\",{\"1\":{\"45\":1}}],[\"支持多种事务隔离级别\",{\"1\":{\"2\":1}}],[\"支持客户端通过\",{\"1\":{\"26\":1}}],[\"支持的数据类型\",{\"1\":{\"21\":1}}],[\"支持两种事务隔离级别\",{\"1\":{\"9\":1,\"176\":1}}],[\"支持唯一性\",{\"1\":{\"2\":1}}],[\"支持\",{\"1\":{\"2\":1}}],[\"高效的数据操作接口\",{\"1\":{\"74\":1}}],[\"高效的数据管理\",{\"1\":{\"2\":1}}],[\"高性能的\",{\"1\":{\"1\":1}}],[\"极大地提升开发效率\",{\"1\":{\"2\":1}}],[\"snapshot\",{\"1\":{\"290\":4}}],[\"switch\",{\"1\":{\"158\":1,\"159\":1}}],[\"sonn\",{\"1\":{\"143\":2}}],[\"son1\",{\"1\":{\"143\":1}}],[\"son0\",{\"1\":{\"143\":1}}],[\"socket\",{\"1\":{\"7\":1,\"26\":3,\"29\":1,\"33\":9,\"36\":2,\"37\":5,\"174\":1,\"181\":1},\"2\":{\"28\":1,\"39\":1}}],[\"single\",{\"1\":{\"161\":2}}],[\"singleexp\",{\"1\":{\"159\":6}}],[\"singleexpression\",{\"1\":{\"159\":1,\"161\":1}}],[\"singleexp2\",{\"1\":{\"154\":6,\"158\":2}}],[\"singleexp1\",{\"1\":{\"154\":3,\"158\":1}}],[\"siblinguid\",{\"1\":{\"143\":2,\"145\":6}}],[\"size的字节数组\",{\"1\":{\"246\":1}}],[\"size的bytebuffer\",{\"1\":{\"104\":1}}],[\"size\",{\"1\":{\"72\":3,\"79\":2,\"81\":1,\"83\":10,\"91\":1,\"104\":1,\"113\":1,\"114\":1,\"125\":1,\"144\":4,\"199\":2,\"202\":1,\"240\":1,\"243\":1,\"246\":1,\"249\":2,\"251\":1,\"268\":4}}],[\"simplefilevisitor<path>\",{\"1\":{\"46\":1}}],[\"simpledb\",{\"1\":{\"14\":3,\"15\":2,\"16\":1,\"17\":1,\"29\":2,\"40\":1,\"49\":1,\"63\":2,\"77\":2,\"95\":1,\"110\":1,\"120\":1,\"132\":1,\"141\":1,\"151\":1,\"181\":3,\"182\":2,\"183\":1,\"184\":1,\"186\":1,\"213\":1,\"225\":1,\"233\":1,\"254\":1,\"282\":1,\"295\":1,\"308\":1}}],[\"simplesqldatabaseapplication\",{\"1\":{\"13\":2,\"180\":2}}],[\"sleep\",{\"1\":{\"57\":1,\"265\":1}}],[\"slf4j\",{\"1\":{\"43\":1}}],[\"scheduled\",{\"1\":{\"46\":2}}],[\"sp\",{\"1\":{\"288\":6,\"292\":1}}],[\"spacesize\",{\"1\":{\"72\":3,\"114\":2}}],[\"space\",{\"1\":{\"72\":2}}],[\"split\",{\"1\":{\"45\":1}}],[\"springapplication\",{\"1\":{\"13\":1,\"180\":1}}],[\"springbootapplication\",{\"1\":{\"13\":1,\"180\":1}}],[\"springboot\",{\"0\":{\"13\":1,\"180\":1},\"1\":{\"7\":1,\"174\":1}}],[\"spring\",{\"1\":{\"2\":1,\"13\":5,\"41\":1,\"180\":5}}],[\"system\",{\"1\":{\"44\":1,\"46\":3,\"66\":2,\"72\":1,\"106\":2,\"123\":2,\"125\":1,\"126\":1,\"136\":6,\"146\":1,\"260\":1,\"266\":1,\"267\":1,\"290\":1,\"304\":1,\"305\":1,\"312\":2}}],[\"suffix\",{\"1\":{\"188\":2,\"189\":3,\"191\":3,\"240\":1,\"251\":1}}],[\"supportedtype\",{\"1\":{\"160\":2}}],[\"suppresswarnings\",{\"1\":{\"159\":1}}],[\"super\",{\"1\":{\"72\":2,\"146\":3,\"235\":1,\"240\":1,\"251\":1,\"290\":1,\"314\":1,\"316\":1}}],[\"substring\",{\"1\":{\"196\":1,\"203\":1}}],[\"sub2\",{\"1\":{\"136\":3}}],[\"sub1\",{\"1\":{\"136\":4}}],[\"subarray2\",{\"1\":{\"136\":1,\"137\":2}}],[\"subarray1\",{\"1\":{\"136\":1,\"137\":2}}],[\"subarray\",{\"0\":{\"134\":1},\"1\":{\"64\":1,\"65\":1,\"66\":2,\"129\":1,\"132\":1,\"133\":2,\"134\":4,\"135\":1,\"136\":22,\"137\":1,\"138\":1,\"143\":2,\"144\":4,\"146\":2,\"304\":1,\"305\":1},\"2\":{\"131\":1,\"140\":1}}],[\"submit\",{\"1\":{\"43\":1}}],[\"success\",{\"1\":{\"44\":3}}],[\"s\",{\"0\":{\"30\":1},\"1\":{\"26\":1,\"29\":1}}],[\"search\",{\"1\":{\"154\":3,\"155\":1}}],[\"searchnextres\",{\"1\":{\"145\":3}}],[\"searchnext方法\",{\"1\":{\"145\":1}}],[\"searchnext\",{\"1\":{\"145\":2}}],[\"seek\",{\"1\":{\"82\":1}}],[\"seed\",{\"1\":{\"80\":2}}],[\"separator\",{\"1\":{\"44\":2,\"46\":1}}],[\"sessionids\",{\"1\":{\"46\":4}}],[\"sessionid\",{\"1\":{\"43\":6,\"44\":4,\"46\":10}}],[\"session\",{\"1\":{\"43\":7,\"44\":5,\"46\":10}}],[\"sessionexecutormap\",{\"1\":{\"43\":2}}],[\"sendmessage\",{\"1\":{\"43\":1,\"44\":3}}],[\"send\",{\"1\":{\"33\":1,\"34\":3,\"36\":1,\"37\":1}}],[\"servletrequest\",{\"1\":{\"45\":2}}],[\"servletserverhttprequest\",{\"1\":{\"45\":2}}],[\"serverhttpresponse\",{\"1\":{\"45\":2}}],[\"serverhttprequest\",{\"1\":{\"45\":2}}],[\"serversocket\",{\"1\":{\"36\":1}}],[\"server\",{\"1\":{\"26\":1,\"29\":1,\"32\":1}}],[\"serializable\",{\"1\":{\"23\":1,\"283\":1,\"289\":2,\"292\":1,\"311\":1,\"312\":1,\"313\":2}}],[\"setxmax\",{\"1\":{\"305\":1,\"316\":1}}],[\"setrawkthkey\",{\"1\":{\"144\":2}}],[\"setrawkthson\",{\"1\":{\"144\":2}}],[\"setrawsibling\",{\"1\":{\"144\":2}}],[\"setrawnokeys\",{\"1\":{\"144\":2}}],[\"setrawisleaf\",{\"1\":{\"144\":2}}],[\"setdataitemrawinvalid\",{\"1\":{\"92\":1}}],[\"setdirty\",{\"1\":{\"66\":1,\"72\":1,\"100\":1,\"105\":1,\"106\":2,\"123\":2,\"126\":1}}],[\"setvcopen\",{\"1\":{\"73\":1,\"123\":3}}],[\"setvcclose\",{\"1\":{\"72\":1,\"123\":3}}],[\"setfso\",{\"1\":{\"72\":1,\"106\":1,\"125\":1,\"126\":1}}],[\"set<long>\",{\"1\":{\"59\":1,\"154\":3}}],[\"set<string>\",{\"1\":{\"46\":1,\"219\":3}}],[\"setexecutor\",{\"1\":{\"46\":1}}],[\"setter\",{\"1\":{\"46\":1}}],[\"set\",{\"1\":{\"22\":1}}],[\"selectnewxid\",{\"1\":{\"267\":1,\"268\":2}}],[\"selectexpressionitem\",{\"1\":{\"198\":2}}],[\"selectitem\",{\"1\":{\"198\":4}}],[\"selectvisitoradapter\",{\"1\":{\"198\":1}}],[\"selectobj\",{\"1\":{\"198\":3}}],[\"select\",{\"1\":{\"22\":3,\"72\":2,\"114\":2,\"196\":2,\"198\":5,\"210\":1,\"226\":2}}],[\"short2byte\",{\"1\":{\"72\":2,\"125\":1}}],[\"short\",{\"1\":{\"69\":3,\"70\":3,\"72\":5,\"92\":1,\"106\":4,\"125\":3,\"126\":3}}],[\"showstatement\",{\"1\":{\"196\":2}}],[\"show\",{\"1\":{\"21\":2,\"226\":1}}],[\"shell\",{\"1\":{\"37\":5}}],[\"shinya\",{\"1\":{\"17\":1,\"37\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"148\":1,\"184\":1,\"191\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"305\":1,\"317\":1}}],[\"satisfiescondition\",{\"1\":{\"157\":1,\"158\":1}}],[\"sa\",{\"1\":{\"17\":1,\"37\":1,\"46\":1,\"60\":1,\"74\":1,\"92\":1,\"107\":1,\"117\":1,\"126\":1,\"138\":1,\"146\":4,\"148\":1,\"161\":1,\"184\":1,\"191\":1,\"203\":1,\"222\":1,\"228\":1,\"251\":1,\"269\":1,\"292\":1,\"304\":5,\"305\":4,\"317\":1}}],[\"stp\",{\"1\":{\"262\":5}}],[\"stream\",{\"1\":{\"156\":1,\"160\":1}}],[\"string2entry\",{\"1\":{\"221\":1}}],[\"string2value\",{\"1\":{\"159\":2,\"160\":1}}],[\"string\",{\"1\":{\"13\":1,\"32\":2,\"33\":4,\"37\":1,\"43\":6,\"44\":4,\"45\":3,\"46\":14,\"73\":2,\"156\":1,\"159\":2,\"160\":2,\"180\":1,\"188\":3,\"189\":3,\"196\":4,\"198\":4,\"199\":3,\"202\":7,\"203\":2,\"216\":1,\"217\":2,\"219\":3,\"220\":2,\"240\":1}}],[\"stamp++\",{\"1\":{\"262\":1}}],[\"stamp\",{\"1\":{\"262\":4}}],[\"standardcopyoption\",{\"1\":{\"191\":1}}],[\"startindex\",{\"1\":{\"196\":3}}],[\"startswith\",{\"1\":{\"196\":1}}],[\"start+8\",{\"1\":{\"146\":1}}],[\"start\",{\"1\":{\"66\":3,\"134\":5,\"136\":1,\"146\":2,\"265\":1,\"304\":2,\"305\":1}}],[\"starttimeoutdeadlockchecker\",{\"1\":{\"265\":1}}],[\"starttime\",{\"1\":{\"46\":5,\"266\":2,\"290\":2}}],[\"status\",{\"1\":{\"216\":1,\"246\":2,\"249\":3}}],[\"statement\",{\"1\":{\"196\":5}}],[\"stat\",{\"1\":{\"37\":2}}],[\"static\",{\"1\":{\"13\":1,\"37\":1,\"46\":3,\"69\":1,\"72\":3,\"73\":2,\"89\":2,\"90\":1,\"91\":1,\"92\":2,\"106\":2,\"113\":2,\"123\":6,\"125\":4,\"126\":1,\"144\":2,\"180\":1,\"188\":2,\"189\":3,\"196\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":3,\"219\":1,\"220\":1,\"240\":7,\"284\":1,\"286\":1,\"288\":1,\"289\":1,\"290\":1,\"292\":1,\"301\":4,\"303\":1}}],[\"sql解析与事务处理\",{\"0\":{\"210\":1}}],[\"sql\",{\"0\":{\"197\":1},\"1\":{\"7\":3,\"9\":1,\"13\":1,\"14\":1,\"17\":1,\"19\":1,\"22\":1,\"26\":2,\"29\":1,\"36\":2,\"37\":1,\"41\":1,\"42\":1,\"43\":11,\"174\":3,\"176\":1,\"180\":1,\"181\":1,\"184\":1,\"194\":2,\"195\":4,\"196\":13,\"203\":10}}],[\"sqlite\",{\"1\":{\"1\":1}}],[\"轻量化构建\",{\"1\":{\"2\":1}}],[\"🚀\",{\"0\":{\"2\":1}}],[\"和读操作\",{\"1\":{\"297\":1}}],[\"和串行化\",{\"1\":{\"283\":1}}],[\"和删除该版本的事务编号\",{\"1\":{\"275\":1}}],[\"和状态写入\",{\"1\":{\"251\":1}}],[\"和一个状态\",{\"1\":{\"249\":1}}],[\"和数据管理器\",{\"1\":{\"226\":1}}],[\"和更新\",{\"1\":{\"187\":1}}],[\"和更新现有数据\",{\"1\":{\"85\":1}}],[\"和全表扫描\",{\"1\":{\"165\":1}}],[\"和撤销\",{\"1\":{\"84\":1}}],[\"和偏移量\",{\"1\":{\"69\":1}}],[\"和页面内偏移量\",{\"1\":{\"69\":1}}],[\"和两阶段锁协议\",{\"1\":{\"2\":1}}],[\"和\",{\"1\":{\"1\":1,\"26\":1,\"33\":1,\"34\":2,\"69\":1,\"73\":1,\"74\":1,\"83\":1,\"87\":2,\"99\":1,\"106\":1,\"107\":1,\"133\":2,\"134\":1,\"136\":1,\"143\":1,\"144\":1,\"145\":1,\"189\":1,\"203\":1,\"246\":1,\"249\":1,\"251\":5,\"255\":3,\"297\":1,\"298\":1,\"304\":2}}],[\"灵感来源于\",{\"1\":{\"1\":1}}],[\"欢迎使用\",{\"0\":{\"1\":1}}],[\"🎉\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
